[
  {
    "snippet": "import copy",
    "span": [
      9,
      9
    ],
    "start_byte": 160,
    "end_byte": 171,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "copy",
    "qualified_name": "copy",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 11,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import logging",
    "span": [
      10,
      10
    ],
    "start_byte": 172,
    "end_byte": 186,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "logging",
    "qualified_name": "logging",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 14,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import os",
    "span": [
      11,
      11
    ],
    "start_byte": 187,
    "end_byte": 196,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "os",
    "qualified_name": "os",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 9,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import pathlib",
    "span": [
      12,
      12
    ],
    "start_byte": 197,
    "end_byte": 211,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "pathlib",
    "qualified_name": "pathlib",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 14,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import queue",
    "span": [
      13,
      13
    ],
    "start_byte": 212,
    "end_byte": 224,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "queue",
    "qualified_name": "queue",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 12,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import re",
    "span": [
      14,
      14
    ],
    "start_byte": 225,
    "end_byte": 234,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "re",
    "qualified_name": "re",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 9,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import socket",
    "span": [
      15,
      15
    ],
    "start_byte": 235,
    "end_byte": 248,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "socket",
    "qualified_name": "socket",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 13,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import threading",
    "span": [
      16,
      16
    ],
    "start_byte": 249,
    "end_byte": 265,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "threading",
    "qualified_name": "threading",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 16,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import time",
    "span": [
      17,
      17
    ],
    "start_byte": 266,
    "end_byte": 277,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "time",
    "qualified_name": "time",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 11,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "from functools import partial",
    "span": [
      18,
      18
    ],
    "start_byte": 278,
    "end_byte": 307,
    "node_type": "import_from_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "partial",
    "qualified_name": "partial",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 29,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "from typing import Union",
    "span": [
      19,
      19
    ],
    "start_byte": 308,
    "end_byte": 332,
    "node_type": "import_from_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "Union",
    "qualified_name": "Union",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 24,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "from unittest import mock",
    "span": [
      20,
      20
    ],
    "start_byte": 333,
    "end_byte": 358,
    "node_type": "import_from_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "mock",
    "qualified_name": "mock",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 25,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import pytest",
    "span": [
      22,
      22
    ],
    "start_byte": 360,
    "end_byte": 373,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "pytest",
    "qualified_name": "pytest",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 13,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import yaml",
    "span": [
      23,
      23
    ],
    "start_byte": 374,
    "end_byte": 385,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "yaml",
    "qualified_name": "yaml",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 11,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import mecademicpy._robot_base as mdrb",
    "span": [
      25,
      25
    ],
    "start_byte": 387,
    "end_byte": 425,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "mecademicpy._robot_base as mdrb",
    "qualified_name": "mecademicpy._robot_base as mdrb",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 38,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import mecademicpy.robot as mdr",
    "span": [
      26,
      26
    ],
    "start_byte": 426,
    "end_byte": 457,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "mecademicpy.robot as mdr",
    "qualified_name": "mecademicpy.robot as mdr",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 31,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "import mecademicpy.robot_trajectory_files as robot_files",
    "span": [
      27,
      27
    ],
    "start_byte": 458,
    "end_byte": 514,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "mecademicpy.robot_trajectory_files as robot_files",
    "qualified_name": "mecademicpy.robot_trajectory_files as robot_files",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 56,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "from mecademicpy.mx_robot_def import MX_ROBOT_TCP_PORT_CONTROL, MX_ROBOT_TCP_PORT_FEED, MxExtToolType, MxIoBankId",
    "span": [
      28,
      28
    ],
    "start_byte": 515,
    "end_byte": 628,
    "node_type": "import_from_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "MX_ROBOT_TCP_PORT_CONTROL",
    "qualified_name": "MX_ROBOT_TCP_PORT_CONTROL",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 113,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "from mecademicpy.mx_robot_def import MxRobotStatusCode as mx_st",
    "span": [
      29,
      29
    ],
    "start_byte": 629,
    "end_byte": 692,
    "node_type": "import_from_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "MxRobotStatusCode as mx_st",
    "qualified_name": "MxRobotStatusCode as mx_st",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 63,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def connect_robot_helper(robot: mdr.Robot,\n                         yaml_filename='meca500_r3_v9.yml',\n                         monitor_mode=False,\n                         offline_mode=True,\n                         disconnect_on_exception=False,\n                         enable_synchronous_mode=False):\n    \"\"\"Utility function to simulate a connection to the robot\"\"\"\n\n    file_path = pathlib.Path.cwd().joinpath('tests', 'robot_config')\n    yaml_file_full_path = pathlib.Path.joinpath(file_path, yaml_filename)\n\n    with open(yaml_file_full_path, 'r', encoding='utf-8') as file_stream:\n        robot_config = yaml.safe_load(file_stream)\n\n        # Set connection message\n        # pylint: disable=protected-access\n        rx_queue = robot._monitor_rx_queue if monitor_mode else robot._command_rx_queue\n        rx_queue.put(mdr.Message(mx_st.MX_ST_CONNECTED, robot_config['expected_connection_message']))\n\n        expected_commands = []\n        robot_responses = []\n        if not monitor_mode and robot_config['expected_connect_commands']:\n            # Set robot command responses\n            for transaction in robot_config['expected_connect_commands']:\n                expected_commands.append(transaction['name'])\n                cmd_responses = []\n                cmd_responses.append(mdr.Message(transaction['response_code'], transaction['response']))\n                if 'extra_event' in transaction:\n                    cmd_responses.append(mdr.Message(transaction['extra_event'], transaction['extra_event_data']))\n                robot_responses.append(cmd_responses)\n\n        # Start the fake robot thread (that will simulate response to expected requests)\n        # pylint: disable=protected-access\n        fake_robot = threading.Thread(target=simple_response_handler,\n                                      args=(robot._command_tx_queue, robot._command_rx_queue, expected_commands,\n                                            robot_responses))\n\n        fake_robot.start()\n\n        robot._Connect(TEST_IP,\n                       offline_mode=offline_mode,\n                       disconnect_on_exception=disconnect_on_exception,\n                       enable_synchronous_mode=enable_synchronous_mode,\n                       monitor_mode=monitor_mode)\n\n        fake_robot.join()\n\n        robot.WaitConnected(timeout=0)",
    "span": [
      70,
      117
    ],
    "start_byte": 2163,
    "end_byte": 4491,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "connect_robot_helper",
    "qualified_name": "connect_robot_helper",
    "signature": "connect_robot_helper(robot: mdr.Robot,\n                         yaml_filename='meca500_r3_v9.yml',\n                         monitor_mode=False,\n                         offline_mode=True,\n                         disconnect_on_exception=False,\n                         enable_synchronous_mode=False)",
    "docstring": "Utility function to simulate a connection to the robot",
    "chunk_size_bytes": 2328,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def simple_response_handler(queue_in: queue.Queue, queue_out: queue.Queue, expected_in: list[str],\n                            desired_out: Union[list[list[mdr.Message]], list[mdr.Message]]):\n    \"\"\"Simulated handler that simulates responses that the robot send to queued requests\"\"\"\n    if isinstance(expected_in, list):\n        for i, expected_val in enumerate(expected_in):\n            event = queue_in.get(block=True, timeout=1)\n            assert event == expected_val\n            if isinstance(desired_out[i], list):\n                desired_list: list = desired_out\n                for response in desired_list[i]:\n                    queue_out.put(response)\n            else:\n                queue_out.put(desired_out[i])\n\n    else:\n        event = queue_in.get(block=True, timeout=1)\n        assert event == expected_in\n        queue_out.put(desired_out)",
    "span": [
      121,
      138
    ],
    "start_byte": 4544,
    "end_byte": 5406,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "simple_response_handler",
    "qualified_name": "simple_response_handler",
    "signature": "simple_response_handler(queue_in: queue.Queue, queue_out: queue.Queue, expected_in: list[str],\n                            desired_out: Union[list[list[mdr.Message]], list[mdr.Message]])",
    "docstring": "Simulated handler that simulates responses that the robot send to queued requests",
    "chunk_size_bytes": 862,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def fake_server(address, port, data_list, server_up):\n    \"\"\" Server to listen for a connection. Send initial data in data_list on connect,\n    send rest in response to any msg.  \"\"\"\n    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_sock.settimeout(10)  # Allow up to 10 seconds to create the connection.\n    server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_sock.bind((address, port))\n    server_sock.listen()\n    server_up.set()\n\n    # pylint: disable=unused-variable\n    client, addr = server_sock.accept()\n\n    if data_list:\n        client.sendall(data_list.pop(0).encode('ascii'))\n\n    while True:\n        received_data = client.recv(1024)\n        if not received_data:\n            break\n        if len(received_data) > 1 and data_list:\n            client.sendall(data_list.pop(0).encode('ascii'))",
    "span": [
      141,
      162
    ],
    "start_byte": 5409,
    "end_byte": 6267,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "fake_server",
    "qualified_name": "fake_server",
    "signature": "fake_server(address, port, data_list, server_up)",
    "docstring": "Server to listen for a connection. Send initial data in data_list on connect,\n    send rest in response to any msg.",
    "chunk_size_bytes": 858,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def run_fake_server(address, port, data_list):\n    server_up_event = threading.Event()  # Synchronization event for fake server.\n    server_thread = threading.Thread(target=fake_server, args=(address, port, data_list, server_up_event))\n    server_thread.start()\n    assert server_up_event.wait(timeout=DEFAULT_TIMEOUT)\n    return server_thread",
    "span": [
      166,
      171
    ],
    "start_byte": 6314,
    "end_byte": 6657,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "run_fake_server",
    "qualified_name": "run_fake_server",
    "signature": "run_fake_server(address, port, data_list)",
    "docstring": null,
    "chunk_size_bytes": 343,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "class FakeSocket():\n\n    def __init__(self, input_data):\n        self.queue = queue.Queue()\n        for x in input_data:\n            self.queue.put(x)\n\n    def setblocking(self, _):\n        pass\n\n    def recv(self, _):",
    "span": [
      175,
      186
    ],
    "start_byte": 6764,
    "end_byte": 7014,
    "node_type": "class_definition",
    "chunk_type": "class",
    "language": "python",
    "name": "FakeSocket",
    "qualified_name": "FakeSocket",
    "docstring": null,
    "chunk_size_bytes": 218,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def __init__(self, input_data):\n        self.queue = queue.Queue()\n        for x in input_data:\n            self.queue.put(x)",
    "span": [
      177,
      180
    ],
    "start_byte": 6789,
    "end_byte": 6914,
    "node_type": "function_definition",
    "chunk_type": "method",
    "language": "python",
    "name": "__init__",
    "signature": "__init__(self, input_data)",
    "parent_class": "FakeSocket",
    "qualified_name": "FakeSocket.__init__",
    "docstring": null,
    "chunk_size_bytes": 125,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def setblocking(self, _):\n        pass",
    "span": [
      182,
      183
    ],
    "start_byte": 6920,
    "end_byte": 6958,
    "node_type": "function_definition",
    "chunk_type": "method",
    "language": "python",
    "name": "setblocking",
    "signature": "setblocking(self, _)",
    "parent_class": "FakeSocket",
    "qualified_name": "FakeSocket.setblocking",
    "docstring": null,
    "chunk_size_bytes": 38,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def recv(self, _):\n        return self.queue.get()",
    "span": [
      185,
      186
    ],
    "start_byte": 6964,
    "end_byte": 7014,
    "node_type": "function_definition",
    "chunk_type": "method",
    "language": "python",
    "name": "recv",
    "signature": "recv(self, _)",
    "parent_class": "FakeSocket",
    "qualified_name": "FakeSocket.recv",
    "docstring": null,
    "chunk_size_bytes": 50,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_setup_invalid_input(robot: mdr.Robot):\n    with pytest.raises(mdr.CommunicationError):\n        robot.Connect('1.1.1.1.1')",
    "span": [
      195,
      197
    ],
    "start_byte": 7269,
    "end_byte": 7399,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_setup_invalid_input",
    "qualified_name": "test_setup_invalid_input",
    "signature": "test_setup_invalid_input(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 130,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_connection_no_robot(robot: mdr.Robot):\n    robot.default_timeout = 0\n\n    with pytest.raises((mdr.CommunicationError, TimeoutError, ConnectionRefusedError)):\n        robot.Connect(TEST_IP)",
    "span": [
      201,
      205
    ],
    "start_byte": 7520,
    "end_byte": 7717,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_connection_no_robot",
    "qualified_name": "test_connection_no_robot",
    "signature": "test_connection_no_robot(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 197,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_successful_connection_full_socket_legacy(robot: mdr.Robot):\n\n    command_server_thread = run_fake_server(TEST_IP, MX_ROBOT_TCP_PORT_CONTROL, [\n        '[3000][Connected to Meca500 R3-virtual v8.3.10]\\0', '[2007][0,0,0,0,1,1,1]\\0', '[2083][m500-99999]\\0',\n        '[2082][v8.3.10.9876-unit-test-fake]\\0', '[2007][0,0,0,0,1,1,1]\\0'\n    ])\n    monitor_server_thread = run_fake_server(TEST_IP, MX_ROBOT_TCP_PORT_FEED, ['\\0'])\n\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitConnected(timeout=0)\n\n    robot.Connect(TEST_IP)\n    robot.WaitConnected()\n\n    assert robot.GetRobotInfo().model == 'Meca500'\n    assert robot.GetRobotInfo().revision == 3\n    assert robot.GetRobotInfo().is_virtual is True\n    assert robot.GetRobotInfo().version.major == 8\n    assert robot.GetRobotInfo().version.minor == 3\n    assert robot.GetRobotInfo().version.patch == 10\n    assert robot.GetRobotInfo().version.build == 9876\n    assert robot.GetRobotInfo().serial == 'm500-99999'\n\n    robot.Disconnect()\n    assert robot._command_socket is None\n    assert robot._monitor_socket is None\n\n    command_server_thread.join()\n    monitor_server_thread.join()",
    "span": [
      210,
      238
    ],
    "start_byte": 7868,
    "end_byte": 9023,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_successful_connection_full_socket_legacy",
    "qualified_name": "test_successful_connection_full_socket_legacy",
    "signature": "test_successful_connection_full_socket_legacy(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 1155,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_successful_connection_split_response(robot: mdr.Robot):\n    # Push \"Connected to\" and empty message (terminated socket)\n    fake_socket = FakeSocket([b'[3', b'00', b'0][Connected to Meca500 R3 v9.0.0]\\0', b''])\n    rx_queue = queue.Queue()\n\n    # Test the socket handler directly to ensure messages are received across several recv() calls.\n    robot._rx_thread_fct(fake_socket, rx_queue)\n\n    assert rx_queue.qsize() == 2  # \"Connected to\" and _TERMINATE\n    message = rx_queue.get()\n    assert message.id == mx_st.MX_ST_CONNECTED\n    assert message.data == MECA500_CONNECTED_RESPONSE",
    "span": [
      242,
      253
    ],
    "start_byte": 9124,
    "end_byte": 9718,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_successful_connection_split_response",
    "qualified_name": "test_successful_connection_split_response",
    "signature": "test_successful_connection_split_response(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 594,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_mcs500_connection(robot: mdr.Robot):\n    connect_robot_helper(robot, yaml_filename='mcs500_r1_v9.yml')\n    assert not robot.GetStatusRobot().activation_state\n    assert robot.GetRobotInfo().model == 'Mcs500'\n    assert robot.GetRobotInfo().num_joints == 4\n    assert robot.GetRobotInfo().version.major == 9\n    assert robot.GetRobotInfo().rt_message_capable\n    assert robot.GetRobotInfo().serial == 'mcs500-87654321'",
    "span": [
      257,
      264
    ],
    "start_byte": 9767,
    "end_byte": 10193,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_mcs500_connection",
    "qualified_name": "test_mcs500_connection",
    "signature": "test_mcs500_connection(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 426,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_mca250_connection(robot: mdr.Robot):\n    connect_robot_helper(robot, yaml_filename='mca250_r1_v10.yml')\n    assert not robot.GetStatusRobot().activation_state\n    assert robot.GetRobotInfo().model == 'Mca250'\n    assert robot.GetRobotInfo().num_joints == 6\n    assert robot.GetRobotInfo().version.major == 10\n    assert robot.GetRobotInfo().rt_message_capable\n    assert robot.GetRobotInfo().serial == 'mca250-250250'",
    "span": [
      268,
      275
    ],
    "start_byte": 10242,
    "end_byte": 10668,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_mca250_connection",
    "qualified_name": "test_mca250_connection",
    "signature": "test_mca250_connection(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 426,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_mca1000_connection(robot: mdr.Robot):\n    connect_robot_helper(robot, yaml_filename='mca1000_r1_v10.yml')\n    assert not robot.GetStatusRobot().activation_state\n    assert robot.GetRobotInfo().model == 'Mca1000'\n    assert robot.GetRobotInfo().num_joints == 6\n    assert robot.GetRobotInfo().version.major == 10\n    assert robot.GetRobotInfo().rt_message_capable\n    assert robot.GetRobotInfo().serial == 'mca1000-10001000'",
    "span": [
      279,
      286
    ],
    "start_byte": 10718,
    "end_byte": 11150,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_mca1000_connection",
    "qualified_name": "test_mca1000_connection",
    "signature": "test_mca1000_connection(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 432,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_7_0_connection(robot: mdr.Robot):\n    connect_robot_helper(robot, yaml_filename='meca500_r3_v7_0.yml')\n    assert not robot.GetStatusRobot().activation_state\n    assert robot.GetRobotInfo().model == 'Meca500'\n    assert robot.GetRobotInfo().num_joints == 6\n    assert robot.GetRobotInfo().version.major == 7\n    assert robot.GetRobotInfo().version.minor == 0\n    assert robot.GetRobotInfo().version.patch == 6\n    assert not robot.GetRobotInfo().rt_message_capable\n    assert not robot.GetRobotInfo().rt_on_ctrl_port_capable\n    assert not robot.GetRobotInfo().gripper_pos_ctrl_capable\n    assert robot.GetRobotInfo().serial == ''",
    "span": [
      290,
      301
    ],
    "start_byte": 11224,
    "end_byte": 11863,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_7_0_connection",
    "qualified_name": "test_7_0_connection",
    "signature": "test_7_0_connection(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 639,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_8_3_connection(robot: mdr.Robot):\n    connect_robot_helper(robot, yaml_filename='meca500_r3_v8_3.yml')\n    assert not robot.GetStatusRobot().activation_state\n    assert robot.GetRobotInfo().model == 'Meca500'\n    assert robot.GetRobotInfo().num_joints == 6\n    assert robot.GetRobotInfo().version.major == 8\n    assert robot.GetRobotInfo().version.minor == 3\n    assert not robot.GetRobotInfo().rt_message_capable\n    assert not robot.GetRobotInfo().rt_on_ctrl_port_capable\n    assert not robot.GetRobotInfo().gripper_pos_ctrl_capable\n    assert robot.GetRobotInfo().serial == 'm500-83'",
    "span": [
      305,
      315
    ],
    "start_byte": 11929,
    "end_byte": 12524,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_8_3_connection",
    "qualified_name": "test_8_3_connection",
    "signature": "test_8_3_connection(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 595,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_8_4_connection(robot: mdr.Robot):\n    connect_robot_helper(robot, yaml_filename='meca500_r3_v8_4.yml')\n    assert not robot.GetStatusRobot().activation_state\n    assert robot.GetRobotInfo().model == 'Meca500'\n    assert robot.GetRobotInfo().num_joints == 6\n    assert robot.GetRobotInfo().version.major == 8\n    assert robot.GetRobotInfo().version.minor == 4\n    assert robot.GetRobotInfo().rt_message_capable\n    assert not robot.GetRobotInfo().rt_on_ctrl_port_capable\n    assert not robot.GetRobotInfo().gripper_pos_ctrl_capable\n    assert robot.GetRobotInfo().serial == 'm500-84'",
    "span": [
      319,
      329
    ],
    "start_byte": 12590,
    "end_byte": 13181,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_8_4_connection",
    "qualified_name": "test_8_4_connection",
    "signature": "test_8_4_connection(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 591,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_9_1_connection(robot: mdr.Robot):\n    connect_robot_helper(robot, yaml_filename='meca500_r3_v9.yml')\n\n    assert not robot.GetStatusRobot().activation_state\n    assert robot.GetRobotInfo().model == 'Meca500'\n    assert robot.GetRobotInfo().num_joints == 6\n    assert robot.GetRobotInfo().version.major == 9\n    assert robot.GetRobotInfo().version.minor == 147\n    assert robot.GetRobotInfo().version.patch == 0\n    assert robot.GetRobotInfo().version.build == 1213\n    assert robot.GetRobotInfo().rt_message_capable\n    assert robot.GetRobotInfo().rt_on_ctrl_port_capable\n    assert robot.GetRobotInfo().serial == 'm500-99999999'\n    assert robot.GetRobotInfo().gripper_pos_ctrl_capable\n    assert robot.GetRobotInfo().ext_tool_version_capable\n    # Not tested here. Tested in test_framework.\n    #assert robot.GetRobotInfo().ext_tool_version.major == 9\n    #assert robot.GetRobotInfo().ext_tool_version.minor == 147\n    #assert robot.GetRobotInfo().ext_tool_version.patch == 0\n    #assert robot.GetRobotInfo().ext_tool_version.build == 1213",
    "span": [
      333,
      352
    ],
    "start_byte": 13258,
    "end_byte": 14308,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_9_1_connection",
    "qualified_name": "test_9_1_connection",
    "signature": "test_9_1_connection(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 1050,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_already_connected(robot: mdr.Robot):\n    connect_robot_helper(robot, yaml_filename='meca500_r3_v9.yml')\n\n    # Try connecting again, should do nothing\n    robot.Connect()\n    assert robot.IsConnected()",
    "span": [
      356,
      361
    ],
    "start_byte": 14380,
    "end_byte": 14590,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_already_connected",
    "qualified_name": "test_already_connected",
    "signature": "test_already_connected(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 210,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_sequential_connections(robot: mdr.Robot):\n\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_USER_ALREADY, ''))\n    with pytest.raises(Exception):\n        robot._Connect(TEST_IP, offline_mode=True, disconnect_on_exception=False)\n\n    robot._command_rx_queue.put(mdr.Message(99999, ''))\n    with pytest.raises(Exception):\n        robot._Connect(TEST_IP, offline_mode=True, disconnect_on_exception=False)\n\n    connect_robot_helper(robot)\n    robot.Disconnect()\n\n    connect_robot_helper(robot)\n    robot.Disconnect()",
    "span": [
      365,
      379
    ],
    "start_byte": 14673,
    "end_byte": 15202,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_sequential_connections",
    "qualified_name": "test_sequential_connections",
    "signature": "test_sequential_connections(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 529,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_monitoring_connection_extra_messages(robot: mdr.Robot):\n    robot._monitor_rx_queue.put(mdr.Message(99999, ''))\n    robot._monitor_rx_queue.put(mdr.Message(99999, ''))\n    robot._monitor_rx_queue.put(mdr.Message(99999, ''))\n    robot._monitor_rx_queue.put(mdr.Message(99999, ''))\n    # Make sure robot connects quickly even if many messages preceding connection message are on monitoring port\n    connect_robot_helper(robot)\n    robot.WaitConnected(timeout=0)",
    "span": [
      382,
      389
    ],
    "start_byte": 15205,
    "end_byte": 15673,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_monitoring_connection_extra_messages",
    "qualified_name": "test_monitoring_connection_extra_messages",
    "signature": "test_monitoring_connection_extra_messages(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 468,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_with_block(robot: mdr.Robot):\n    called_callbacks = []\n\n    def on_connected_test():\n        called_callbacks.append('on_connected_test')\n\n    def on_disconnected_test():\n        called_callbacks.append('on_disconnected_test')\n\n    with mdr.Robot() as robot2:\n        callbacks = mdr.RobotCallbacks()\n        callbacks.on_connected = on_connected_test\n        callbacks.on_disconnected = on_disconnected_test\n        robot2.RegisterCallbacks(callbacks, run_callbacks_in_separate_thread=True)\n\n        # Simulate a connection\n        connect_robot_helper(robot2)\n\n    # Test that connection occurred, and disconnection too (at end of \"with\" block)\n    assert called_callbacks == ['on_connected_test', 'on_disconnected_test']",
    "span": [
      394,
      413
    ],
    "start_byte": 15767,
    "end_byte": 16500,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_with_block",
    "qualified_name": "test_with_block",
    "signature": "test_with_block(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 733,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_with_block_twice(robot: mdr.Robot):\n    called_callbacks = []\n\n    def on_connected_test():\n        called_callbacks.append('on_connected_test')\n\n    def on_disconnected_test():\n        called_callbacks.append('on_disconnected_test')\n\n    # Create robot and attach callbacks\n    robot2 = mdr.Robot()\n    callbacks = mdr.RobotCallbacks()\n    callbacks.on_connected = on_connected_test\n    callbacks.on_disconnected = on_disconnected_test\n    robot2.RegisterCallbacks(callbacks, run_callbacks_in_separate_thread=True)\n\n    # Connect within 'with' block -> Should disconnect but keep callbacks attached\n    with robot2:\n        connect_robot_helper(robot2)\n\n    # Connect again 'with' block -> Should disconnect but keep callbacks attached\n    with robot2:\n        connect_robot_helper(robot2)\n\n    # Test that connection occurred, and disconnection too (at end of \"with\" block)\n    assert called_callbacks == [\n        'on_connected_test', 'on_disconnected_test', 'on_connected_test', 'on_disconnected_test'\n    ]",
    "span": [
      418,
      445
    ],
    "start_byte": 16622,
    "end_byte": 17642,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_with_block_twice",
    "qualified_name": "test_with_block_twice",
    "signature": "test_with_block_twice(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 1020,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_with_pre_connected(robot: mdr.Robot):\n    robot2 = mdr.Robot()\n    connect_robot_helper(robot2)\n    with pytest.raises(mdr.InvalidStateError):\n        with robot2:\n            robot2.Disconnect()",
    "span": [
      450,
      455
    ],
    "start_byte": 17748,
    "end_byte": 17952,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_with_pre_connected",
    "qualified_name": "test_with_pre_connected",
    "signature": "test_with_pre_connected(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 204,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_monitoring_connection(robot: mdr.Robot):\n    connect_robot_helper(robot, monitor_mode=True)\n\n    # Helper functions for generating test data. To ensure data is unique in each field, we add the response code to the\n    # 'seed' array, with is generated with range().\n    def make_test_array(code, data):\n        return [x + code for x in data]\n\n    # Convert the test array into a TimestampedData object.\n    def make_test_data(code, data, update_type):\n        test_array = make_test_array(code, data)\n        return mdr.TimestampedData(test_array[0], test_array[1:], update_type)\n\n    # Convert the test array into a Message object.\n    def make_test_message(code, data):\n        test_array = make_test_array(code, data)\n        return mdr.Message(code, ','.join([str(x) for x in test_array]))\n\n    # Send monitor messages.\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_TARGET_JOINT_POS, range(7)))\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_TARGET_CART_POS, range(7)))\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_TARGET_JOINT_VEL, range(7)))\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_TARGET_CART_VEL, range(7)))\n\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_TARGET_CONF, range(4)))\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_TARGET_CONF_TURN, range(2)))\n\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_JOINT_POS, range(7)))\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_ABS_JOINT_POS, range(7)))\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_CART_POS, range(7)))\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_JOINT_VEL, range(7)))\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_JOINT_TORQ, range(7)))\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_CART_VEL, range(7)))\n\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_CONF, range(4)))",
    "span": [
      459,
      538
    ],
    "start_byte": 18042,
    "end_byte": 23346,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_monitoring_connection_part_1",
    "qualified_name": "test_monitoring_connection_part_1",
    "parent_function": "test_monitoring_connection",
    "chunk_size_bytes": 2000,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_CONF_TURN, range(2)))\n\n    robot._monitor_rx_queue.put(make_test_message(mx_st.MX_ST_RT_ACCELEROMETER, range(5)))\n\n    robot.Disconnect()\n\n    # Temporarily test using direct members, switch to using proper getters once implemented.\n    assert robot._robot_rt_data.rt_target_joint_pos == make_test_data(\n        mx_st.MX_ST_RT_TARGET_JOINT_POS, range(7), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL)\n    assert robot._robot_rt_data.rt_target_cart_pos == make_test_data(\n        mx_st.MX_ST_RT_TARGET_CART_POS, range(7), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL)\n    assert robot._robot_rt_data.rt_target_joint_vel == make_test_data(\n        mx_st.MX_ST_RT_TARGET_JOINT_VEL, range(7), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)\n    assert robot._robot_rt_data.rt_target_cart_vel == make_test_data(\n        mx_st.MX_ST_RT_TARGET_CART_VEL, range(7), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)\n    assert robot._robot_rt_data.rt_target_conf == make_test_data(\n        mx_st.MX_ST_RT_TARGET_CONF, range(4), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n    assert robot._robot_rt_data.rt_target_conf_turn == make_test_data(\n        mx_st.MX_ST_RT_TARGET_CONF_TURN, range(2), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n\n    assert robot._robot_rt_data.rt_joint_pos == make_test_data(\n        mx_st.MX_ST_RT_JOINT_POS, range(7), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)\n    assert robot._robot_rt_data.rt_abs_joint_pos == make_test_data(\n        mx_st.MX_ST_RT_ABS_JOINT_POS, range(7), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)\n    assert robot._robot_rt_data.rt_cart_pos == make_test_data(\n        mx_st.MX_ST_RT_CART_POS, range(7), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)\n    assert robot._robot_rt_data.rt_joint_vel == make_test_data(\n        mx_st.MX_ST_RT_JOINT_VEL, range(7), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)",
    "span": [
      459,
      538
    ],
    "start_byte": 18042,
    "end_byte": 23346,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_monitoring_connection_part_2",
    "qualified_name": "test_monitoring_connection_part_2",
    "parent_function": "test_monitoring_connection",
    "chunk_size_bytes": 2054,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "    assert robot._robot_rt_data.rt_joint_torq == make_test_data(\n        mx_st.MX_ST_RT_JOINT_TORQ, range(7), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)\n    assert robot._robot_rt_data.rt_cart_vel == make_test_data(\n        mx_st.MX_ST_RT_CART_VEL, range(7), mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)\n    assert robot._robot_rt_data.rt_conf == make_test_data(mx_st.MX_ST_RT_CONF, range(4),\n                                                          mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n    assert robot._robot_rt_data.rt_conf_turn == make_test_data(mx_st.MX_ST_RT_CONF_TURN, range(2),\n                                                               mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n\n    # The data is sent as [timestamp, accelerometer_id, {measurements...}].\n    # We convert it to a dictionary which maps the accelerometer_id to a TimestampedData object.\n    accel_array = make_test_array(mx_st.MX_ST_RT_ACCELEROMETER, range(5))\n    assert robot._robot_rt_data.rt_accelerometer == {\n        accel_array[1]:\n        mdr.TimestampedData(accel_array[0], accel_array[2:],\n                            mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)\n    }",
    "span": [
      459,
      538
    ],
    "start_byte": 18042,
    "end_byte": 23346,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_monitoring_connection_part_3",
    "qualified_name": "test_monitoring_connection_part_3",
    "parent_function": "test_monitoring_connection",
    "chunk_size_bytes": 1248,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_user_set_checkpoints(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    # Validate internal checkpoint waiting.\n    checkpoint_1 = robot.SetCheckpoint(1)\n    # Check that the command is sent to the robot.\n    assert robot._command_tx_queue.get() == 'SetCheckpoint(1)'\n    # Check that the id is correct.\n    assert checkpoint_1.id == 1\n    # Check that wait times out if response has not been sent.\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_1.wait(timeout=0)\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_REACHED, '1'))\n    # Check that wait succeeds if response is sent.\n    checkpoint_1.wait(timeout=DEFAULT_TIMEOUT)",
    "span": [
      542,
      556
    ],
    "start_byte": 23443,
    "end_byte": 24119,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_user_set_checkpoints",
    "qualified_name": "test_user_set_checkpoints",
    "signature": "test_user_set_checkpoints(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 676,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_external_checkpoints(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    # Validate external checkpoint waiting.\n    checkpoint_1 = robot.ExpectExternalCheckpoint(1)\n    # Check that the command is not sent to the robot.\n    assert robot._command_tx_queue.qsize() == 0\n    # Check that the id is correct.\n    assert checkpoint_1.id == 1\n    # Check that wait times out if response has not been sent.\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_1.wait(timeout=0)\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_REACHED, '1'))\n    # Check that wait succeeds if response is sent.\n    checkpoint_1.wait(timeout=DEFAULT_TIMEOUT)",
    "span": [
      560,
      574
    ],
    "start_byte": 24230,
    "end_byte": 24906,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_external_checkpoints",
    "qualified_name": "test_external_checkpoints",
    "signature": "test_external_checkpoints(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 676,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_multiple_checkpoints(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    # Validate multiple checkpoints, internal and external.\n    checkpoint_1 = robot.SetCheckpoint(1)\n    checkpoint_2 = robot.SetCheckpoint(2)\n    checkpoint_3 = robot.ExpectExternalCheckpoint(3)\n\n    # All three checkpoints are still pending, check that all three time out.\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_1.wait(timeout=0)\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_2.wait(timeout=0)\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_3.wait(timeout=0)\n\n    # First checkpoint is reached, second two should time out.\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_REACHED, '1'))\n    checkpoint_1.wait(timeout=DEFAULT_TIMEOUT)\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_2.wait(timeout=0)\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_3.wait(timeout=0)\n\n    # First and second checkpoints are reached, last one should time out.\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_REACHED, '2'))\n    checkpoint_1.wait(timeout=DEFAULT_TIMEOUT)\n    checkpoint_2.wait(timeout=DEFAULT_TIMEOUT)\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_3.wait(timeout=0)\n\n    # All checkpoints are reached.\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_REACHED, '3'))\n    checkpoint_3.wait(timeout=DEFAULT_TIMEOUT)\n    checkpoint_2.wait(timeout=DEFAULT_TIMEOUT)\n    checkpoint_1.wait(timeout=DEFAULT_TIMEOUT)",
    "span": [
      578,
      613
    ],
    "start_byte": 24974,
    "end_byte": 26532,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_multiple_checkpoints",
    "qualified_name": "test_multiple_checkpoints",
    "signature": "test_multiple_checkpoints(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 1558,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_repeated_checkpoints(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    checkpoint_1_a = robot.SetCheckpoint(1)\n    checkpoint_1_b = robot.SetCheckpoint(1)\n\n    # Check that wait times out if response has not been sent.\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_1_a.wait(timeout=0)\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_1_b.wait(timeout=0)\n\n    # Only one checkpoint has been returned, the second should still block.\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_REACHED, '1'))\n    with pytest.raises(mdr.TimeoutException):\n        checkpoint_1_b.wait(timeout=0)\n    checkpoint_1_a.wait(timeout=DEFAULT_TIMEOUT)\n\n    # Check that waits succeeds if response is sent.\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_REACHED, '1'))\n    checkpoint_1_b.wait(timeout=DEFAULT_TIMEOUT)\n    checkpoint_1_a.wait(timeout=DEFAULT_TIMEOUT)",
    "span": [
      618,
      639
    ],
    "start_byte": 26663,
    "end_byte": 27593,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_repeated_checkpoints",
    "qualified_name": "test_repeated_checkpoints",
    "signature": "test_repeated_checkpoints(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 930,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_special_checkpoints(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    robot.SetCheckpoint(1)\n    robot.SetCheckpoint(2)\n\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitForAnyCheckpoint(timeout=0)\n\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_REACHED, '1'))\n    robot.WaitForAnyCheckpoint()",
    "span": [
      643,
      653
    ],
    "start_byte": 27627,
    "end_byte": 27970,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_special_checkpoints",
    "qualified_name": "test_special_checkpoints",
    "signature": "test_special_checkpoints(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 343,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_unaccounted_checkpoints(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    # Send unexpected checkpoint.\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_REACHED, '1'))\n\n    # This call will raise an exception if internal states are invalid.\n    robot._check_internal_states()",
    "span": [
      657,
      664
    ],
    "start_byte": 28061,
    "end_byte": 28369,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_unaccounted_checkpoints",
    "qualified_name": "test_unaccounted_checkpoints",
    "signature": "test_unaccounted_checkpoints(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 308,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_stranded_checkpoints(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    checkpoint_1 = robot.SetCheckpoint(1)\n\n    robot.Disconnect()\n\n    # Checkpoint should throw error instead of blocking since robot is already disconnected.\n    with pytest.raises(mdr.InterruptException):\n        checkpoint_1.wait(timeout=DEFAULT_TIMEOUT)",
    "span": [
      668,
      677
    ],
    "start_byte": 28446,
    "end_byte": 28786,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_stranded_checkpoints",
    "qualified_name": "test_stranded_checkpoints",
    "signature": "test_stranded_checkpoints(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 340,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_events(robot: mdr.Robot):\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitActivated(timeout=0)\n    robot.WaitDeactivated()\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitConnected(timeout=0)\n    robot.WaitDisconnected()\n\n    connect_robot_helper(robot)\n\n    robot.WaitConnected()\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitDisconnected(timeout=0)\n\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitActivated(timeout=0)\n    robot.WaitDeactivated()\n\n    robot.ActivateRobot()\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,0,0,0,0,0,0'))\n\n    robot.WaitActivated(timeout=1)\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitDeactivated(timeout=0)\n\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitHomed(timeout=0)\n    robot.Home()\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,0,0,0'))\n    robot.WaitHomed(timeout=1)\n\n    robot.PauseMotion()\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,1,0,0'))\n    # Wait until pause is successfully set.\n    robot.WaitMotionPaused(timeout=DEFAULT_TIMEOUT)\n\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitMotionResumed(timeout=0)\n    robot.ResumeMotion()\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,0,0,0'))\n    robot.WaitMotionResumed(timeout=1)\n\n    robot.ClearMotion()\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CLEAR_MOTION, ''))\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,1,1,1'))\n    robot.WaitMotionCleared(timeout=1)\n\n    robot._robot_events.on_end_of_block.wait(timeout=1)\n\n    # Robot enters error state.\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,1,0,0,0'))\n    robot._robot_events.on_error.wait(timeout=1)\n\n    robot.ResetError()\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,0,0,0'))\n    robot._robot_events.on_error_reset.wait(timeout=1)\n\n    robot.DeactivateRobot()\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '0,0,0,0,0,0,0'))\n\n    # Note: the order of these waits is intentional.\n    # The WaitActivated check may fail if message hasn't yet been processed.\n    robot.WaitDeactivated(timeout=1)\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitActivated(timeout=0)\n\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_BRAKES_OFF, ''))\n    robot._robot_events.on_brakes_deactivated.wait(timeout=DEFAULT_TIMEOUT)\n\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_BRAKES_ON, ''))\n    robot._robot_events.on_brakes_activated.wait(timeout=DEFAULT_TIMEOUT)\n\n    with pytest.raises(mdr.TimeoutException):\n        robot.WaitDisconnected(timeout=0)\n    robot.Disconnect()\n    robot.WaitDisconnected()",
    "span": [
      681,
      756
    ],
    "start_byte": 28845,
    "end_byte": 31736,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_events",
    "qualified_name": "test_events",
    "signature": "test_events(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 2891,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_disconnect_on_exception(robot: mdr.Robot):\n\n    connect_robot_helper(robot, disconnect_on_exception=True)\n\n    with pytest.raises(mdr.DisconnectError):\n        robot.SetCheckpoint(0)\n\n    # Test that disabling the feature avoids the disconnect.\n    robot.Disconnect()\n    connect_robot_helper(robot, disconnect_on_exception=False)\n\n    with pytest.raises(AssertionError):\n        robot.SetCheckpoint(0)",
    "span": [
      760,
      772
    ],
    "start_byte": 31821,
    "end_byte": 32232,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_disconnect_on_exception",
    "qualified_name": "test_disconnect_on_exception",
    "signature": "test_disconnect_on_exception(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 411,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_callbacks(robot: mdr.Robot):\n    # Initialize object which will contain all user-defined callback functions.\n    callbacks = mdr.RobotCallbacks()\n\n    # Expect that almost all callbacks will be called\n    expected_callbacks = copy.deepcopy(callbacks.__dict__)\n    # ... except on_monitor_message since we're not connecting to monitoring port by default\n    expected_callbacks.pop('on_monitor_message')\n\n    # Create list to store names of callbacks which have been called.\n    called_callbacks = []\n\n    # Function to record which callbacks have been called.\n    # To avoid writing a separate function for each callback, we take in a name parameter.\n    # Just before the callback is assigned, we set the name to be the callback we currently care about.\n    def test_callback(name):\n        called_callbacks.append(name)\n\n    # For each available callback 'slot', assign the 'test_callback' function, with the callback name as a parameter.\n    for attr in callbacks.__dict__:\n        callbacks.__dict__[attr] = partial(test_callback, name=attr)\n\n    # Checkpoint callbacks are different than other callbacks, use different function.\n    checkpoint_id = 123\n\n    # pylint: disable=redefined-builtin\n    def checkpoint_reached_callback(id):\n        called_callbacks.append('on_checkpoint_reached')\n        called_callbacks.append(id)\n\n    # pylint: disable=redefined-builtin\n    def checkpoint_discarded_callback(id):\n        called_callbacks.append('on_checkpoint_discarded')\n        called_callbacks.append(id)\n\n    callbacks.on_checkpoint_reached = checkpoint_reached_callback\n    callbacks.on_checkpoint_discarded = checkpoint_discarded_callback\n\n    # The two message callbacks are also unique.\n    def command_message_callback(message):\n        called_callbacks.append('on_command_message')\n\n    def monitor_message_callback(message):\n        called_callbacks.append('on_monitor_message')\n\n    callbacks.on_command_message = command_message_callback\n    callbacks.on_monitor_message = monitor_message_callback\n",
    "span": [
      777,
      942
    ],
    "start_byte": 32429,
    "end_byte": 40197,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_callbacks_part_1",
    "qualified_name": "test_callbacks_part_1",
    "parent_function": "test_callbacks",
    "chunk_size_bytes": 2023,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "    # End of cycle callback is alike on_monitor_message, as it also happens on a monitoring message, but less often\n    def end_of_cycle_callback():\n        called_callbacks.append('on_end_of_cycle')\n\n    callbacks.on_end_of_cycle = end_of_cycle_callback\n\n    for run_in_thread in [True]:\n        # Register all callbacks.\n        robot.RegisterCallbacks(callbacks, run_callbacks_in_separate_thread=run_in_thread)\n\n        connect_robot_helper(robot, enable_synchronous_mode=True)\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,0,0,0,0,0,0'))\n        robot.ActivateRobot()\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,0,0,0'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_CYCLE_END, '12345'))\n        robot.Home()\n\n        robot.GetStatusRobot(synchronous_update=False)\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,1,0,0'))\n\n        robot.GetRtGripperState(synchronous_update=False)\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_GRIPPER, '0,0,0,0,0,0'))\n\n        robot.SetCheckpoint(checkpoint_id)\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_REACHED, str(checkpoint_id)))\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,1,0,0'))\n        robot.PauseMotion()\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,0,0,0'))\n        robot.ResumeMotion()\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CLEAR_MOTION, ''))\n        # Note we don't actually run robot.ClearMotion() here as the command will block in synchronous mode.\n        # It is also not necessary for the test.\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_OFFLINE_START, ''))\n        # Note we don't actually run robot.StartOfflineProgram() here as there is no actual robot and thus\n        # no recorded programs\n        # It is also not necessary for the test.\n",
    "span": [
      777,
      942
    ],
    "start_byte": 32429,
    "end_byte": 40197,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_callbacks_part_2",
    "qualified_name": "test_callbacks_part_2",
    "parent_function": "test_callbacks",
    "chunk_size_bytes": 2019,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "        # Simulate end of cycle (detected on MX_ST_GET_POSE monitor message when robot is not 'rt_message_capable')\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_POSE, '0.0,0.0,0.0,0.0,0.0,0.0'))\n\n        # Robot enters error state.\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,1,0,0,0'))\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,0,0,0'))\n        robot.ResetError()\n\n        # Robot pstop triggered.\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_PSTOP2, '1'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_PSTOP2, '2'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_PSTOP2, '0'))\n        robot.ResetPStop2()\n\n        # Robot PStop1 triggered.\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_PSTOP1, '1'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_PSTOP1, '2'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_PSTOP1, '0'))\n\n        # Robot estop triggered.\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_ESTOP, '1'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_ESTOP, '2'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_ESTOP, '0'))\n\n        robot.ResetError()\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,1,0,0,0,0'))\n        robot.ActivateSim()\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,0,0,0'))\n        robot.DeactivateSim()\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_EXTTOOL_SIM, '1'))\n        robot.SetExtToolSim(MxExtToolType.MX_EXT_TOOL_MEGP25_SHORT)\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_EXTTOOL_SIM, '0'))\n        robot.SetExtToolSim(MxExtToolType.MX_EXT_TOOL_NONE)\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_EXTTOOL_STATUS, '33,1,1,1,1,0'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_VALVE_STATE, '34,1,1'))",
    "span": [
      777,
      942
    ],
    "start_byte": 32429,
    "end_byte": 40197,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_callbacks_part_3",
    "qualified_name": "test_callbacks_part_3",
    "parent_function": "test_callbacks",
    "chunk_size_bytes": 2014,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_GRIPPER_STATE, '35,1,1,0,0'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_OUTPUT_STATE, '36,1,1,0,0'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_INPUT_STATE, '36,1,1,0,0'))\n        # Simulate enabling/disabling of IO module sim\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_IO_STATUS, '39,1,1,1,0'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_IO_STATUS, '40,1,1,0,0'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_VACUUM_STATE, '41,1,1,0'))\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_VACUUM_PRESSURE, '42,-1'))\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RECOVERY_MODE_ON, ''))\n        robot.SetRecoveryMode(True)\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RECOVERY_MODE_OFF, ''))\n        robot.SetRecoveryMode(False)\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_OFFLINE_START, ''))\n\n        robot.SetCheckpoint(checkpoint_id)\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_CHECKPOINT_DISCARDED, str(checkpoint_id)))\n\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '0,0,0,0,0,0,0'))\n        robot.DeactivateRobot()\n\n        robot.Disconnect()\n\n        if not run_in_thread:\n            robot.RunCallbacks()\n\n        robot.UnregisterCallbacks()\n\n        # Check that all callbacks have been called.\n        for attr in expected_callbacks:\n            assert attr in called_callbacks, f'callback {attr} not called (called={called_callbacks})'\n\n        assert checkpoint_id in called_callbacks\n\n        assert robot._callback_thread is None",
    "span": [
      777,
      942
    ],
    "start_byte": 32429,
    "end_byte": 40197,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_callbacks_part_4",
    "qualified_name": "test_callbacks_part_4",
    "parent_function": "test_callbacks",
    "chunk_size_bytes": 1709,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_event_with_exception():\n    # Test successful setting.\n    event = mdr.InterruptableEvent()\n    event.set()\n    event.wait(timeout=0)\n\n    # Test event timed out.\n    event.clear()\n    with pytest.raises(mdr.TimeoutException):\n        event.wait(timeout=0)\n\n    # Test event throwing exception.\n    exception_event = mdr.InterruptableEvent()\n    exception_event.abort()\n    with pytest.raises(mdr.InterruptException):\n        exception_event.wait(timeout=0)",
    "span": [
      946,
      961
    ],
    "start_byte": 40259,
    "end_byte": 40725,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_event_with_exception",
    "qualified_name": "test_event_with_exception",
    "signature": "test_event_with_exception()",
    "docstring": null,
    "chunk_size_bytes": 466,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_motion_commands(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    skip_commands = [\n        'MoveGripper', 'MoveJoints', 'MoveJointsVel', 'MoveJointsRel', 'SetSynchronousMode', 'SetTorqueLimits',\n        'SetTorqueLimitsCfg', 'SetIoSim', 'SetOutputState', 'SetOutputStateImmediate', 'SetVariable'\n    ]\n\n    # List of methods that will be deprecated. The deprecation decorator breaks the way we use to test those methods.\n    deprecated_commands = [\n        'MoveLinRelTRF', 'MoveLinRelWRF', 'MoveLinVelTRF', 'MoveLinVelWRF', 'SetRTC', 'SetTRF', 'SetWRF'\n    ]\n\n    # Run all move-type commands in API and check that the text_command matches.\n    for name in dir(robot):\n        if name in skip_commands or name in deprecated_commands:\n            continue\n        elif name.startswith('Move') or name.startswith('Set'):\n            method = getattr(robot, name)\n\n            num_args = method.__wrapped__.__code__.co_argcount\n            test_args = list(range(1, num_args))\n            test_args_text = ','.join([str(x) for x in test_args])\n\n            # Call method.\n            method(*test_args)\n\n            text_command = robot._command_tx_queue.get(block=True, timeout=1)\n\n            # Check that the text commands begins with the appropriate name.\n            assert text_command.find(\n                name) == 0, f'Method {name} does not match text command ({text_command} does not include {name})'\n\n            # Check that the test arguments.\n            assert text_command.find(\n                test_args_text\n            ) != -1, f'Method {name} args do not match text command ({text_command} does not include {test_args_text})'",
    "span": [
      966,
      1002
    ],
    "start_byte": 40941,
    "end_byte": 42601,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_motion_commands",
    "qualified_name": "test_motion_commands",
    "signature": "test_motion_commands(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 1660,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_joint_moves(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    fake_joint = fake_data(seed=1, length=6)\n    fake_joints_str = fake_string(seed=1, length=6)\n\n    robot.MoveJoints(*fake_joint)\n    text_command = robot._command_tx_queue.get(block=True, timeout=1)\n    assert text_command.find('MoveJoints') == 0\n    assert text_command.find(fake_joints_str) != -1\n\n    with pytest.raises(ValueError):\n        robot.MoveJoints(1, 2, 3)\n\n    robot.MoveJointsRel(*fake_joint)\n    text_command = robot._command_tx_queue.get(block=True, timeout=1)\n    assert text_command.find('MoveJointsRel') == 0\n    assert text_command.find(fake_joints_str) != -1\n\n    with pytest.raises(ValueError):\n        robot.MoveJointsRel(1, 2, 3)\n\n    robot.MoveJointsVel(*fake_joint)\n    text_command = robot._command_tx_queue.get(block=True, timeout=1)\n    assert text_command.find('MoveJointsVel') == 0\n    assert text_command.find(fake_joints_str) != -1\n\n    with pytest.raises(ValueError):\n        robot.MoveJointsVel(1, 2, 3)",
    "span": [
      1006,
      1034
    ],
    "start_byte": 42676,
    "end_byte": 43691,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_joint_moves",
    "qualified_name": "test_joint_moves",
    "signature": "test_joint_moves(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 1015,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_synchronous_gets(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    # Test GetRtTargetJointPos.\n    expected_commands = ['SyncCmdQueue(1)', 'GetRtTargetJointPos']\n    robot_responses = []\n    robot_responses.append(mdr.Message(mx_st.MX_ST_SYNC_CMD_QUEUE, '1'))\n    robot_responses.append(mdr.Message(mx_st.MX_ST_RT_TARGET_JOINT_POS, '1234, 1, 2, 3, 4, 5, 6'))\n    fake_robot = threading.Thread(target=simple_response_handler,\n                                  args=(robot._command_tx_queue, robot._command_rx_queue, expected_commands,\n                                        robot_responses))\n\n    fake_robot.start()\n\n    # Try synchronous get\n    assert robot.GetRtTargetJointPos(synchronous_update=True, timeout=1) == [1, 2, 3, 4, 5, 6]\n\n    # Also test get with timestamp\n    expected_response = mdr.TimestampedData(1234, [1, 2, 3, 4, 5, 6],\n                                            mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL)\n    assert robot.GetRtTargetJointPos(include_timestamp=True, synchronous_update=False) == expected_response\n\n    fake_robot.join()\n\n    # Test GetRtTargetCartPos.\n    expected_commands = ['SyncCmdQueue(2)', 'GetRtTargetCartPos']\n    robot_responses = []\n    robot_responses.append(mdr.Message(mx_st.MX_ST_SYNC_CMD_QUEUE, '2'))\n    robot_responses.append(mdr.Message(mx_st.MX_ST_RT_TARGET_CART_POS, '2345, 2, 3, 4, 5, 6, 7'))\n    fake_robot = threading.Thread(target=simple_response_handler,\n                                  args=(robot._command_tx_queue, robot._command_rx_queue, expected_commands,\n                                        robot_responses))\n\n    fake_robot.start()\n\n    # Try synchronous get\n    assert robot.GetRtTargetCartPos(synchronous_update=True, timeout=1) == [2, 3, 4, 5, 6, 7]\n\n    # Also test get with timestamp\n    expected_response = mdr.TimestampedData(2345, [2, 3, 4, 5, 6, 7],\n                                            mdr.RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL)\n    assert robot.GetRtTargetCartPos(include_timestamp=True, synchronous_update=False) == expected_response\n\n    fake_robot.join()\n\n    # Attempting these gets without the appropriate robot response should result in timeout.\n\n    with pytest.raises(mdr.TimeoutException):\n        robot.GetRtTargetJointPos(synchronous_update=True, timeout=0)\n\n    with pytest.raises(mdr.TimeoutException):\n        robot.GetRtTargetCartPos(synchronous_update=True, timeout=0)",
    "span": [
      1038,
      1089
    ],
    "start_byte": 43744,
    "end_byte": 46164,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_synchronous_gets",
    "qualified_name": "test_synchronous_gets",
    "signature": "test_synchronous_gets(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 2420,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def fake_data(seed, length=6):\n    return [seed] * length",
    "span": [
      1093,
      1094
    ],
    "start_byte": 46250,
    "end_byte": 46307,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "fake_data",
    "qualified_name": "fake_data",
    "signature": "fake_data(seed, length=6)",
    "docstring": null,
    "chunk_size_bytes": 57,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def fake_string(seed, length=6):\n    return ','.join([str(x) for x in fake_data(seed, length)])",
    "span": [
      1097,
      1098
    ],
    "start_byte": 46310,
    "end_byte": 46405,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "fake_string",
    "qualified_name": "fake_string",
    "signature": "fake_string(seed, length=6)",
    "docstring": null,
    "chunk_size_bytes": 95,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_synchronous_gets_legacy(robot: mdr.Robot):\n    # Use a connected response that indicate a robot that does not support real-time monitoring\n    connect_robot_helper(robot, yaml_filename='meca500_r3_v8_3.yml')\n\n    #\n    # Test legacy messages:\n    #\n    robot._monitor_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_JOINTS, fake_string(seed=1)))\n    robot._monitor_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_POSE, fake_string(seed=1)))\n\n    # Terminate queue and wait for thread to exit to ensure messages are processed.\n    robot._monitor_rx_queue.put(mdrb._TERMINATE)\n    robot._monitor_rx_handler_thread.join(timeout=5)\n    robot._initialize_monitoring_connection()\n\n    # Without RT messages, enabling 'include_timestamp' should raise exception.\n    with pytest.raises(mdr.InvalidStateError):\n        robot.GetRtTargetJointPos(include_timestamp=True)\n    with pytest.raises(mdr.InvalidStateError):\n        robot.GetRtTargetCartPos(include_timestamp=True)\n\n    assert robot.GetRtTargetJointPos(include_timestamp=False) == fake_data(seed=1)\n    assert robot.GetRtTargetCartPos(include_timestamp=False) == fake_data(seed=1)\n\n    assert not robot.GetRobotInfo().rt_message_capable\n\n    # Test synchronous gets without RT messages.\n    expected_command = 'GetJoints'\n    robot_response = mdr.Message(mx_st.MX_ST_GET_JOINTS, fake_string(seed=2))\n    fake_robot = threading.Thread(target=simple_response_handler,\n                                  args=(robot._command_tx_queue, robot._command_rx_queue, expected_command,\n                                        robot_response))\n\n    fake_robot.start()\n\n    assert robot.GetRtTargetJointPos(synchronous_update=True, timeout=1) == fake_data(seed=2)\n    fake_robot.join()\n\n    expected_command = 'GetPose'\n    robot_response = mdr.Message(mx_st.MX_ST_GET_POSE, fake_string(seed=2))\n    fake_robot = threading.Thread(target=simple_response_handler,\n                                  args=(robot._command_tx_queue, robot._command_rx_queue, expected_command,\n                                        robot_response))\n\n    fake_robot.start()\n\n    assert robot.GetRtTargetCartPos(synchronous_update=True, timeout=1) == fake_data(seed=2)\n    fake_robot.join()",
    "span": [
      1102,
      1149
    ],
    "start_byte": 46462,
    "end_byte": 48658,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_synchronous_gets_legacy",
    "qualified_name": "test_synchronous_gets_legacy",
    "signature": "test_synchronous_gets_legacy(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 2196,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_start_offline_program(robot: mdr.Robot):\n    connect_robot_helper(robot, enable_synchronous_mode=True)\n\n    expected_command = 'StartProgram(1)'\n\n    # Report that the program has been started successfully.\n    robot_response = mdr.Message(mx_st.MX_ST_OFFLINE_START, '')\n    fake_robot = threading.Thread(target=simple_response_handler,\n                                  args=(robot._command_tx_queue, robot._command_rx_queue, expected_command,\n                                        robot_response))\n    fake_robot.start()\n\n    robot.StartOfflineProgram(1, timeout=1)\n\n    fake_robot.join(timeout=1)\n\n    # Report that the program does not exist.\n    robot_response = mdr.Message(mx_st.MX_ST_NO_OFFLINE_SAVED, '')\n    fake_robot = threading.Thread(target=simple_response_handler,\n                                  args=(robot._command_tx_queue, robot._command_rx_queue, expected_command,\n                                        robot_response))\n    fake_robot.start()\n\n    with pytest.raises(mdr.InvalidStateError):\n        robot.StartOfflineProgram(1, timeout=1)\n\n    fake_robot.join(timeout=1)",
    "span": [
      1153,
      1179
    ],
    "start_byte": 48699,
    "end_byte": 49805,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_start_offline_program",
    "qualified_name": "test_start_offline_program",
    "signature": "test_start_offline_program(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 1106,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_monitor_mode(robot: mdr.Robot):\n\n    robot._monitor_rx_queue.put(mdr.Message(mx_st.MX_ST_CONNECTED, MECA500_CONNECTED_RESPONSE))\n    robot._Connect(TEST_IP,\n                   monitor_mode=True,\n                   offline_mode=True,\n                   disconnect_on_exception=False,\n                   enable_synchronous_mode=True)\n\n    robot.WaitConnected(timeout=0)\n\n    # Check that the Meca500 response was correctly parsed to have 6 joints.\n    assert robot.GetRobotInfo().num_joints == 6\n\n    # Prepare test data\n    fake_joint = fake_data(seed=1, length=6)\n    fake_joints_str = fake_string(seed=1, length=6)\n    fake_pose = fake_data(seed=2, length=6)\n    fake_pose_str = fake_string(seed=2, length=6)\n\n    # Send test messages.\n    robot._monitor_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_TARGET_JOINT_POS, '1234, ' + fake_joints_str))\n    robot._monitor_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_TARGET_CART_POS, '2345, ' + fake_pose_str))\n\n    # Terminate queue and wait for thread to exit to ensure messages are processed.\n    robot._monitor_rx_queue.put(mdrb._TERMINATE)\n    robot._monitor_rx_handler_thread.join(timeout=5)\n\n    # Check that these gets do not raise an exception.\n    assert robot.GetRtTargetJointPos() == fake_joint\n    assert robot.GetRtTargetCartPos() == fake_pose\n\n    with pytest.raises(mdr.InvalidStateError):\n        robot.MoveJoints(*fake_joint)",
    "span": [
      1183,
      1216
    ],
    "start_byte": 49861,
    "end_byte": 51248,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_monitor_mode",
    "qualified_name": "test_monitor_mode",
    "signature": "test_monitor_mode(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 1387,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_custom_command(robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    expected_command = 'TestCommand'\n    robot_response = mdr.Message(mx_st.MX_ST_CMD_SUCCESSFUL, 'TestResponse')\n    fake_robot = threading.Thread(target=simple_response_handler,\n                                  args=(robot._command_tx_queue, robot._command_rx_queue, expected_command,\n                                        robot_response))\n\n    fake_robot.start()\n\n    response_event = robot.SendCustomCommand('TestCommand', expected_responses=[mx_st.MX_ST_CMD_SUCCESSFUL])\n    assert response_event.wait(timeout=DEFAULT_TIMEOUT) == robot_response\n\n    assert len(robot._custom_response_events) == 0",
    "span": [
      1220,
      1234
    ],
    "start_byte": 51304,
    "end_byte": 51984,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "test_custom_command",
    "qualified_name": "test_custom_command",
    "signature": "test_custom_command(robot: mdr.Robot)",
    "docstring": null,
    "chunk_size_bytes": 680,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def remove_all_whitespaces(string):\n    return re.sub(r\"\\s+\", \"\", string)",
    "span": [
      1238,
      1239
    ],
    "start_byte": 52047,
    "end_byte": 52120,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "remove_all_whitespaces",
    "qualified_name": "remove_all_whitespaces",
    "signature": "remove_all_whitespaces(string)",
    "docstring": null,
    "chunk_size_bytes": 73,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def robot_trajectory_files_identical(file_path_1, file_path_2):\n    robot_traj_1 = robot_files.RobotTrajectories.from_file(file_path_1)\n    robot_traj_2 = robot_files.RobotTrajectories.from_file(file_path_2)\n\n    return robot_traj_1 == robot_traj_2",
    "span": [
      1244,
      1248
    ],
    "start_byte": 52192,
    "end_byte": 52440,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "robot_trajectory_files_identical",
    "qualified_name": "robot_trajectory_files_identical",
    "signature": "robot_trajectory_files_identical(file_path_1, file_path_2)",
    "docstring": null,
    "chunk_size_bytes": 248,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "def test_file_logger(tmp_path, robot: mdr.Robot):\n    connect_robot_helper(robot)\n\n    # Manually set that the robot is rt-message-capable.\n    robot._robot_info.rt_message_capable = True\n\n    # Send some fictive IoModule input/output values so the robot object creates the inputs/outputs arrays\n    io_module_outputs = mdr.Message(mx_st.MX_ST_RT_OUTPUT_STATE,\n                                    f'0,{MxIoBankId.MX_IO_BANK_ID_IO_MODULE},1,0,1,0,1,0,1,0')\n    io_module_inputs = mdr.Message(mx_st.MX_ST_RT_INPUT_STATE,\n                                   f'0,{MxIoBankId.MX_IO_BANK_ID_IO_MODULE},0,1,0,1,0,1,0,1')\n    robot._command_rx_queue.put(io_module_outputs)\n    robot._command_rx_queue.put(io_module_inputs)\n\n    start_time = time.monotonic()\n    while len(robot._robot_rt_data.rt_io_module_inputs.data) == 0:\n        if time.monotonic() - start_time >= 1:\n            raise TimeoutError('Timeout waiting for MX_ST_RT_INPUT_STATE to be handled for io_module')\n        time.sleep(0.001)\n\n    # Send some fictive signal generator input/output values so the robot object creates the inputs/outputs arrays\n    sig_gen_outputs = mdr.Message(mx_st.MX_ST_RT_OUTPUT_STATE,\n                                  f'0,{MxIoBankId.MX_IO_BANK_ID_SIG_GEN},1,0,1,0,1,0,1,0, 1,1,0,0,1,1,0,0,1')\n    sig_gen_inputs = mdr.Message(mx_st.MX_ST_RT_INPUT_STATE,\n                                 f'0,{MxIoBankId.MX_IO_BANK_ID_SIG_GEN},0,1,0,1,0,1,0,1, 1,1,0')\n    robot._command_rx_queue.put(sig_gen_outputs)\n    robot._command_rx_queue.put(sig_gen_inputs)\n\n    start_time = time.monotonic()\n    while len(robot._robot_rt_data.rt_sig_gen_inputs.data) == 0:\n        if time.monotonic() - start_time >= 1:\n            raise TimeoutError('Timeout waiting for MX_ST_RT_INPUT_STATE to be handled for sig_gen')\n        time.sleep(0.001)\n\n    # Send status message to indicate that the robot is activated and homed, and idle.\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_STATUS_ROBOT, '1,1,0,0,0,1,1'))\n    robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_REAL_TIME_MONITORING, ''))\n",
    "span": [
      1252,
      1375
    ],
    "start_byte": 52539,
    "end_byte": 60324,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_file_logger_part_1",
    "qualified_name": "test_file_logger_part_1",
    "parent_function": "test_file_logger",
    "chunk_size_bytes": 2077,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "    # Start logging with context manager version of logger. record_time is False to for comparison with reference file.\n    with robot.FileLogger(0.001, file_path=tmp_path, record_time=False):\n        robot.MoveJoints(0, -60, 60, 0, 0, 0)\n        robot.MoveJoints(0, 0, 0, 0, 0, 0)\n        for i in range(1, 4):\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_JOINTS, fake_string(seed=3)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_POSE, fake_string(seed=4)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_CONF, fake_string(seed=102, length=3)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_CONF_TURN, fake_string(seed=103, length=2)))\n\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_TARGET_JOINT_POS, fake_string(seed=3, length=7)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_TARGET_CART_POS, fake_string(seed=4, length=7)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_TARGET_JOINT_VEL, fake_string(seed=5, length=7)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_TARGET_CART_VEL, fake_string(seed=6, length=7)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_TARGET_JOINT_TORQ, fake_string(seed=666, length=7)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_TARGET_CONF, fake_string(seed=7, length=4)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_TARGET_CONF_TURN, fake_string(seed=8, length=2)))\n\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_JOINT_POS, fake_string(seed=9, length=7)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_CART_POS, fake_string(seed=10, length=7)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_JOINT_VEL, fake_string(seed=11, length=7)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_JOINT_TORQ, fake_string(seed=12, length=7)))",
    "span": [
      1252,
      1375
    ],
    "start_byte": 52539,
    "end_byte": 60324,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_file_logger_part_2",
    "qualified_name": "test_file_logger_part_2",
    "parent_function": "test_file_logger",
    "chunk_size_bytes": 1986,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_CART_VEL, fake_string(seed=13, length=7)))\n\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_CONF, fake_string(seed=14, length=4)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_CONF_TURN, fake_string(seed=15, length=2)))\n\n            robot._command_rx_queue.put(\n                mdr.Message(mx_st.MX_ST_RT_ACCELEROMETER, '16,5,' + fake_string(seed=16000, length=3)))\n\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_ABS_JOINT_POS, fake_string(seed=99, length=7)))\n\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_EXTTOOL_STATUS, fake_string(seed=17, length=6)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_VALVE_STATE, fake_string(seed=18, length=3)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_GRIPPER_STATE, fake_string(seed=19, length=5)))\n\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_GRIPPER_FORCE, fake_string(seed=20, length=2)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_GRIPPER_POS, fake_string(seed=21, length=2)))\n\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_WRF, fake_string(seed=22, length=7)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_TRF, fake_string(seed=23, length=7)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_CHECKPOINT, fake_string(seed=24, length=2)))\n\n            robot._command_rx_queue.put(io_module_outputs)\n            robot._command_rx_queue.put(io_module_inputs)\n            robot._command_rx_queue.put(\n                mdr.Message(mx_st.MX_ST_RT_IO_STATUS, f'26,{MxIoBankId.MX_IO_BANK_ID_IO_MODULE},26,26,26'))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_VACUUM_STATE, fake_string(seed=27, length=4)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_VACUUM_PRESSURE, fake_string(seed=28, length=2)))\n\n            robot._command_rx_queue.put(sig_gen_outputs)",
    "span": [
      1252,
      1375
    ],
    "start_byte": 52539,
    "end_byte": 60324,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_file_logger_part_3",
    "qualified_name": "test_file_logger_part_3",
    "parent_function": "test_file_logger",
    "chunk_size_bytes": 2042,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  },
  {
    "snippet": "            robot._command_rx_queue.put(sig_gen_inputs)\n            robot._command_rx_queue.put(\n                mdr.Message(mx_st.MX_ST_RT_IO_STATUS, f'29,{MxIoBankId.MX_IO_BANK_ID_SIG_GEN},29,29,29'))\n            robot._command_rx_queue.put(\n                mdr.Message(mx_st.MX_ST_RT_EFFECTIVE_TIME_SCALING, fake_string(seed=30, length=2)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_VM, fake_string(seed=31, length=10)))\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_CURRENT, fake_string(seed=32, length=2)))\n\n            robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_RT_CYCLE_END, str(i * 100)))\n\n        # Simulate response to last \"SetRealTimeMonitoring\" performed automatically at end of logging\n        robot._command_rx_queue.put(mdr.Message(mx_st.MX_ST_GET_REAL_TIME_MONITORING, ''))\n\n        # Terminate queue and wait for thread to exit to ensure messages are processed.\n        robot._command_rx_queue.put(mdrb._TERMINATE)\n\n    robot._rx_handler_thread.join(timeout=5)\n\n    # Restart the monitoring connection to ensure the API is in a good state.\n    robot._initialize_monitoring_connection()\n\n    # Ensure one log file is created.\n    directory = os.listdir(tmp_path)\n    assert len(directory) == 1\n\n    log_file_name = directory[0]\n    assert log_file_name.startswith('Meca500_R3_v9.147.0')\n\n    log_file_path = os.path.join(tmp_path, log_file_name)\n    reference_file_path = os.path.join(os.path.dirname(__file__), 'log_file_reference.zip')\n\n    # Check that the logger output matches the reference file.\n    assert robot_trajectory_files_identical(log_file_path, reference_file_path)\n\n    robot.Disconnect()",
    "span": [
      1252,
      1375
    ],
    "start_byte": 52539,
    "end_byte": 60324,
    "node_type": "function_definition",
    "chunk_type": "function_part",
    "language": "python",
    "name": "test_file_logger_part_4",
    "qualified_name": "test_file_logger_part_4",
    "parent_function": "test_file_logger",
    "chunk_size_bytes": 1677,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/tests/robot_test.py",
    "normalized_path": "mecademicpy/tests/robot_test.py"
  }
]