[
  {
    "snippet": "import socket",
    "span": [
      12,
      12
    ],
    "start_byte": 364,
    "end_byte": 377,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "socket",
    "qualified_name": "socket",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 13,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/meca500-accessories/flexibowl/python/flexibowl_plugin.py",
    "normalized_path": "meca500-accessories/flexibowl/python/flexibowl_plugin.py"
  },
  {
    "snippet": "from time import sleep",
    "span": [
      13,
      13
    ],
    "start_byte": 378,
    "end_byte": 400,
    "node_type": "import_from_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "sleep",
    "qualified_name": "sleep",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 22,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/meca500-accessories/flexibowl/python/flexibowl_plugin.py",
    "normalized_path": "meca500-accessories/flexibowl/python/flexibowl_plugin.py"
  },
  {
    "snippet": "import sys",
    "span": [
      14,
      14
    ],
    "start_byte": 401,
    "end_byte": 411,
    "node_type": "import_statement",
    "chunk_type": "import",
    "language": "python",
    "name": "sys",
    "qualified_name": "sys",
    "signature": null,
    "docstring": null,
    "chunk_size_bytes": 10,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/meca500-accessories/flexibowl/python/flexibowl_plugin.py",
    "normalized_path": "meca500-accessories/flexibowl/python/flexibowl_plugin.py"
  },
  {
    "snippet": "def in_allarm(ip):\n    \"\"\"\n    Check if the FlexiBowl device is in alarm state.\n    \n    Args:\n        ip (str): IP address of the FlexiBowl device\n        \n    Returns:\n        bool: True if device is operational (no alarms), False if in alarm state or connection failed\n    \"\"\"\n    assert type(ip) is str\n    TCP_IP = ip\n    TCP_PORT = 7776\n    BUFFER_SIZE = 1024\n    command = \"AL\"\n    # Create alarm check message: NULL + 7 + \"AL\" + CR\n    MESSAGE = chr(0)+chr(7)+command+chr(13)\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    try:\n        s.connect((TCP_IP, TCP_PORT))\n        s.send(MESSAGE.encode())\n        data = s.recv(BUFFER_SIZE)\n        print(\"Message send: \" + MESSAGE)\n        print(\"Message recive: \" + str(data))\n        sleep(0.1)  # Brief delay for message processing\n    except :\n        print(\"Not Connected1\")\n        s.close()\n        return False\n    # Extract alarm status from response (bytes 5 onwards contain hex alarm data)\n    my_hexdata = data[5:None]\n    print(my_hexdata)\n    \n    # Convert hex alarm data to binary for bit analysis\n    scale = 16  # Hexadecimal base\n    num_of_bits = 16\n    binary_string = bin(int(my_hexdata, scale))[2:].zfill(num_of_bits)\n    print(binary_string)\n    \n    # Convert binary to decimal to check for any alarm bits set\n    error_decimal = int(binary_string, 2)\n    if(error_decimal > 0):\n        # Device is in alarm state\n        s.close()\n        return False\n    else:\n        s.close()\n        return True",
    "span": [
      17,
      64
    ],
    "start_byte": 414,
    "end_byte": 1906,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "in_allarm",
    "qualified_name": "in_allarm",
    "signature": "in_allarm(ip)",
    "docstring": "Check if the FlexiBowl device is in alarm state.\n    \n    Args:\n        ip (str): IP address of the FlexiBowl device\n        \n    Returns:\n        bool: True if device is operational (no alarms), False if in alarm state or connection failed",
    "chunk_size_bytes": 1492,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/meca500-accessories/flexibowl/python/flexibowl_plugin.py",
    "normalized_path": "meca500-accessories/flexibowl/python/flexibowl_plugin.py"
  },
  {
    "snippet": "def move_flb1(ip, command):\n    \"\"\"\n    Send movement commands to the FlexiBowl device.\n    \n    Args:\n        ip (str): IP address of the FlexiBowl device\n        command (str): Command to execute. Valid commands:\n            - \"MOVE\": Basic movement\n            - \"MOVE FLIP\": Move with flip action\n            - \"MOVE BLOW FLIP\": Move with blow and flip\n            - \"MOVE BLOW\": Move with blow action\n            - \"SHAKE\": Shake the bowl\n            - \"LIGHT ON\": Turn on illumination\n            - \"LIGHT OFF\": Turn off illumination\n            - \"FLIP\": Flip action only\n            - \"BLOW\": Blow action only\n            - \"QUICK EMPTY OPTION\": Quick empty sequence\n            \n    Returns:\n        bool: True if command executed successfully, False otherwise\n    \"\"\"\n    assert type(command) is str\n    assert type(ip) is str\n    TCP_IP = ip\n    TCP_PORT = 7776\n    BUFFER_SIZE = 1024\n\n    # Map human-readable commands to FlexiBowl protocol commands\n    if(command==\"MOVE\"):\n        command=\"QX2\"\n    elif (command==\"MOVE FLIP\"):\n        command=\"QX3\"\n    elif (command==\"MOVE BLOW FLIP\"):\n        command=\"QX4\"\n    elif (command==\"MOVE BLOW\"):\n        command=\"QX5\"\n    elif (command==\"SHAKE\"):\n        command=\"QX6\"\n    elif (command==\"LIGHT ON\"):\n        command=\"QX7\"\n    elif (command==\"LIGHT OFF\"):\n        command=\"QX8\"\n    elif (command==\"FLIP\"):\n        command=\"QX10\"\n    elif (command==\"BLOW\"):\n        command=\"QX9\"\n    elif (command==\"QUICK EMPTY OPTION\"):\n        command=\"QX11\"\n    else:\n        command=\"QX60\"  # Invalid command - will cause device to reject\n    # Create command message: NULL + 7 + command + CR\n    MESSAGE = chr(0)+chr(7)+command+chr(13)\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.settimeout(2)\n    try:\n        s.connect((TCP_IP, TCP_PORT))\n        s.send(MESSAGE.encode())\n        data = s.recv(BUFFER_SIZE)\n        print(\"Message send: \" + MESSAGE)\n        print(\"Message recive: \" + str(data))\n        sleep(0.1)  # Brief delay for message processing\n        \n        # Check if device responded with \"%\" indicating command acceptance\n        if(b\"%\" in data):\n            print(\"Command accepted, waiting for completion...\")\n            moving = 1\n            # Wait for movement/operation to complete\n            while True:\n\n                # Different status checking methods for different command types\n                if(command==\"QX11\") or (command==\"QX10\") or (command==\"QX4\") or (command==\"QX3\"):\n                    # For these commands, check IO status (busy signal)\n                    print(\"Checking device busy status...\")\n                    sleep(0.1)\n                    MESSAGE = chr(0)+chr(7)+\"IO\"+chr(13)  # IO status query\n                    s.send(MESSAGE.encode())\n                    data = s.recv(BUFFER_SIZE)\n                    print(data)\n                    moving = data[12:-1]  # Extract busy status from response\n                    print(moving)\n                    if int(moving) == 1:  # Device reports not busy (operation complete)\n                        sleep(0.1)\n                        break\n                else:\n                    # For other commands, check SC (status/completion) register\n                    MESSAGE = chr(0)+chr(7)+\"SC\"+chr(13)  # Status check query\n                    s.send(MESSAGE.encode())\n                    data = s.recv(BUFFER_SIZE)\n                    moving = data[7:-2]  # Extract status from response\n                    if int(moving) == 0:  # Operation completed\n                        sleep(0.1)\n                        break\n                sleep(0.1)  # Polling interval for status checks\n            s.close()\n            return True\n        else:\n            s.close()\n            return False\n    except :\n        print(\"Not Connected2\")\n        s.close()\n        return False",
    "span": [
      66,
      167
    ],
    "start_byte": 1908,
    "end_byte": 5744,
    "node_type": "function_definition",
    "chunk_type": "function",
    "language": "python",
    "name": "move_flb1",
    "qualified_name": "move_flb1",
    "signature": "move_flb1(ip, command)",
    "docstring": "Send movement commands to the FlexiBowl device.\n    \n    Args:\n        ip (str): IP address of the FlexiBowl device\n        command (str): Command to execute. Valid commands:\n            - \"MOVE\": Basic movement\n            - \"MOVE FLIP\": Move with flip action\n            - \"MOVE BLOW FLIP\": Move with blow and flip\n            - \"MOVE BLOW\": Move with blow action\n            - \"SHAKE\": Shake the bowl\n            - \"LIGHT ON\": Turn on illumination\n            - \"LIGHT OFF\": Turn off illumination\n            - \"FLIP\": Flip action only\n            - \"BLOW\": Blow action only\n            - \"QUICK EMPTY OPTION\": Quick empty sequence\n            \n    Returns:\n        bool: True if command executed successfully, False otherwise",
    "chunk_size_bytes": 3836,
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/meca500-accessories/flexibowl/python/flexibowl_plugin.py",
    "normalized_path": "meca500-accessories/flexibowl/python/flexibowl_plugin.py"
  }
]