{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:810bf2e4448e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "deepcopy", "qualified_name": "deepcopy", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [8, 8], "text": "from copy import deepcopy", "hash": "810bf2e4448e", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 25, "original_size_bytes": 25, "start_byte": 221, "end_byte": 246}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:b616058a49fd", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Optional", "qualified_name": "Optional", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [9, 9], "text": "from typing import Optional, Tuple, Union", "hash": "b616058a49fd", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 41, "original_size_bytes": 41, "start_byte": 247, "end_byte": 288}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:f6466ac7b775", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unknown", "qualified_name": "unknown", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [11, 11], "text": "from .mx_robot_def import *", "hash": "f6466ac7b775", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 27, "original_size_bytes": 27, "start_byte": 290, "end_byte": 317}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:616b71bc439a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Robot", "qualified_name": "Robot", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [12, 12], "text": "from .robot import Robot", "hash": "616b71bc439a", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 24, "original_size_bytes": 24, "start_byte": 318, "end_byte": 342}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:9e7a5dc6e16d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unknown", "qualified_name": "unknown", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [13, 13], "text": "from .robot_classes import *", "hash": "9e7a5dc6e16d", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 28, "original_size_bytes": 28, "start_byte": 343, "end_byte": 371}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:5485e01f3db1", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unknown", "qualified_name": "unknown", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [14, 14], "text": "from .tools import *", "hash": "5485e01f3db1", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 20, "original_size_bytes": 20, "start_byte": 372, "end_byte": 392}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:226ce6d71384", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "DirtyFlags", "qualified_name": "DirtyFlags", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [17, 34], "text": "class DirtyFlags():\n    def __init__(self):\n        self._dirty = True\n        self._sent_commands = {}\n    def set_dirty(self):\n        self._dirty = True\n    def clear_dirty(self):\n        self._dirty = False", "hash": "226ce6d71384", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": null, "chunk_size_bytes": 210, "original_size_bytes": 213, "start_byte": 395, "end_byte": 844}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:fcbed598c8a7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "DirtyFlags.__init__", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [19, 21], "text": "def __init__(self):\n        self._dirty = True\n        self._sent_commands = {}", "hash": "fcbed598c8a7", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self)", "docstring": null, "chunk_size_bytes": 79, "original_size_bytes": 79, "start_byte": 420, "end_byte": 499}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:50a84dcf244f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "set_dirty", "qualified_name": "DirtyFlags.set_dirty", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [23, 24], "text": "def set_dirty(self):\n        self._dirty = True", "hash": "50a84dcf244f", "chunk_type": "method", "node_type": "function_definition", "signature": "set_dirty(self)", "docstring": null, "chunk_size_bytes": 47, "original_size_bytes": 47, "start_byte": 505, "end_byte": 552}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:469d593e1149", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "clear_dirty", "qualified_name": "DirtyFlags.clear_dirty", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [26, 28], "text": "def clear_dirty(self):\n        self._dirty = False\n        self._sent_commands = {}", "hash": "469d593e1149", "chunk_type": "method", "node_type": "function_definition", "signature": "clear_dirty(self)", "docstring": null, "chunk_size_bytes": 83, "original_size_bytes": 83, "start_byte": 558, "end_byte": 641}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:7dd21d9dc89e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "is_dirty", "qualified_name": "DirtyFlags.is_dirty", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [30, 31], "text": "def is_dirty(self, cmd_name: str) -> bool:\n        return self._dirty or cmd_name in self._sent_commands", "hash": "7dd21d9dc89e", "chunk_type": "method", "node_type": "function_definition", "signature": "is_dirty(self, cmd_name: str)", "docstring": null, "chunk_size_bytes": 104, "original_size_bytes": 104, "start_byte": 647, "end_byte": 751}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:5c9b78ccbda6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "add_sent_command", "qualified_name": "DirtyFlags.add_sent_command", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [33, 34], "text": "def add_sent_command(self, cmd_name: str):\n        self._sent_commands[cmd_name] = True", "hash": "5c9b78ccbda6", "chunk_type": "method", "node_type": "function_definition", "signature": "add_sent_command(self, cmd_name: str)", "docstring": null, "chunk_size_bytes": 87, "original_size_bytes": 87, "start_byte": 757, "end_byte": 844}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:4698b91d9b5b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "MotionQueueParams", "qualified_name": "MotionQueueParams", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [37, 84], "text": "class MotionQueueParams:\n    \"\"\" This class regroups all motion queue parameters \"\"\"\n    def __init__(self):\n        self.torque_limits_severity = MxEventSeverity.MX_EVENT_SEVERITY_WARNING\n        self.torque_limits_mode = MxTorqueLimitsMode.MX_TORQUE_LIMITS_DETECT_SKIP_ACCEL\n        self.torque_limits = [100] * 6\n        self.auto_conf = True\n        self.auto_conf_turn = True\n        self.blending = 100\n        self.cart_acc = 50\n        self.cart_ang_vel = 150\n        self.cart_lin_vel = 400\n        self.joint_acc = 50\n        self.joint_vel_limit = 100\n        self.joint_vel = 50\n        self.move_mode = MxMoveMode.MX_MOVE_MODE_VELOCITY\n        self.move_duration_severity = MxEventSeverity.MX_EVENT_SEVERITY_WARNING\n        self.move_duration = 3.0\n        self.vel_timeout = 0.1\n        self.trf = [0, 0, 0, 0, 0, 0]\n        self.wrf = [0, 0, 0, 0, 0, 0]\n        self.payload = [0, 0, 0, 0]\n        self.gripper_force = 40\n        self.gripper_vel = 50\n        self.gripper_range = [0, 0]\n        self.move_jump_height = [MX_MOVE_JUMP_DEFAULT_HEIGHT_MM, MX_MOVE_JUMP_DEFAULT_HEIGHT_MM, 0, 102]\n        self.move_jump_approach_vel = [10, 1, 10, 1]\n        self.monitoring_interval = 1.0 / 60.0\n        self.real_time_monitoring = ['TargetJointPos', 'TargetCartPos']\n    def __eq__(self, other):\n        \"\"\"Comparison of each motion queue parameter (note: We could use a dataclass instead)\"\"\"", "hash": "4698b91d9b5b", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "This class regroups all motion queue parameters", "chunk_size_bytes": 1404, "original_size_bytes": 1409, "start_byte": 847, "end_byte": 2723}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:6c875f1da218", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "MotionQueueParams.__init__", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [40, 69], "text": "def __init__(self):\n        self.torque_limits_severity = MxEventSeverity.MX_EVENT_SEVERITY_WARNING\n        self.torque_limits_mode = MxTorqueLimitsMode.MX_TORQUE_LIMITS_DETECT_SKIP_ACCEL\n        self.torque_limits = [100] * 6\n        self.auto_conf = True\n        self.auto_conf_turn = True\n        self.blending = 100\n        self.cart_acc = 50\n        self.cart_ang_vel = 150\n        self.cart_lin_vel = 400\n        self.joint_acc = 50\n        self.joint_vel_limit = 100\n        self.joint_vel = 50\n        self.move_mode = MxMoveMode.MX_MOVE_MODE_VELOCITY\n        self.move_duration_severity = MxEventSeverity.MX_EVENT_SEVERITY_WARNING\n        self.move_duration = 3.0\n        self.vel_timeout = 0.1\n        self.trf = [0, 0, 0, 0, 0, 0]\n        self.wrf = [0, 0, 0, 0, 0, 0]\n        self.payload = [0, 0, 0, 0]\n        self.gripper_force = 40\n        self.gripper_vel = 50\n        self.gripper_range = [0, 0]\n        self.move_jump_height = [MX_MOVE_JUMP_DEFAULT_HEIGHT_MM, MX_MOVE_JUMP_DEFAULT_HEIGHT_MM, 0, 102]\n        self.move_jump_approach_vel = [10, 1, 10, 1]\n        self.monitoring_interval = 1.0 / 60.0\n        self.real_time_monitoring = ['TargetJointPos', 'TargetCartPos']", "hash": "6c875f1da218", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self)", "docstring": null, "chunk_size_bytes": 1189, "original_size_bytes": 1192, "start_byte": 937, "end_byte": 2129}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:1c2c2fdeaeef", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__eq__", "qualified_name": "MotionQueueParams.__eq__", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [71, 84], "text": "def __eq__(self, other):\n        \"\"\"Comparison of each motion queue parameter (note: We could use a dataclass instead)\"\"\"\n        for field in self.__dict__:\n            self_attr = getattr(self, field)\n            other_attr = getattr(other, field)\n            if other_attr is None:\n                return False\n            if isinstance(self_attr, list):\n                for idx, attr in enumerate(self_attr):\n                    if attr != other_attr[idx]:\n                        return False\n            elif self_attr != other_attr:\n                return False\n        return True", "hash": "1c2c2fdeaeef", "chunk_type": "method", "node_type": "function_definition", "signature": "__eq__(self, other)", "docstring": "Comparison of each motion queue parameter (note: We could use a dataclass instead)", "chunk_size_bytes": 588, "original_size_bytes": 588, "start_byte": 2135, "end_byte": 2723}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:b9d51ec6e1a6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "RobotWithTools", "qualified_name": "RobotWithTools", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [87, 219], "text": "class RobotWithTools(Robot):\n    \"\"\"This class is derived from the Robot class and adds some more utility methods that can be useful to manage\n       a robot.\n       Among other things, it has helper methods used to initialize the robot in a well-known state.\n    \"\"\"", "hash": "b9d51ec6e1a6", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "This class is derived from the Robot class and adds some more utility methods that can be useful to manage\n       a robot.\n       Among other things, it has helper methods used to initialize the robot in a well-known state.", "chunk_size_bytes": 267, "original_size_bytes": 267, "start_byte": 2726, "end_byte": 8978}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:5bd9b6c2d739", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "RobotWithTools.__init__", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [93, 97], "text": "def __init__(self):\n        super().__init__()\n        self._dirty_flags = DirtyFlags()\n        self._prev_motion_queue_params = None", "hash": "5bd9b6c2d739", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self)", "docstring": null, "chunk_size_bytes": 133, "original_size_bytes": 217, "start_byte": 2999, "end_byte": 3216}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:0475400a7b27", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "HasIoModule", "qualified_name": "RobotWithTools.HasIoModule", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [100, 102], "text": "def HasIoModule(self):\n        \"\"\" Tells if the IO module is connected/detected \"\"\"\n        return self.GetRtIoStatus(MxIoBankId.MX_IO_BANK_ID_IO_MODULE).present", "hash": "0475400a7b27", "chunk_type": "method", "node_type": "function_definition", "signature": "HasIoModule(self)", "docstring": "Tells if the IO module is connected/detected", "chunk_size_bytes": 161, "original_size_bytes": 161, "start_byte": 3257, "end_byte": 3418}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:f818ba215a6b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ActivateRobot", "qualified_name": "RobotWithTools.ActivateRobot", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [104, 111], "text": "def ActivateRobot(self):\n        \"\"\"Overload of ActivateRobot to set as \"dirty\" all motion-queue related settings\n            (which get reset on the robot upon activation and thus may no more match previously requested settings)\n        \"\"\"\n        with self._main_lock:\n            self._dirty_flags.set_dirty()\n        return super().ActivateRobot()", "hash": "f818ba215a6b", "chunk_type": "method", "node_type": "function_definition", "signature": "ActivateRobot(self)", "docstring": "Overload of ActivateRobot to set as \"dirty\" all motion-queue related settings\n            (which get reset on the robot upon activation and thus may no more match previously requested settings)", "chunk_size_bytes": 352, "original_size_bytes": 465, "start_byte": 3424, "end_byte": 3889}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:fbda6181f647", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "DeactivateRobot", "qualified_name": "RobotWithTools.DeactivateRobot", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [113, 120], "text": "def DeactivateRobot(self):\n        \"\"\"Overload of DeactivateRobot to set as \"dirty\" all motion-queue related settings\n            (which get reset on the robot upon activation and thus may no more match previously requested settings)\n        \"\"\"\n        with self._main_lock:\n            self._dirty_flags.set_dirty()\n        return super().DeactivateRobot()", "hash": "fbda6181f647", "chunk_type": "method", "node_type": "function_definition", "signature": "DeactivateRobot(self)", "docstring": "Overload of DeactivateRobot to set as \"dirty\" all motion-queue related settings\n            (which get reset on the robot upon activation and thus may no more match previously requested settings)", "chunk_size_bytes": 358, "original_size_bytes": 473, "start_byte": 3895, "end_byte": 4368}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:1c55699d83c9", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_activated", "qualified_name": "RobotWithTools._set_activated", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [122, 129], "text": "def _set_activated(self, activated: bool):\n        \"\"\"Overload of _set_activated to set as \"dirty\" all motion-queue related settings\n            (which get reset on the robot upon activation and thus may no more match previously requested settings)\n        \"\"\"\n        if not activated and self._robot_status.activation_state:\n            with self._main_lock:\n                self._dirty_flags.set_dirty()\n        return super()._set_activated(activated)", "hash": "1c55699d83c9", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_activated(self, activated: bool)", "docstring": "Overload of _set_activated to set as \"dirty\" all motion-queue related settings\n            (which get reset on the robot upon activation and thus may no more match previously requested settings)", "chunk_size_bytes": 455, "original_size_bytes": 455, "start_byte": 4374, "end_byte": 4829}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:f9511097f1b6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ActivateAndHome", "qualified_name": "RobotWithTools.ActivateAndHome", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [131, 137], "text": "def ActivateAndHome(self):\n        \"\"\"Overload of ActivateAndHome to set as \"dirty\" all motion-queue related settings\n            (which get reset on the robot upon activation and thus may no more match previously requested settings)\n        \"\"\"\n        with self._main_lock:\n            self._dirty_flags.set_dirty()\n        super().ActivateAndHome()", "hash": "f9511097f1b6", "chunk_type": "method", "node_type": "function_definition", "signature": "ActivateAndHome(self)", "docstring": "Overload of ActivateAndHome to set as \"dirty\" all motion-queue related settings\n            (which get reset on the robot upon activation and thus may no more match previously requested settings)", "chunk_size_bytes": 351, "original_size_bytes": 351, "start_byte": 4835, "end_byte": 5186}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:9092ffb2f0cc", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Disconnect", "qualified_name": "RobotWithTools.Disconnect", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [139, 143], "text": "def Disconnect(self):\n        \"\"\"Overload of Disconnect to set as \"dirty\" all motion-queue related settings\"\"\"\n        with self._main_lock:\n            self._dirty_flags.set_dirty()\n        return super().Disconnect()", "hash": "9092ffb2f0cc", "chunk_type": "method", "node_type": "function_definition", "signature": "Disconnect(self)", "docstring": "Overload of Disconnect to set as \"dirty\" all motion-queue related settings", "chunk_size_bytes": 218, "original_size_bytes": 218, "start_byte": 5192, "end_byte": 5410}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:62c97210ae92", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_send_command", "qualified_name": "RobotWithTools._send_command", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [145, 158], "text": "def _send_command(self, command: str, args: Optional[Union[str, list, tuple]] = None):\n        \"\"\" Here we catch some commands sent to the robot to detect is robot's settings are dirty and need to be\n            reset before running the next test \"\"\"\n        with self._main_lock:\n            command, args = self._split_command_args(command, args)\n            if command.lower() == 'setconf':\n                self._dirty_flags.add_sent_command('SetAutoConf')\n            elif command.lower() == 'setconfturn':\n                self._dirty_flags.add_sent_command('SetAutoConfTurn')\n            self._dirty_flags.add_sent_command(command)\n            super()._send_command(command, args)", "hash": "62c97210ae92", "chunk_type": "method", "node_type": "function_definition", "signature": "_send_command(self, command: str, args: Optional[Union[str, list, tuple]] = None)", "docstring": "Here we catch some commands sent to the robot to detect is robot's settings are dirty and need to be\n            reset before running the next test", "chunk_size_bytes": 685, "original_size_bytes": 851, "start_byte": 5416, "end_byte": 6267}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:5baed044e2d2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_robot_operation_mode", "qualified_name": "RobotWithTools._set_robot_operation_mode", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [160, 171], "text": "def _set_robot_operation_mode(self, robot_operation_mode: MxRobotOperationMode):\n        \"\"\"Update the \"robot_operation_mode\" from robot safety status\n        Parameters\n        ----------\n        robot_operation_mode : MxRobotOperationMode\n            New robot operation mode to set in robot state\n        \"\"\"\n        super()._set_robot_operation_mode(robot_operation_mode)\n        if robot_operation_mode == MxRobotOperationMode.MX_ROBOT_OPERATION_MODE_MANUAL:\n            self._dirty_flags.add_sent_command('SetTimeScaling')", "hash": "5baed044e2d2", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_robot_operation_mode(self, robot_operation_mode: MxRobotOperationMode)", "docstring": "Update the \"robot_operation_mode\" from robot safety status\n\n        Parameters\n        ----------\n        robot_operation_mode : MxRobotOperationMode\n            New robot operation mode to set in robot state", "chunk_size_bytes": 528, "original_size_bytes": 609, "start_byte": 6273, "end_byte": 6882}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:d0c4d93179f5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "set_dirty_if_params_changed", "qualified_name": "RobotWithTools.set_dirty_if_params_changed", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [173, 175], "text": "def set_dirty_if_params_changed(self, motion_queue_params: MotionQueueParams):\n        if (self._prev_motion_queue_params is None or self._prev_motion_queue_params != motion_queue_params):\n            self._dirty_flags.set_dirty()", "hash": "d0c4d93179f5", "chunk_type": "method", "node_type": "function_definition", "signature": "set_dirty_if_params_changed(self, motion_queue_params: MotionQueueParams)", "docstring": null, "chunk_size_bytes": 230, "original_size_bytes": 230, "start_byte": 6888, "end_byte": 7118}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:9d2b0644c49f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "clear_dirty_flags", "qualified_name": "RobotWithTools.clear_dirty_flags", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [177, 184], "text": "def clear_dirty_flags(self, motion_queue_params: Optional[MotionQueueParams] = None) -> bool:\n        \"\"\"Caller by test suite after it finished settings robot's initial state. From this moment, we'll be monitoring\n           which commands are sent to the robot and mark them as 'dirty' so we set again with default value when\n           starting next test case.\"\"\"\n        with self._main_lock:\n            if motion_queue_params:\n                self._prev_motion_queue_params = deepcopy(motion_queue_params)\n            return self._dirty_flags.clear_dirty()", "hash": "9d2b0644c49f", "chunk_type": "method", "node_type": "function_definition", "signature": "clear_dirty_flags(self, motion_queue_params: Optional[MotionQueueParams] = None)", "docstring": "Caller by test suite after it finished settings robot's initial state. From this moment, we'll be monitoring\n           which commands are sent to the robot and mark them as 'dirty' so we set again with default value when\n           starting next test case.", "chunk_size_bytes": 561, "original_size_bytes": 561, "start_byte": 7124, "end_byte": 7685}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:b14935556049", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "is_cmd_dirty", "qualified_name": "RobotWithTools.is_cmd_dirty", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [186, 195], "text": "def is_cmd_dirty(self, cmd_name: str) -> bool:\n        \"\"\"Tells if the specified command is 'dirty' (i.e. has been sent to robot since last test setup)\n        Parameters\n        ----------\n        cmd_name : str\n            Name of the command to check if dirty\n        \"\"\"\n        with self._main_lock:\n            return self._dirty_flags.is_dirty(cmd_name)", "hash": "b14935556049", "chunk_type": "method", "node_type": "function_definition", "signature": "is_cmd_dirty(self, cmd_name: str)", "docstring": "Tells if the specified command is 'dirty' (i.e. has been sent to robot since last test setup)\n\n        Parameters\n        ----------\n        cmd_name : str\n            Name of the command to check if dirty", "chunk_size_bytes": 360, "original_size_bytes": 361, "start_byte": 7691, "end_byte": 8052}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:623ffe57f8cc", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "set_if_dirty", "qualified_name": "RobotWithTools.set_if_dirty", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [197, 219], "text": "def set_if_dirty(self, cmd_name: str, *args: Tuple[any]):\n        \"\"\"Send the specified robot command, but only if 'dirt', i.e. if the robot does not already have this value\n        Parameters\n        ----------\n        cmd_name : str\n            Name of the \"Set\" command to send\n        *args :\n            Command-specific arguments\n        \"\"\"\n        with self._main_lock:\n            if not self.is_cmd_dirty(cmd_name):\n                return\n        func = getattr(self, cmd_name)\n        if func:\n            func(*args)\n        else:\n            args_string = \",\".join([str(arg) for arg in args])\n            cmd_string = f'cmd_name({args_string})'\n            self.SendCustomCommand(cmd_string)", "hash": "623ffe57f8cc", "chunk_type": "method", "node_type": "function_definition", "signature": "set_if_dirty(self, cmd_name: str, *args: Tuple[any])", "docstring": "Send the specified robot command, but only if 'dirt', i.e. if the robot does not already have this value\n\n        Parameters\n        ----------\n        cmd_name : str\n            Name of the \"Set\" command to send\n        *args :\n            Command-specific arguments", "chunk_size_bytes": 704, "original_size_bytes": 920, "start_byte": 8058, "end_byte": 8978}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:d319b937634b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "get_joint_limits_cfg", "qualified_name": "get_joint_limits_cfg", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [228, 235], "text": "def get_joint_limits_cfg(robot: RobotWithTools) -> bool:\n    \"\"\" Get joint limits configuration (enabled or not)\n    \"\"\"\n    event = robot.SendCustomCommand('GetJointLimitsCfg()',\n                                    expected_responses=[MxRobotStatusCode.MX_ST_GET_JOINT_LIMITS_CFG])\n    wait_result = event.wait(timeout=2)\n    return int(wait_result.data) != 0", "hash": "d319b937634b", "chunk_type": "function", "node_type": "function_definition", "signature": "get_joint_limits_cfg(robot: RobotWithTools)", "docstring": "Get joint limits configuration (enabled or not)", "chunk_size_bytes": 360, "original_size_bytes": 410, "start_byte": 9162, "end_byte": 9572}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:44d88707ae05", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "set_joint_limits_cfg", "qualified_name": "set_joint_limits_cfg", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [238, 251], "text": "def set_joint_limits_cfg(robot: RobotWithTools, set_enable=False):\n    \"\"\" Set enable/disable joint limits (deactivating the robot if necessary to apply the configuration change)\n    Parameters\n    ----------\n    set_enable : bool,\n        Enable joint limits or not by default False\n    \"\"\"\n    if set_enable != get_joint_limits_cfg(robot):\n        deactivate_robot(robot)\n        robot.SetJointLimitsCfg(set_enable)", "hash": "44d88707ae05", "chunk_type": "function", "node_type": "function_definition", "signature": "set_joint_limits_cfg(robot: RobotWithTools, set_enable=False)", "docstring": "Set enable/disable joint limits (deactivating the robot if necessary to apply the configuration change)\n\n    Parameters\n    ----------\n    set_enable : bool,\n        Enable joint limits or not by default False", "chunk_size_bytes": 417, "original_size_bytes": 516, "start_byte": 9575, "end_byte": 10091}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:ef3780fdb9c2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "get_joint_limits", "qualified_name": "get_joint_limits", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [254, 277], "text": "def get_joint_limits(robot: RobotWithTools, joint: int, use_model: bool = False) -> tuple[float]:\n    \"\"\"Get current joint limits for selected joint.\n    Parameters\n    ----------\n    joint : int\n        joint number to get limits\n    use_model : bool\n        return model limits (else effective joint limits)\n    Returns\n    -------\n    tuple[float]\n        low limit, high limit\n    \"\"\"\n    wait_result = robot.SendCustomCommand(\n        f'GetModelJointLimits({joint})' if use_model else f'GetJointLimits({joint})',\n        expected_responses=[MxRobotStatusCode.MX_ST_GET_MODEL_JOINT_LIMITS, MxRobotStatusCode.MX_ST_GET_JOINT_LIMITS],\n        timeout=2)\n    limits = [float(x) for x in wait_result.data.split(',')]\n    return limits[1], limits[2]", "hash": "ef3780fdb9c2", "chunk_type": "function", "node_type": "function_definition", "signature": "get_joint_limits(robot: RobotWithTools, joint: int, use_model: bool = False)", "docstring": "Get current joint limits for selected joint.\n\n    Parameters\n    ----------\n    joint : int\n        joint number to get limits\n    use_model : bool\n        return model limits (else effective joint limits)\n\n    Returns\n    -------\n    tuple[float]\n        low limit, high limit", "chunk_size_bytes": 748, "original_size_bytes": 846, "start_byte": 10094, "end_byte": 10940}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:7d349a55ea68", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "get_all_joint_limits", "qualified_name": "get_all_joint_limits", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [280, 296], "text": "def get_all_joint_limits(robot: RobotWithTools, use_model: bool = False) -> dict[int, tuple[float]]:\n    \"\"\" Get limits for each robot joint\n    Parameters\n    ----------\n    use_model : bool\n        return model limits\n    Returns\n    -------\n        dict {joint, [low_limit, high_limit]}\n    \"\"\"\n    limits = {}\n    for joint in range(1, robot.GetRobotInfo().num_joints + 1):\n        limits[joint] = get_joint_limits(robot, joint=joint, use_model=use_model)\n    return limits", "hash": "7d349a55ea68", "chunk_type": "function", "node_type": "function_definition", "signature": "get_all_joint_limits(robot: RobotWithTools, use_model: bool = False)", "docstring": "Get limits for each robot joint\n\n    Parameters\n    ----------\n    use_model : bool\n        return model limits\n\n    Returns\n    -------\n        dict {joint, [low_limit, high_limit]}", "chunk_size_bytes": 477, "original_size_bytes": 480, "start_byte": 10943, "end_byte": 11423}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:1f99c931bac9", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_joint_limits", "qualified_name": "_set_joint_limits", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [299, 316], "text": "def _set_joint_limits(robot: RobotWithTools, joint: int, low_limit: float, high_limit: float):\n    \"\"\" Set limits on selected joint (deactivating the robot if necessary to apply the configuration change)\n    Parameters\n    ----------\n    joint : int\n        joint number where to set the limit\n    low_limit : float\n        lower joint limit\n    high_limit : float\n        higher joint limit\n    \"\"\"\n    deactivate_robot(robot)\n    robot.SetJointLimits(joint, low_limit, high_limit)", "hash": "1f99c931bac9", "chunk_type": "function", "node_type": "function_definition", "signature": "_set_joint_limits(robot: RobotWithTools, joint: int, low_limit: float, high_limit: float)", "docstring": "Set limits on selected joint (deactivating the robot if necessary to apply the configuration change)\n\n    Parameters\n    ----------\n    joint : int\n        joint number where to set the limit\n    low_limit : float\n        lower joint limit\n    high_limit : float\n        higher joint limit", "chunk_size_bytes": 482, "original_size_bytes": 582, "start_byte": 11426, "end_byte": 12008}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:b942da1f19cf", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_enable_joint_limits_for_ext_tool", "qualified_name": "_enable_joint_limits_for_ext_tool", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [319, 380], "text": "def _enable_joint_limits_for_ext_tool(robot: RobotWithTools, move_to_safe_position=False):\n    \"\"\"This function configures appropriate joint limits depending on the detected external tool, as described\n        in documentation for public method reset_joint_limits below\n    Args:\n        robot (RobotWithTools):                 Robot to configure joint limits for\n        move_to_safe_position (bool, optional): If True and robot is outside the limits, this function will attempt\n                                                to move it inside the limits (using recovery mode) before enabling\n                                                the limits.\n                                                Defaults to False.\n    \"\"\"\n    if not robot.GetRobotInfo().supports_ext_tool:\n        set_joint_limits_cfg(robot, set_enable=False)\n        return\n    if not robot.GetRtExtToolStatus().is_physical_tool_present():\n        set_joint_limits_cfg(robot, set_enable=False)\n    else:\n        expected_joint_limits = get_all_joint_limits(robot, use_model=True)\n        if robot.GetRtExtToolStatus().is_gripper(physical=True):\n            expected_joint_limits[6] = (-200, 200)\n        elif robot.GetRtExtToolStatus().is_pneumatic_module(physical=True):\n            expected_joint_limits[5] = (-100, 100)\n        set_limits = not get_joint_limits_cfg(robot)\n        if not set_limits:\n            for joint, limits in expected_joint_limits.items():\n                if (limits[0], limits[1]) != get_joint_limits(robot, joint=joint):\n                    set_limits = True\n        if move_to_safe_position:\n            cur_joint_pos = robot.GetRtTargetJointPos()\n            for limits, pos in zip(expected_joint_limits.items(), cur_joint_pos):\n                if not limits[1][0] + 5 <= float(pos) <= limits[1][1] - 5:\n                    if not robot.GetStatusRobot().activation_state:\n                        reset_sim_mode(robot)\n                        configure_recovery_mode(robot, True)\n                        robot.ActivateRobot()\n                        robot.WaitActivated()\n                    target_pos = [0] * robot.GetRobotInfo().num_joints\n                    robot.MoveJoints(*target_pos)\n                    robot.WaitIdle()\n                    break\n        if set_limits:\n            for joint, limits in expected_joint_limits.items():\n                _set_joint_limits(robot, joint=joint, low_limit=limits[0], high_limit=limits[1])\n            set_joint_limits_cfg(robot, set_enable=True)", "hash": "b942da1f19cf", "chunk_type": "function", "node_type": "function_definition", "signature": "_enable_joint_limits_for_ext_tool(robot: RobotWithTools, move_to_safe_position=False)", "docstring": "This function configures appropriate joint limits depending on the detected external tool, as described\n        in documentation for public method reset_joint_limits below\n\n    Args:\n        robot (RobotWithTools):                 Robot to configure joint limits for\n        move_to_safe_position (bool, optional): If True and robot is outside the limits, this function will attempt\n                                                to move it inside the limits (using recovery mode) before enabling\n                                                the limits.\n                                                Defaults to False.", "chunk_size_bytes": 2502, "original_size_bytes": 3099, "start_byte": 12011, "end_byte": 15110}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:f848f221ecb9", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_joint_limits", "qualified_name": "reset_joint_limits", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [383, 399], "text": "def reset_joint_limits(robot: RobotWithTools):\n    \"\"\" This function attempts to determine appropriate joint limits to apply according to type of external tool\n        connected to the robot.\n        *** WARNING ***\n        There is no warranty that the chosen joint limits are appropriate for your physical setup.\n        The cable length or other constraints on your robot may cause different joint limits requirements.\n        Please use this method only if your situation is covered by one of the cases below.\n        This function handles only the following cases (write your own function if your situation differs)\n        - For Meca500 with a MPM500 pneumatic module, a limit will be set to avoid collision with the joint 4\n        - For Meca500 with a MEGP-25E or MEGP-25LS gripper, joint 6 will be limited to +/- 180 degrees to avoid\n          damaging the cable.\n        - Otherwise, joint limits are disabled\n    \"\"\"\n    _enable_joint_limits_for_ext_tool(robot)", "hash": "f848f221ecb9", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_joint_limits(robot: RobotWithTools)", "docstring": "This function attempts to determine appropriate joint limits to apply according to type of external tool\n        connected to the robot.\n\n        *** WARNING ***\n        There is no warranty that the chosen joint limits are appropriate for your physical setup.\n        The cable length or other constraints on your robot may cause different joint limits requirements.\n        Please use this method only if your situation is covered by one of the cases below.\n\n        This function handles only the following cases (write your own function if your situation differs)\n        - For Meca500 with a MPM500 pneumatic module, a limit will be set to avoid collision with the joint 4\n        - For Meca500 with a MEGP-25E or MEGP-25LS gripper, joint 6 will be limited to +/- 180 degrees to avoid\n          damaging the cable.\n        - Otherwise, joint limits are disabled", "chunk_size_bytes": 972, "original_size_bytes": 1039, "start_byte": 15113, "end_byte": 16152}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:ac2557192e15", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_work_zone_limits", "qualified_name": "reset_work_zone_limits", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [402, 436], "text": "def reset_work_zone_limits(robot: RobotWithTools):\n    \"\"\"This function reverts work zone limits to defaults.\n    \"\"\"\n    expected_cfg = [\n        MxEventSeverity.MX_EVENT_SEVERITY_ERROR, MxWorkZoneMode.MX_WORK_ZONE_MODE_ROBOT_AND_TOOL_IN_WORK_ZONE\n    ]\n    expected_limits = [-10000, -10000, -10000, 10000, 10000, 10000]\n    response = robot.SendCustomCommand('GetWorkZoneCfg()',\n                                       expected_responses=[MxRobotStatusCode.MX_ST_GET_WORK_ZONE_CFG],\n                                       timeout=2)\n    current_work_zone_limits_cfg = string_to_numbers(response.data)\n    need_to_set_cfg = current_work_zone_limits_cfg != expected_cfg\n    response = robot.SendCustomCommand('GetWorkZoneLimits()',\n                                       expected_responses=[MxRobotStatusCode.MX_ST_GET_WORK_ZONE_LIMITS],\n                                       timeout=2)\n    current_work_zone_limits = string_to_numbers(response.data)\n    need_to_set_limits = current_work_zone_limits != expected_limits\n    if not need_to_set_cfg and not need_to_set_limits:\n        return\n    deactivate_robot(robot)\n    if need_to_set_limits:\n        robot.SetWorkZoneLimits(*expected_limits)\n    if need_to_set_cfg:\n        robot.SetWorkZoneCfg(*expected_cfg)", "hash": "ac2557192e15", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_work_zone_limits(robot: RobotWithTools)", "docstring": "This function reverts work zone limits to defaults.", "chunk_size_bytes": 1263, "original_size_bytes": 1570, "start_byte": 16155, "end_byte": 17725}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:a0c7aec05469", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_collision_cfg", "qualified_name": "reset_collision_cfg", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [439, 473], "text": "def reset_collision_cfg(robot: RobotWithTools):\n    \"\"\"This function reverts collision configurations to defaults.\n    \"\"\"\n    expected_severity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR\n    expected_tool_sphere = [0, 0, 0, 0]\n    expected_collision_cfg = [expected_severity]\n    response = robot.SendCustomCommand('GetCollisionCfg()',\n                                       expected_responses=[MxRobotStatusCode.MX_ST_GET_COLLISION_CFG],\n                                       timeout=2)\n    current_collision_cfg = string_to_numbers(response.data)\n    need_to_set_collision_cfg = current_collision_cfg != expected_collision_cfg\n    response = robot.SendCustomCommand('GetToolSphere()',\n                                       expected_responses=[MxRobotStatusCode.MX_ST_GET_TOOL_SPHERE],\n                                       timeout=2)\n    current_tool_sphere = string_to_numbers(response.data)\n    need_to_set_tool_sphere = current_tool_sphere != expected_tool_sphere\n    if not need_to_set_tool_sphere and not need_to_set_collision_cfg:\n        return\n    deactivate_robot(robot)\n    if need_to_set_tool_sphere:\n        robot.SetToolSphere(*expected_tool_sphere)\n    if need_to_set_collision_cfg:\n        robot.SetCollisionCfg(*expected_collision_cfg)", "hash": "a0c7aec05469", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_collision_cfg(robot: RobotWithTools)", "docstring": "This function reverts collision configurations to defaults.", "chunk_size_bytes": 1256, "original_size_bytes": 1433, "start_byte": 17728, "end_byte": 19161}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:9e47d6403425", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_pstop2_cfg", "qualified_name": "reset_pstop2_cfg", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [476, 495], "text": "def reset_pstop2_cfg(robot: RobotWithTools):\n    \"\"\"This function reverts PStop2 configuration to defaults.\n    \"\"\"\n    expected_severity = [MxEventSeverity.MX_EVENT_SEVERITY_CLEAR_MOTION]\n    response = robot.SendCustomCommand('GetPStop2Cfg()',\n                                       expected_responses=[MxRobotStatusCode.MX_ST_GET_PSTOP2_CFG],\n                                       timeout=2)\n    current_severity = string_to_numbers(response.data)\n    need_to_set_cfg = expected_severity != current_severity\n    if not need_to_set_cfg:\n        return\n    deactivate_robot(robot)\n    robot.SetPStop2Cfg(expected_severity[0])", "hash": "9e47d6403425", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_pstop2_cfg(robot: RobotWithTools)", "docstring": "This function reverts PStop2 configuration to defaults.", "chunk_size_bytes": 627, "original_size_bytes": 744, "start_byte": 19164, "end_byte": 19908}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:f13f714310b2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_sim_mode_cfg", "qualified_name": "reset_sim_mode_cfg", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [498, 518], "text": "def reset_sim_mode_cfg(robot: RobotWithTools):\n    \"\"\"This function reverts simulation mode configuration to defaults.\n    \"\"\"\n    expected_sim_mode_cfg = [MxRobotSimulationMode.MX_SIM_MODE_REAL_TIME]\n    if not robot.GetRobotInfo().version.is_at_least(11, 1, 2):\n        return\n    response = robot.SendCustomCommand('GetSimModeCfg()',\n                                       expected_responses=[MxRobotStatusCode.MX_ST_GET_SIM_MODE_CFG],\n                                       timeout=2)\n    current_sim_mode_cfg = string_to_numbers(response.data)\n    need_to_set_cfg = expected_sim_mode_cfg != current_sim_mode_cfg\n    if not need_to_set_cfg:\n        return\n    robot.SetSimModeCfg(expected_sim_mode_cfg[0])", "hash": "f13f714310b2", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_sim_mode_cfg(robot: RobotWithTools)", "docstring": "This function reverts simulation mode configuration to defaults.", "chunk_size_bytes": 709, "original_size_bytes": 818, "start_byte": 19911, "end_byte": 20729}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:006a96d75945", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_vacuum_grip", "qualified_name": "reset_vacuum_grip", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [521, 529], "text": "def reset_vacuum_grip(robot: RobotWithTools):\n    \"\"\"This function release vacuum from the io module (without purging) and restores default purge duration \"\"\"\n    if (robot.HasIoModule()\n            or robot.GetRtIoStatus(MxIoBankId.MX_IO_BANK_ID_IO_MODULE).sim_mode) and robot.GetRtVacuumState().vacuum_on:\n        robot.SetVacuumPurgeDuration_Immediate(0)  # No purge, just stop vacuum\n        event = robot.GetInterruptableEvent([MxRobotStatusCode.MX_ST_RT_VACUUM_STATE])\n        robot.VacuumRelease_Immediate()\n        event.wait(timeout=0.1)\n        robot.SetVacuumPurgeDuration_Immediate(-1)  # Restore default duration", "hash": "006a96d75945", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_vacuum_grip(robot: RobotWithTools)", "docstring": "This function release vacuum from the io module (without purging) and restores default purge duration", "chunk_size_bytes": 625, "original_size_bytes": 625, "start_byte": 20732, "end_byte": 21357}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:a3ee1d60718c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_vacuum_grip_parameters", "qualified_name": "reset_vacuum_grip_parameters", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [532, 536], "text": "def reset_vacuum_grip_parameters(robot: RobotWithTools):\n    \"\"\"This function restores default vacuum gripper parameters (thresholds and purge duration)\"\"\"\n    if robot.HasIoModule() or robot.GetRtIoStatus(MxIoBankId.MX_IO_BANK_ID_IO_MODULE).sim_mode:\n        robot.SetVacuumThreshold_Immediate(0, 0)  # Restore default thresholds\n        robot.SetVacuumPurgeDuration_Immediate(-1)  # Restore default duration", "hash": "a3ee1d60718c", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_vacuum_grip_parameters(robot: RobotWithTools)", "docstring": "This function restores default vacuum gripper parameters (thresholds and purge duration)", "chunk_size_bytes": 409, "original_size_bytes": 409, "start_byte": 21360, "end_byte": 21769}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:a9d79740af12", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_reset_io_sim_bank", "qualified_name": "_reset_io_sim_bank", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [539, 542], "text": "def _reset_io_sim_bank(robot: RobotWithTools, bank_id: MxIoBankId):\n    \"\"\"This function clears IO simulation mode for specified IO module\"\"\"\n    robot.SetIoSim(bank_id, False)\n    robot.WaitIoSimDisabled(bank_id)", "hash": "a9d79740af12", "chunk_type": "function", "node_type": "function_definition", "signature": "_reset_io_sim_bank(robot: RobotWithTools, bank_id: MxIoBankId)", "docstring": "This function clears IO simulation mode for specified IO module", "chunk_size_bytes": 213, "original_size_bytes": 213, "start_byte": 21772, "end_byte": 21985}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:a7416a855cb3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_io_sim", "qualified_name": "reset_io_sim", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [545, 553], "text": "def reset_io_sim(robot: RobotWithTools):\n    \"\"\"This function clears IO simulation mode\"\"\"\n    if not robot.GetRobotInfo().supports_io_module:\n        return\n    if robot.GetStatusRobot().simulation_mode != MxRobotSimulationMode.MX_SIM_MODE_DISABLED:\n        return\n    if robot.GetRtIoStatus(MxIoBankId.MX_IO_BANK_ID_IO_MODULE).sim_mode:\n        _reset_io_sim_bank(robot, MxIoBankId.MX_IO_BANK_ID_IO_MODULE)", "hash": "a7416a855cb3", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_io_sim(robot: RobotWithTools)", "docstring": "This function clears IO simulation mode", "chunk_size_bytes": 408, "original_size_bytes": 483, "start_byte": 21988, "end_byte": 22471}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:0a3e9e2c0b1c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_reset_digital_outputs_bank", "qualified_name": "_reset_digital_outputs_bank", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [556, 567], "text": "def _reset_digital_outputs_bank(robot: RobotWithTools, bank_id: MxIoBankId):\n    \"\"\"This function clears all digital outputs for specified bank\"\"\"\n    curr_output_states = robot.GetRtOutputState(bank_id).data\n    nb_outputs = len(curr_output_states)\n    cleared_outputs = [0] * nb_outputs\n    if curr_output_states == cleared_outputs:\n        return\n    robot.SetOutputState_Immediate(bank_id, *cleared_outputs)", "hash": "0a3e9e2c0b1c", "chunk_type": "function", "node_type": "function_definition", "signature": "_reset_digital_outputs_bank(robot: RobotWithTools, bank_id: MxIoBankId)", "docstring": "This function clears all digital outputs for specified bank", "chunk_size_bytes": 411, "original_size_bytes": 485, "start_byte": 22474, "end_byte": 22959}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:82ad710e216f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_wait_outputs_cleared", "qualified_name": "_wait_outputs_cleared", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [570, 586], "text": "def _wait_outputs_cleared(robot: RobotWithTools):\n    \"\"\"Wait until all digital outputs have been cleared\"\"\"\n    io_module_outputs = robot.GetRtOutputState(MxIoBankId.MX_IO_BANK_ID_IO_MODULE).data\n    io_module_outputs_cleared = [0] * len(io_module_outputs)\n    start_wait = time.monotonic()\n    while io_module_outputs != io_module_outputs_cleared:\n        if time.monotonic() - start_wait > 2:\n            raise TimeoutError(f'Timeout waiting for digital outputs to be cleared (io_module={io_module_outputs})')\n        event = robot.GetInterruptableEvent([MxRobotStatusCode.MX_ST_RT_OUTPUT_STATE])\n        try:\n            event.wait(timeout=0.01)\n        except TimeoutException:\n            pass\n        io_module_outputs = robot.GetRtOutputState(MxIoBankId.MX_IO_BANK_ID_IO_MODULE).data", "hash": "82ad710e216f", "chunk_type": "function", "node_type": "function_definition", "signature": "_wait_outputs_cleared(robot: RobotWithTools)", "docstring": "Wait until all digital outputs have been cleared", "chunk_size_bytes": 791, "original_size_bytes": 885, "start_byte": 22962, "end_byte": 23847}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:dbc9ffee4842", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_digital_outputs", "qualified_name": "reset_digital_outputs", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [589, 593], "text": "def reset_digital_outputs(robot: RobotWithTools):\n    \"\"\"This function clears all digital outputs for all banks\"\"\"\n    if robot.HasIoModule():\n        _reset_digital_outputs_bank(robot, MxIoBankId.MX_IO_BANK_ID_IO_MODULE)\n        _wait_outputs_cleared(robot)", "hash": "dbc9ffee4842", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_digital_outputs(robot: RobotWithTools)", "docstring": "This function clears all digital outputs for all banks", "chunk_size_bytes": 258, "original_size_bytes": 258, "start_byte": 23850, "end_byte": 24108}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:05b837f60503", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "deactivate_robot", "qualified_name": "deactivate_robot", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [601, 608], "text": "def deactivate_robot(robot: RobotWithTools):\n    \"\"\"This function deactivates the robot, and awaits confirmation\n    \"\"\"\n    if not robot.GetStatusRobot().activation_state:\n        return\n    robot.DeactivateRobot()\n    robot.WaitDeactivated(timeout=10)", "hash": "05b837f60503", "chunk_type": "function", "node_type": "function_definition", "signature": "deactivate_robot(robot: RobotWithTools)", "docstring": "This function deactivates the robot, and awaits confirmation", "chunk_size_bytes": 253, "original_size_bytes": 283, "start_byte": 24183, "end_byte": 24466}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:c067c8a8e85c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "configure_recovery_mode", "qualified_name": "configure_recovery_mode", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [611, 619], "text": "def configure_recovery_mode(robot: RobotWithTools, recovery_mode: bool):\n    \"\"\"Enable or disable recovery mode on the robot\"\"\"\n    is_dirty = robot.is_cmd_dirty('SetRecoveryMode')\n    if robot.GetStatusRobot().recovery_mode == recovery_mode and not is_dirty:\n        return\n    robot.SetRecoveryMode(recovery_mode)\n    robot.WaitRecoveryMode(recovery_mode)", "hash": "c067c8a8e85c", "chunk_type": "function", "node_type": "function_definition", "signature": "configure_recovery_mode(robot: RobotWithTools, recovery_mode: bool)", "docstring": "Enable or disable recovery mode on the robot", "chunk_size_bytes": 357, "original_size_bytes": 397, "start_byte": 24469, "end_byte": 24866}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:7f1d0496b76e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_sim_mode", "qualified_name": "reset_sim_mode", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [622, 633], "text": "def reset_sim_mode(robot: RobotWithTools):\n    \"\"\"Disables the robot simulation mode if not already done\n       (including deactivating the robot if necessary)\n    \"\"\"\n    if robot.GetStatusRobot().simulation_mode == MxRobotSimulationMode.MX_SIM_MODE_DISABLED:\n        return\n    if robot.GetStatusRobot().activation_state:\n        deactivate_robot(robot)\n    robot.DeactivateSim()\n    robot.WaitSimDeactivated(timeout=2)", "hash": "7f1d0496b76e", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_sim_mode(robot: RobotWithTools)", "docstring": "Disables the robot simulation mode if not already done\n       (including deactivating the robot if necessary)", "chunk_size_bytes": 421, "original_size_bytes": 448, "start_byte": 24869, "end_byte": 25317}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:6cab4c519afb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_error", "qualified_name": "reset_error", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [636, 653], "text": "def reset_error(robot: RobotWithTools):\n    \"\"\"Synchronously reset robot error (if robot is in error state).\n    Args:\n        robot (RobotWithTools): Robot to reset error for\n    Raises\n        ------\n        TimeoutException\n            Raised if the robot does not report error being cleared in a reasonable time\n        InterruptException\n            Raised if waiting becomes irrelevant (disconnected from the robot for example)\n    \"\"\"\n    if not robot.GetStatusRobot().error_status:\n        return\n    robot.ResetError()\n    robot.WaitErrorReset(timeout=5)", "hash": "6cab4c519afb", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_error(robot: RobotWithTools)", "docstring": "Synchronously reset robot error (if robot is in error state).\n\n    Args:\n        robot (RobotWithTools): Robot to reset error for\n\n    Raises\n        ------\n        TimeoutException\n            Raised if the robot does not report error being cleared in a reasonable time\n        InterruptException\n            Raised if waiting becomes irrelevant (disconnected from the robot for example)", "chunk_size_bytes": 563, "original_size_bytes": 593, "start_byte": 25320, "end_byte": 25913}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:f8a4f4bf5fb3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "clear_motion", "qualified_name": "clear_motion", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [656, 674], "text": "def clear_motion(robot: RobotWithTools, then_resume=False):\n    \"\"\"This function clears robot's motion queue, and optionally resumes motion,\n       then awaits confirmation\n    Parameters\n    ----------\n    then_resume : bool, optional\n        Resume motion after clearing motion queue, by default False\n    \"\"\"\n    if robot.GetStatusRobot().error_status:\n        return\n    if not robot.GetStatusRobot().homing_state:\n        return\n    robot.ClearMotion()\n    robot.WaitMotionCleared(timeout=5)\n    robot.WaitMotionPaused(timeout=2)\n    if then_resume:\n        robot.ResumeMotion()\n        robot.WaitMotionResumed(timeout=2)", "hash": "f8a4f4bf5fb3", "chunk_type": "function", "node_type": "function_definition", "signature": "clear_motion(robot: RobotWithTools, then_resume=False)", "docstring": "This function clears robot's motion queue, and optionally resumes motion,\n       then awaits confirmation\n\n    Parameters\n    ----------\n    then_resume : bool, optional\n        Resume motion after clearing motion queue, by default False", "chunk_size_bytes": 626, "original_size_bytes": 627, "start_byte": 25916, "end_byte": 26543}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:59d527b220f3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "resume_motion", "qualified_name": "resume_motion", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [677, 689], "text": "def resume_motion(robot: RobotWithTools):\n    \"\"\"Resumes robot's motion queue (if it's in run state) and awaits confirmation\"\"\"\n    if robot.GetStatusRobot().error_status:\n        return\n    if not robot.GetStatusRobot().pause_motion_status:\n        return\n    if not robot.GetStatusRobot().homing_state:\n        return\n    robot.ResumeMotion()\n    robot.WaitMotionResumed(timeout=2)", "hash": "59d527b220f3", "chunk_type": "function", "node_type": "function_definition", "signature": "resume_motion(robot: RobotWithTools)", "docstring": "Resumes robot's motion queue (if it's in run state) and awaits confirmation", "chunk_size_bytes": 383, "original_size_bytes": 505, "start_byte": 26546, "end_byte": 27051}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:0bff12b0b05c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_robot_configuration", "qualified_name": "reset_robot_configuration", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [697, 706], "text": "def reset_robot_configuration(robot: RobotWithTools):\n    \"\"\"This function resets robot configuration to default state ***\n    \"\"\"\n    reset_error(robot)\n    reset_sim_mode(robot)\n    reset_joint_limits(robot)\n    reset_work_zone_limits(robot)\n    reset_collision_cfg(robot)\n    reset_pstop2_cfg(robot)\n    reset_sim_mode_cfg(robot)", "hash": "0bff12b0b05c", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_robot_configuration(robot: RobotWithTools)", "docstring": "This function resets robot configuration to default state ***", "chunk_size_bytes": 332, "original_size_bytes": 332, "start_byte": 27137, "end_byte": 27469}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:0d88375c4121", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_motion_queue", "qualified_name": "reset_motion_queue", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [712, 783], "text": "def reset_motion_queue(robot: RobotWithTools, params: MotionQueueParams = None, activate_home=False):\n    \"\"\"This function resets robot's motion queue to default values\n    Args:\n        robot (RobotWithTools):                 Robot to reset motion queue for\n        params (MotionQueueParams, optional):   Motion queue parameters to apply.\n                                                Default values from MotionQueueParams are used if None.\n                                                Defaults to None.\n        activate_home (bool, optional): True  -> Activate and home the robot if not already done\n                                        False -> Don't change robot status (do nothing if not activated and homed)\n                                        Defaults to False.\n    \"\"\"\n    if robot.GetRobotInfo().supports_time_scaling:\n        robot.set_if_dirty('SetTimeScaling', 100)\n    if activate_home and not robot.GetStatusRobot().homing_state:\n        robot.ActivateAndHome()\n        robot.WaitHomed()\n    if robot.GetStatusRobot().homing_state:\n        if params is None:\n            params = MotionQueueParams()\n        robot.set_dirty_if_params_changed(params)\n        reset_error(robot)\n        clear_motion(robot, then_resume=True)\n        if robot.GetRobotInfo().supports_torque_limits:\n            robot.set_if_dirty('SetTorqueLimitsCfg', params.torque_limits_severity, params.torque_limits_mode)\n            num_joints = robot.GetRobotInfo().num_joints\n            if len(params.torque_limits) == num_joints:\n                robot.set_if_dirty('SetTorqueLimits', *params.torque_limits)\n            else:\n                robot.set_if_dirty('SetTorqueLimits', *params.torque_limits[:num_joints])\n        robot.set_if_dirty('SetAutoConf', params.auto_conf)\n        if robot.GetRobotInfo().supports_conf_turn:\n            robot.set_if_dirty('SetAutoConfTurn', params.auto_conf_turn)\n        robot.set_if_dirty('SetBlending', params.blending)\n        robot.set_if_dirty('SetCartAcc', params.cart_acc)\n        robot.set_if_dirty('SetCartAngVel', params.cart_ang_vel)\n        robot.set_if_dirty('SetCartLinVel', params.cart_lin_vel)\n        robot.set_if_dirty('SetJointAcc', params.joint_acc)\n        if robot.GetRobotInfo().supports_joint_vel_limit:\n            robot.set_if_dirty('SetJointVelLimit', params.joint_vel_limit)\n        robot.set_if_dirty('SetJointVel', params.joint_vel)\n        if robot.GetRobotInfo().supports_move_duration:\n            robot.set_if_dirty('SetMoveMode', params.move_mode)\n            robot.set_if_dirty('SetMoveDurationCfg', params.move_duration_severity)\n            robot.set_if_dirty('SetMoveDuration', params.move_duration)\n        robot.set_if_dirty('SetVelTimeout', params.vel_timeout)\n        robot.set_if_dirty('SetTrf', *params.trf)\n        robot.set_if_dirty('SetWrf', *params.wrf)\n        if robot.GetRobotInfo().version.is_at_least(9, 3):\n            robot.set_if_dirty('SetPayload', *params.payload)\n        if robot_model_support_eoat(robot.GetRobotInfo().robot_model):\n            robot.set_if_dirty('SetGripperForce', params.gripper_force)\n            robot.set_if_dirty('SetGripperVel', params.gripper_vel)\n            if robot.GetRobotInfo().gripper_pos_ctrl_capable:\n                robot.set_if_dirty('SetGripperRange', *params.gripper_range)\n        if robot.GetRobotInfo().num_joints == 4:\n            robot.set_if_dirty('SetMoveJumpHeight', *params.move_jump_height)\n            robot.set_if_dirty('SetMoveJumpApproachVel', *params.move_jump_approach_vel)\n        robot.set_if_dirty('SetMonitoringInterval', params.monitoring_interval)\n        if robot.GetRobotInfo().version.is_at_least(9, 3):\n            robot.set_if_dirty('SetRealTimeMonitoring', *params.real_time_monitoring)\n        robot.clear_dirty_flags(params)", "hash": "0d88375c4121", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_motion_queue(robot: RobotWithTools, params: MotionQueueParams = None, activate_home=False)", "docstring": "This function resets robot's motion queue to default values\n\n    Args:\n        robot (RobotWithTools):                 Robot to reset motion queue for\n        params (MotionQueueParams, optional):   Motion queue parameters to apply.\n                                                Default values from MotionQueueParams are used if None.\n                                                Defaults to None.\n        activate_home (bool, optional): True  -> Activate and home the robot if not already done\n                                        False -> Don't change robot status (do nothing if not activated and homed)\n                                        Defaults to False.", "chunk_size_bytes": 3791, "original_size_bytes": 3941, "start_byte": 27593, "end_byte": 31534}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_initializer.py:33ec6eba9291", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "reset_vacuum_module", "qualified_name": "reset_vacuum_module", "source_path": "mecademicpy/mecademicpy/robot_initializer.py", "loc": [786, 791], "text": "def reset_vacuum_module(robot: RobotWithTools):\n    \"\"\"Reset the MVK01 vacuum module states (does nothing if not present)\"\"\"\n    reset_vacuum_grip(robot)\n    reset_vacuum_grip_parameters(robot)\n    reset_io_sim(robot)\n    reset_digital_outputs(robot)", "hash": "33ec6eba9291", "chunk_type": "function", "node_type": "function_definition", "signature": "reset_vacuum_module(robot: RobotWithTools)", "docstring": "Reset the MVK01 vacuum module states (does nothing if not present)", "chunk_size_bytes": 250, "original_size_bytes": 250, "start_byte": 31537, "end_byte": 31787}
