{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:bcab709e15be", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "numpy as np", "qualified_name": "numpy as np", "source_path": "utilities/MathAddonFunctions.py", "loc": [1, 1], "text": "import numpy as np", "hash": "bcab709e15be", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 18, "original_size_bytes": 18, "start_byte": 0, "end_byte": 18}
{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:873d7b0dccc5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "linalg as LA", "qualified_name": "linalg as LA", "source_path": "utilities/MathAddonFunctions.py", "loc": [2, 2], "text": "from numpy import linalg as LA", "hash": "873d7b0dccc5", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 30, "original_size_bytes": 30, "start_byte": 19, "end_byte": 49}
{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:305e5c5942ed", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Mat", "qualified_name": "Mat", "source_path": "utilities/MathAddonFunctions.py", "loc": [4, 45], "text": "class Mat():\n    '''\n    A Matrix class to handle the pose transformation and rotation matrices\n    used for calculating WRF and TCP\n    '''", "hash": "305e5c5942ed", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "A Matrix class to handle the pose transformation and rotation matrices\n    used for calculating WRF and TCP", "chunk_size_bytes": 140, "original_size_bytes": 140, "start_byte": 51, "end_byte": 1414}
{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:388f02cec7b8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "Mat.__init__", "source_path": "utilities/MathAddonFunctions.py", "loc": [10, 38], "text": "def __init__(self,pose):\n        self.x = pose[0]\n        self.y = pose[1]\n        self.z = pose[2]\n        alpha = np.deg2rad(pose[3])\n        beta = np.deg2rad(pose[4])\n        gamma = np.deg2rad(pose[5]) \n        sin_alpha = np.sin(alpha)\n        cos_alpha = np.cos(alpha)\n        sin_beta = np.sin(beta)\n        cos_beta = np.cos(beta)\n        sin_gamma = np.sin(gamma)\n        cos_gamma = np.cos(gamma)\n        self.r11 = cos_beta*cos_gamma\n        self.r12 = -(cos_beta)*(sin_gamma)\n        self.r13 = sin_beta\n        self.r21 = cos_alpha*sin_gamma + sin_alpha*sin_beta*cos_gamma\n        self.r22 = cos_alpha*cos_gamma - sin_alpha*sin_beta*sin_gamma\n        self.r23 = -(sin_alpha*cos_beta)\n        self.r31 = sin_alpha*sin_gamma - cos_alpha*sin_beta*cos_gamma\n        self.r32 = sin_alpha*cos_gamma + cos_alpha*sin_beta*sin_gamma\n        self.r33 = cos_alpha*cos_beta", "hash": "388f02cec7b8", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self,pose)", "docstring": null, "chunk_size_bytes": 875, "original_size_bytes": 890, "start_byte": 201, "end_byte": 1091}
{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:3e8e3a2b796d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "H", "qualified_name": "Mat.H", "source_path": "utilities/MathAddonFunctions.py", "loc": [41, 42], "text": "def H(self):\n        return np.array([[self.r11, self.r12, self.r13, self.x],[self.r21, self.r22, self.r23, self.y],[self.r31, self.r32, self.r33, self.z],[0, 0, 0, 1]])", "hash": "3e8e3a2b796d", "chunk_type": "method", "node_type": "function_definition", "signature": "H(self)", "docstring": null, "chunk_size_bytes": 169, "original_size_bytes": 169, "start_byte": 1098, "end_byte": 1267}
{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:ac2a60a983d1", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "R33", "qualified_name": "Mat.R33", "source_path": "utilities/MathAddonFunctions.py", "loc": [44, 45], "text": "def R33(self):\n        return np.array([[self.r11, self.r12, self.r13],[self.r21, self.r22, self.r23],[self.r31, self.r32, self.r33]])", "hash": "ac2a60a983d1", "chunk_type": "method", "node_type": "function_definition", "signature": "R33(self)", "docstring": null, "chunk_size_bytes": 134, "original_size_bytes": 134, "start_byte": 1280, "end_byte": 1414}
{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:adc7920374f6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "xyzRxyz_to_H", "qualified_name": "xyzRxyz_to_H", "source_path": "utilities/MathAddonFunctions.py", "loc": [48, 53], "text": "def xyzRxyz_to_H(pose):\n    '''\n    Function to calculate the Pose Transformation Matrix for a given (x,y,z,rx,ry,rz)\n    ***Uses Euler Angle notation***\n    '''\n    return Mat(pose).H()", "hash": "adc7920374f6", "chunk_type": "function", "node_type": "function_definition", "signature": "xyzRxyz_to_H(pose)", "docstring": "Function to calculate the Pose Transformation Matrix for a given (x,y,z,rx,ry,rz)\n    ***Uses Euler Angle notation***", "chunk_size_bytes": 186, "original_size_bytes": 186, "start_byte": 1417, "end_byte": 1603}
{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:a249e2d54c75", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "H_to_xyzRxyz", "qualified_name": "H_to_xyzRxyz", "source_path": "utilities/MathAddonFunctions.py", "loc": [55, 77], "text": "def H_to_xyzRxyz(Pose_Mat):\n    '''\n    Function to calculate the (x,y,z,rx,ry,rz) from the Pose Transormation Matrix.\n    ***Uses Euler Angle notation***\n    '''\n    if abs(Pose_Mat[0,2]) == 1:\n        ry = Pose_Mat[0,2]*90\n        rz_rad = np.arctan2(Pose_Mat[1,0],Pose_Mat[1,1])\n        rz = np.rad2deg(rz_rad)\n        rx = 0\n    else:\n        ry_rad = np.arcsin(Pose_Mat[0,2])\n        ry = np.rad2deg(ry_rad)\n        rz_rad = np.arctan2(-Pose_Mat[0,1],Pose_Mat[0,0])\n        rz = np.rad2deg(rz_rad)\n        rx_rad = np.arctan2(-Pose_Mat[1,2],Pose_Mat[2,2])\n        rx = np.rad2deg(rx_rad)\n    return (Pose_Mat[0,3],Pose_Mat[1,3],Pose_Mat[2,3],rx,ry,rz)", "hash": "a249e2d54c75", "chunk_type": "function", "node_type": "function_definition", "signature": "H_to_xyzRxyz(Pose_Mat)", "docstring": "Function to calculate the (x,y,z,rx,ry,rz) from the Pose Transormation Matrix.\n    ***Uses Euler Angle notation***", "chunk_size_bytes": 656, "original_size_bytes": 661, "start_byte": 1605, "end_byte": 2266}
{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:7abfded48f40", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "CalcWRFChild", "qualified_name": "CalcWRFChild", "source_path": "utilities/MathAddonFunctions.py", "loc": [80, 92], "text": "def CalcWRFChild(WRF_Parent, WRF_Child):\n    '''\n    Function to calculate the WRF of a child reference frame with respect to BRF of Meca500\n    Takes the parent WRF and child WRF values and returns the WRF of child with respect to BRF of Meca500\n    Parent Frame: Reference frame defined with respect to BRF of Meca500\n    Child Frame: Reference frame defined with respect to Parent Frame\n    '''\n    Pose_Parent = xyzRxyz_to_H(WRF_Parent)\n    Pose_Child = xyzRxyz_to_H(WRF_Child)\n    Pose_Child_Parent = Pose_Parent.dot(Pose_Child)\n    return str(H_to_xyzRxyz(Pose_Child_Parent))", "hash": "7abfded48f40", "chunk_type": "function", "node_type": "function_definition", "signature": "CalcWRFChild(WRF_Parent, WRF_Child)", "docstring": "Function to calculate the WRF of a child reference frame with respect to BRF of Meca500\n    Takes the parent WRF and child WRF values and returns the WRF of child with respect to BRF of Meca500\n    Parent Frame: Reference frame defined with respect to BRF of Meca500\n    Child Frame: Reference frame defined with respect to Parent Frame", "chunk_size_bytes": 581, "original_size_bytes": 583, "start_byte": 2277, "end_byte": 2860}
{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:c1b6c7d5b25e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "CalcWRF", "qualified_name": "CalcWRF", "source_path": "utilities/MathAddonFunctions.py", "loc": [95, 156], "text": "def CalcWRF(p1,p2,p3):\n    '''\n    Function to calculate the WRF with respect to BRF of Meca500 using 3 points\n    P1 is at Origin of the reference frame\n    P2 is a point on the +X axis of the reference frame\n    P3 is a point on the +XY plane of the reference frame\n    '''\n    p1p2 = True\n    p1p3 = True\n    ux = [p2[0]-p1[0],p2[1]-p1[1],p2[2]-p1[2]] \n    norm_ux = LA.norm(ux)\n    if norm_ux < 10:\n        print(\" P1 and P2 are too close to each other\")\n        p1p2 = False\n    else:\n        uvx = ux / norm_ux # Unit Vector along X\n    if p1p2:\n        v13 = [p3[0]-p1[0],p3[1]-p1[1],p3[2]-p1[2]] \n        norm_v13 = LA.norm(v13)\n        if norm_v13 < 10:\n            print(\" P3 and P1 are too close to each other\")\n            p1p3 = False\n        else:\n            uv13 = v13 / norm_v13\n    if p1p2 and p1p3:\n        uz = np.cross(uvx,uv13)\n        norm_uz = LA.norm(uz)\n        uvz = uz / norm_uz # Unit Vector along Z\n        uvy = np.cross(uvz,uvx) # Unit Vector along Y\n        if abs(uvz[0]) == 1:\n            beta_deg = uvz[0]*90\n            gamma = np.arctan2(uvy[0],uvx[0])\n            gamma_deg = np.rad2deg(gamma)\n            alpha_deg = 0\n        else:\n            beta = np.arcsin(uvz[0])\n            beta_deg = np.rad2deg(beta)\n            gamma = np.arctan2(-uvy[0],uvx[0])\n            gamma_deg = np.rad2deg(gamma)\n            alpha = np.arctan2(-uvz[1],uvz[2])\n            alpha_deg = np.rad2deg(alpha)\n        result = [p1[0],p1[1],p1[2],alpha_deg,beta_deg,gamma_deg]\n    else:\n        result= []\n    return result", "hash": "c1b6c7d5b25e", "chunk_type": "function", "node_type": "function_definition", "signature": "CalcWRF(p1,p2,p3)", "docstring": "Function to calculate the WRF with respect to BRF of Meca500 using 3 points\n    P1 is at Origin of the reference frame\n    P2 is a point on the +X axis of the reference frame\n    P3 is a point on the +XY plane of the reference frame", "chunk_size_bytes": 1540, "original_size_bytes": 1733, "start_byte": 2863, "end_byte": 4596}
{"chunk_id": "meca_samples:utilities/MathAddonFunctions.py:2662ab9ec2ac", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "CalcTCP", "qualified_name": "CalcTCP", "source_path": "utilities/MathAddonFunctions.py", "loc": [158, 188], "text": "def CalcTCP(nPoses):\n    '''\n    Function to calculate the TCP (X,Y,Z) from 4 or more poses\n    Takes a list of Poses as input and returns the TCP \n        TCP(x,y,z) = [(R_Transpose.R)^-1].R_Transpose.p\n    '''\n    R = np.empty((0,3))\n    p = np.empty((0,1))\n    nPoseMat = []\n    for pose in nPoses:\n        nPoseMat.append(Mat(pose))\n    for i in range(len(nPoses)):\n        if i < len(nPoses)-1:\n            R = np.append(R, np.array([[nPoseMat[i].r11 - nPoseMat[i+1].r11, nPoseMat[i].r12 - nPoseMat[i+1].r12, nPoseMat[i].r13 - nPoseMat[i+1].r13],[nPoseMat[i].r21 - nPoseMat[i+1].r21, nPoseMat[i].r22 - nPoseMat[i+1].r22, nPoseMat[i].r23 - nPoseMat[i+1].r23],[nPoseMat[i].r31 - nPoseMat[i+1].r31, nPoseMat[i].r32 - nPoseMat[i+1].r32, nPoseMat[i].r33 - nPoseMat[i+1].r33]]),axis = 0)\n            p = np.append(p,np.array([[-nPoseMat[i].x + nPoseMat[i+1].x],[-nPoseMat[i].y + nPoseMat[i+1].y],[-nPoseMat[i].z + nPoseMat[i+1].z]]),axis = 0)\n        elif i == len(nPoses)-1:\n            R = np.append(R, np.array([[nPoseMat[i].r11 - nPoseMat[0].r11, nPoseMat[i].r12 - nPoseMat[0].r12, nPoseMat[i].r13 - nPoseMat[0].r13],[nPoseMat[i].r21 - nPoseMat[0].r21, nPoseMat[i].r22 - nPoseMat[0].r22, nPoseMat[i].r23 - nPoseMat[0].r23],[nPoseMat[i].r31 - nPoseMat[0].r31, nPoseMat[i].r32 - nPoseMat[0].r32, nPoseMat[i].r33 - nPoseMat[0].r33]]),axis = 0)\n            p = np.append(p,np.array([[-nPoseMat[i].x + nPoseMat[0].x],[-nPoseMat[i].y + nPoseMat[0].y],[-nPoseMat[i].z + nPoseMat[0].z]]),axis = 0)\n    TCP = (LA.inv(R.transpose().dot(R))).dot(R.transpose()).dot(p)\n    return TCP", "hash": "2662ab9ec2ac", "chunk_type": "function", "node_type": "function_definition", "signature": "CalcTCP(nPoses)", "docstring": "Function to calculate the TCP (X,Y,Z) from 4 or more poses\n    Takes a list of Poses as input and returns the TCP \n    \n        TCP(x,y,z) = [(R_Transpose.R)^-1].R_Transpose.p", "chunk_size_bytes": 1574, "original_size_bytes": 1673, "start_byte": 4606, "end_byte": 6279}
