{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:9dd43cb332f7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "copy", "qualified_name": "copy", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [6, 6], "text": "import copy", "hash": "9dd43cb332f7", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 11, "original_size_bytes": 11, "start_byte": 138, "end_byte": 149}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:36e534a3ad48", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Callable", "qualified_name": "Callable", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [7, 7], "text": "from typing import Callable, Optional, Union", "hash": "36e534a3ad48", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 44, "original_size_bytes": 44, "start_byte": 150, "end_byte": 194}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:1c0e6703332e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unknown", "qualified_name": "unknown", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [10, 10], "text": "from mecademicpy.mx_robot_def import *", "hash": "1c0e6703332e", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 38, "original_size_bytes": 38, "start_byte": 252, "end_byte": 290}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:abc5a7ed14d9", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "NotFoundException", "qualified_name": "NotFoundException", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [11, 11], "text": "from mecademicpy.robot_classes import NotFoundException", "hash": "abc5a7ed14d9", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 55, "original_size_bytes": 55, "start_byte": 291, "end_byte": 346}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:ec8c9805cdc1", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SidecarScriptType", "qualified_name": "SidecarScriptType", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [14, 16], "text": "class SidecarScriptType(IntEnum):\n    MXPY = 0  # Simplified .mxpy script\n    PY = 1  # Complete python file (.py)", "hash": "ec8c9805cdc1", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": null, "chunk_size_bytes": 114, "original_size_bytes": 114, "start_byte": 349, "end_byte": 463}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:f8cd8d6fb09c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "RegisteredFunctionType", "qualified_name": "RegisteredFunctionType", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [19, 22], "text": "class RegisteredFunctionType(IntEnum):\n    NON_BLOCKING = 0  # Non-blocking script that quickly pushes robot instructions and terminates\n    BLOCKING_NON_EXCLUSIVE = 1  # Blocking script, non-exclusive (API commands are postponed while it runs)\n    BLOCKING_EXCLUSIVE = 1  # Blocking script, exclusive (API commands are refused while it runs)", "hash": "f8cd8d6fb09c", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": null, "chunk_size_bytes": 342, "original_size_bytes": 342, "start_byte": 466, "end_byte": 808}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:d928a2e0aadc", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "RegisteredArg", "qualified_name": "RegisteredArg", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [25, 108], "text": "class RegisteredArg:\n    \"\"\" Class that describes one argument for RegisteredFunction \"\"\"\n    def __init__(\n        self,\n        name: str,\n        description: str = \"\",\n        type: MxArgType = MxArgType.MX_ARG_TYPE_ANY,\n        length: Optional[int] = None,\n        units: Optional[MxArgUnit] = None,\n        default: Optional[any] = None,\n        min: Optional[any] = None,\n        max: Optional[any] = None,\n    ):\n        \"\"\" Mandatory constructor for this object", "hash": "d928a2e0aadc", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "Class that describes one argument for RegisteredFunction", "chunk_size_bytes": 471, "original_size_bytes": 515, "start_byte": 811, "end_byte": 4569}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:c7b8a61314b4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "RegisteredArg.__init__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [28, 59], "text": "def __init__(\n        self,\n        name: str,\n        description: str = \"\",\n        type: MxArgType = MxArgType.MX_ARG_TYPE_ANY,\n        length: Optional[int] = None,\n        units: Optional[MxArgUnit] = None,\n        default: Optional[any] = None,\n        min: Optional[any] = None,\n        max: Optional[any] = None,\n    ):\n        \"\"\" Mandatory constructor for this object\n        Args:\n            name (str): Name of this argument/variable\n            description (str, optional): Description of this argument for the users. Defaults to \"\".\n            type (MxArgType, optional): Type of this argument. Defaults to MxArgType.MX_ARG_TYPE_ANY.\n            length (Optional[int], optional): Length of this array (0 if single argument, not array). Defaults to None.\n            units (Optional[MxArgUnit], optional): Units of this argument (for documentation only). Defaults to None.\n            default (Optional[any], optional): Default value for this argument (for documentation). Defaults to None.\n            min (Optional[any], optional): Minimum value of this argument (for documentation only). Defaults to None.\n            max (Optional[any], optional): Maximum value of this argument (for documentation only). Defaults to None.\n        \"\"\"\n        self.name = name\n        self.description = description\n        self.type = type\n        self.length = length\n        self.units = units\n        self.default = default\n        self.min = min\n        self.max = max", "hash": "c7b8a61314b4", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(\n        self,\n        name: str,\n        description: str = \"\",\n        #pylint: disable=redefined-builtin\n        type: MxArgType = MxArgType.MX_ARG_TYPE_ANY,\n        length: Optional[int] = None,\n        units: Optional[MxArgUnit] = None,\n        default: Optional[any] = None,\n        min: Optional[any] = None,\n        max: Optional[any] = None,\n    )", "docstring": "Mandatory constructor for this object\n\n        Args:\n            name (str): Name of this argument/variable\n            description (str, optional): Description of this argument for the users. Defaults to \"\".\n            type (MxArgType, optional): Type of this argument. Defaults to MxArgType.MX_ARG_TYPE_ANY.\n            length (Optional[int], optional): Length of this array (0 if single argument, not array). Defaults to None.\n            units (Optional[MxArgUnit], optional): Units of this argument (for documentation only). Defaults to None.\n            default (Optional[any], optional): Default value for this argument (for documentation). Defaults to None.\n            min (Optional[any], optional): Minimum value of this argument (for documentation only). Defaults to None.\n            max (Optional[any], optional): Maximum value of this argument (for documentation only). Defaults to None.", "chunk_size_bytes": 1475, "original_size_bytes": 1519, "start_byte": 906, "end_byte": 2425}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:a61cca82c171", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__str__", "qualified_name": "RegisteredArg.__str__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [61, 63], "text": "def __str__(self) -> str:\n        \"\"\" Returns string representation \"\"\"\n        return self.name", "hash": "a61cca82c171", "chunk_type": "method", "node_type": "function_definition", "signature": "__str__(self)", "docstring": "Returns string representation", "chunk_size_bytes": 96, "original_size_bytes": 96, "start_byte": 2431, "end_byte": 2527}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:078c4bf4772a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__repr__", "qualified_name": "RegisteredArg.__repr__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [65, 66], "text": "def __repr__(self) -> str:\n        return str(self)", "hash": "078c4bf4772a", "chunk_type": "method", "node_type": "function_definition", "signature": "__repr__(self)", "docstring": null, "chunk_size_bytes": 51, "original_size_bytes": 51, "start_byte": 2533, "end_byte": 2584}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:c6f0b0cfbbd2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "to_dict", "qualified_name": "RegisteredArg.to_dict", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [68, 79], "text": "def to_dict(self) -> str:\n        \"\"\" Returns a dictionary string representation of this object, ready to be serialized as JSON for the robot\"\"\"\n        return {\n            MX_JSON_KEY_VAR_NAME: self.name,\n            MX_JSON_KEY_VAR_DESC: self.description,\n            MX_JSON_KEY_VAR_TYPE: int(self.type),\n            MX_JSON_KEY_VAR_ARR_LEN: self.length,\n            MX_JSON_KEY_VAR_UNIT: int(self.units) if self.units else int(MxArgUnit.MX_UNIT_NONE),\n            MX_JSON_KEY_VAR_DEFVAL: self.default,\n            MX_JSON_KEY_VAR_MIN: self.min,\n            MX_JSON_KEY_VAR_MAX: self.max,\n        }", "hash": "c6f0b0cfbbd2", "chunk_type": "method", "node_type": "function_definition", "signature": "to_dict(self)", "docstring": "Returns a dictionary string representation of this object, ready to be serialized as JSON for the robot", "chunk_size_bytes": 602, "original_size_bytes": 602, "start_byte": 2590, "end_byte": 3192}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:912aba7ef580", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "from_dict", "qualified_name": "RegisteredArg.from_dict", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [82, 93], "text": "def from_dict(cls, arg_def: dict) -> RegisteredArg:\n        \"\"\" Fill this class members from a dictionary (generally parsed from a JSON received from the robot) \"\"\"\n        return RegisteredArg(\n            name=str(arg_def.get(MX_JSON_KEY_VAR_NAME, \"\")),\n            description=str(arg_def.get(MX_JSON_KEY_VAR_DESC, \"\")),\n            type=RegisteredArg._parse_type(arg_def.get(MX_JSON_KEY_VAR_TYPE, int(MxArgType.MX_ARG_TYPE_ANY))),\n            length=arg_def.get(MX_JSON_KEY_VAR_ARR_LEN, None),\n            units=arg_def.get(MX_JSON_KEY_VAR_UNIT, None),\n            default=arg_def.get(MX_JSON_KEY_VAR_DEFVAL, None),\n            min=arg_def.get(MX_JSON_KEY_VAR_MIN, None),\n            max=arg_def.get(MX_JSON_KEY_VAR_MAX, None),\n        )", "hash": "912aba7ef580", "chunk_type": "method", "node_type": "function_definition", "signature": "from_dict(cls, arg_def: dict)", "docstring": "Fill this class members from a dictionary (generally parsed from a JSON received from the robot)", "chunk_size_bytes": 741, "original_size_bytes": 741, "start_byte": 3215, "end_byte": 3956}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:94153d89d86b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_parse_type", "qualified_name": "RegisteredArg._parse_type", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [97, 108], "text": "def _parse_type(cls, type: Union[str, int]) -> MxArgType:\n        \"\"\" Parse argument type, which can either be enum value (int) or string (from robot command dict) \"\"\"\n        if isinstance(type, int):\n            return MxArgType(type)\n        elif type == \"int32\" or type == \"uint32\":\n            return MxArgType.MX_ARG_TYPE_INTEGER\n        elif type == \"double\":\n            return MxArgType.MX_ARG_TYPE_FLOAT\n        elif type == \"string\":\n            return MxArgType.MX_ARG_TYPE_STRING\n        else:\n            return MxArgType.MX_ARG_TYPE_ANY", "hash": "94153d89d86b", "chunk_type": "method", "node_type": "function_definition", "signature": "_parse_type(cls, type: Union[str, int])", "docstring": "Parse argument type, which can either be enum value (int) or string (from robot command dict)", "chunk_size_bytes": 551, "original_size_bytes": 551, "start_byte": 4018, "end_byte": 4569}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:c4c3074c19c8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "RegisteredFunction", "qualified_name": "RegisteredFunction", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [111, 223], "text": "class RegisteredFunction:\n    \"\"\" Class to store information of a registered function from a user sidecar module \"\"\"\n    def __init__(self,\n                 function: callable,\n                 name: str,\n                 description: str = \"\",\n                 args: Optional[list[RegisteredArg]] = None,\n                 validate_args: bool = True,\n                 tags: Optional[list[str]] = None,\n                 cyclic_id: Optional[int] = None,\n                 script_type=SidecarScriptType.PY,\n                 function_type=RegisteredFunctionType.NON_BLOCKING,\n                 private: bool = False):\n        \"\"\"Constructor for this class", "hash": "c4c3074c19c8", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "Class to store information of a registered function from a user sidecar module", "chunk_size_bytes": 649, "original_size_bytes": 650, "start_byte": 4572, "end_byte": 10838}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:f0221ad16408", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "RegisteredFunction.__init__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [114, 168], "text": "def __init__(self,\n                 function: callable,\n                 name: str,\n                 description: str = \"\",\n                 args: Optional[list[RegisteredArg]] = None,\n                 validate_args: bool = True,\n                 tags: Optional[list[str]] = None,\n                 cyclic_id: Optional[int] = None,\n                 script_type=SidecarScriptType.PY,\n                 function_type=RegisteredFunctionType.NON_BLOCKING,\n                 private: bool = False):\n        \"\"\"Constructor for this class\n        Args:\n            function (callable): Function to register\n            name (str): Name of the function to use in the namespaces (and on the robot's command dictionary)\n            description (str): Short description that will show up in MecaPortal code editor\n            args (Optional[list[any]], optional): Description of arguments for this function.\n                This is used for user help/documentation in the MecaPortal code editor.\n                It can also be used for arguments validation (if validate_args is True) to avoid the function to be\n                called with unexpected/incorrect arguments (the robot will refuse the command, it won't be called).\n                Note that if validate_args is False, the function will receive any passed arguments, whether they\n                correspond or not to args provided here.\n                Defaults to None.\n            validate_args (bool, optional): Validate that the argument match 'args' above before calling this function.\n                The function will not be called if the arguments don't match the description.\n                Defaults to True.\n            tags (Optional[list[str]], optional): Tags that identify which type of robot command this function\n                implements. The tags are used to classify the function in MecaPortal's code editor context menus.\n                Defaults to None.\n            cyclic_id (Optional[int], optional): Optional Id that can be used in cyclic protocols to call this\n                function.\n                Note that, when called from cyclic protocols, the function can normally only receive float arguments,\n                and up to 6 of them.\n                Defaults to None.\n            private (bool, optional): Indicate that this registered function should not be included in robot's commands\n                dictionary. It will thus not be known by the MecaPortal's code editor and not advertize to users\n                (no auto-complete suggestion, not visible in context menus).\n                Defaults to False.\n        \"\"\"\n        self.function: str = function\n        self.module_name: str = \"\"\n        self.name: str = name\n        self.description = description\n        self.tags = tags\n        self.args = args\n        self.validate_args = validate_args\n        self.cyclic_id = cyclic_id\n        self.script_type = script_type\n        self.function_type = function_type\n        self.private = private\n        self.locally_created = True  # Tells if this function is locally created, else received from the robot\n        self.is_override = False  # Tells if this local function is an override of an existing robot function", "hash": "f0221ad16408", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self,\n                 function: callable,\n                 name: str,\n                 description: str = \"\",\n                 args: Optional[list[RegisteredArg]] = None,\n                 validate_args: bool = True,\n                 tags: Optional[list[str]] = None,\n                 cyclic_id: Optional[int] = None,\n                 script_type=SidecarScriptType.PY,\n                 function_type=RegisteredFunctionType.NON_BLOCKING,\n                 private: bool = False)", "docstring": "Constructor for this class\n\n        Args:\n            function (callable): Function to register\n            name (str): Name of the function to use in the namespaces (and on the robot's command dictionary)\n            description (str): Short description that will show up in MecaPortal code editor\n            args (Optional[list[any]], optional): Description of arguments for this function.\n                This is used for user help/documentation in the MecaPortal code editor.\n                It can also be used for arguments validation (if validate_args is True) to avoid the function to be\n                called with unexpected/incorrect arguments (the robot will refuse the command, it won't be called).\n                Note that if validate_args is False, the function will receive any passed arguments, whether they\n                correspond or not to args provided here.\n                Defaults to None.\n            validate_args (bool, optional): Validate that the argument match 'args' above before calling this function.\n                The function will not be called if the arguments don't match the description.\n                Defaults to True.\n            tags (Optional[list[str]], optional): Tags that identify which type of robot command this function\n                implements. The tags are used to classify the function in MecaPortal's code editor context menus.\n                Defaults to None.\n            cyclic_id (Optional[int], optional): Optional Id that can be used in cyclic protocols to call this\n                function.\n                Note that, when called from cyclic protocols, the function can normally only receive float arguments,\n                and up to 6 of them.\n                Defaults to None.\n            private (bool, optional): Indicate that this registered function should not be included in robot's commands\n                dictionary. It will thus not be known by the MecaPortal's code editor and not advertize to users\n                (no auto-complete suggestion, not visible in context menus).\n                Defaults to False.", "chunk_size_bytes": 3212, "original_size_bytes": 3258, "start_byte": 4694, "end_byte": 7952}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:a61cca82c171", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__str__", "qualified_name": "RegisteredFunction.__str__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [170, 172], "text": "def __str__(self) -> str:\n        \"\"\" Returns string representation \"\"\"\n        return self.name", "hash": "a61cca82c171", "chunk_type": "method", "node_type": "function_definition", "signature": "__str__(self)", "docstring": "Returns string representation", "chunk_size_bytes": 96, "original_size_bytes": 96, "start_byte": 7958, "end_byte": 8054}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:078c4bf4772a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__repr__", "qualified_name": "RegisteredFunction.__repr__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [174, 175], "text": "def __repr__(self) -> str:\n        return str(self)", "hash": "078c4bf4772a", "chunk_type": "method", "node_type": "function_definition", "signature": "__repr__(self)", "docstring": null, "chunk_size_bytes": 51, "original_size_bytes": 51, "start_byte": 8060, "end_byte": 8111}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:06ee1e133d8a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "get_full_name", "qualified_name": "RegisteredFunction.get_full_name", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [177, 179], "text": "def get_full_name(self) -> str:\n        \"\"\" Get the full name (i.e.'function:module.name')\"\"\"\n        return f'function:{self.module_name}.{self.name}'", "hash": "06ee1e133d8a", "chunk_type": "method", "node_type": "function_definition", "signature": "get_full_name(self)", "docstring": "Get the full name (i.e.'function:module.name')", "chunk_size_bytes": 151, "original_size_bytes": 151, "start_byte": 8117, "end_byte": 8268}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:8789ae59fb3f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "to_dict", "qualified_name": "RegisteredFunction.to_dict", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [181, 192], "text": "def to_dict(self) -> str:\n        \"\"\" Returns a dictionary string representation of this object, ready to be serialized as JSON for the robot\"\"\"\n        return {\n            MX_JSON_KEY_SIDECAR_FCT_NAME: self.name,\n            MX_JSON_KEY_SIDECAR_FCT_DESC: self.description,\n            MX_JSON_KEY_SIDECAR_FCT_ARGS: [arg.to_dict() for arg in self.args] if self.args else [],\n            MX_JSON_KEY_SIDECAR_FCT_VALIDATE_ARGS: self.validate_args,\n            MX_JSON_KEY_SIDECAR_FCT_TAGS: self.tags,\n            MX_JSON_KEY_SIDECAR_FCT_CYCLIC_ID: self.cyclic_id,\n            MX_JSON_KEY_SIDECAR_FCT_PRIVATE: self.private,\n            MX_JSON_KEY_SIDECAR_FCT_OVERRIDE: self.is_override\n        }", "hash": "8789ae59fb3f", "chunk_type": "method", "node_type": "function_definition", "signature": "to_dict(self)", "docstring": "Returns a dictionary string representation of this object, ready to be serialized as JSON for the robot", "chunk_size_bytes": 694, "original_size_bytes": 694, "start_byte": 8274, "end_byte": 8968}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:f4d106cec5ad", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "from_robot_cmd_def", "qualified_name": "RegisteredFunction.from_robot_cmd_def", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [195, 223], "text": "def from_robot_cmd_def(cls, function: callable, name: str, cmd_def: dict) -> RegisteredFunction:\n        \"\"\"Build a RegisteredFunction object from a command definition received from the robot\n        as a JSON string and parsed as a dictionary passed as argument to this function.\n        This function is called, for example, when receiving a notification from the robot indicating that a sidecar\n        module has registered a new function.\n        Args:\n            function (callable): The function to call if this command is called.\n                                 Typically, this function will send a message to the robot telling to call this\n                                 registered function with the provided arguments)\n            name (str): Name of the function (may include prefixes, like my_module.my_function)\n            cmd_def (dict): Definition of the function (description, tags, arguments, etc.)\n        Returns:\n            RegisteredFunction: The RegisteredFunction object rebuilt from the provided cmd_def dictionary\n        \"\"\"\n        function = RegisteredFunction(\n            function=function,\n            name=name,\n            description=cmd_def.get(MX_JSON_KEY_SIDECAR_FCT_DESC, \"\"),\n            args=[RegisteredArg.from_dict(arg_dict) for arg_dict in cmd_def.get(MX_JSON_KEY_SIDECAR_FCT_ARGS, [])],\n            validate_args=bool(cmd_def.get(MX_JSON_KEY_SIDECAR_FCT_VALIDATE_ARGS, True)),\n            tags=[str(tag) for tag in cmd_def.get(MX_JSON_KEY_SIDECAR_FCT_TAGS, [])],\n            cyclic_id=cmd_def.get(MX_JSON_KEY_SIDECAR_FCT_CYCLIC_ID, None),\n            private=bool(cmd_def.get(MX_JSON_KEY_SIDECAR_FCT_PRIVATE, False)))\n        function.locally_created = False\n        return function", "hash": "f4d106cec5ad", "chunk_type": "method", "node_type": "function_definition", "signature": "from_robot_cmd_def(cls, function: callable, name: str, cmd_def: dict)", "docstring": "Build a RegisteredFunction object from a command definition received from the robot\n        as a JSON string and parsed as a dictionary passed as argument to this function.\n        This function is called, for example, when receiving a notification from the robot indicating that a sidecar\n        module has registered a new function.\n\n        Args:\n            function (callable): The function to call if this command is called.\n                                 Typically, this function will send a message to the robot telling to call this\n                                 registered function with the provided arguments)\n            name (str): Name of the function (may include prefixes, like my_module.my_function)\n            cmd_def (dict): Definition of the function (description, tags, arguments, etc.)\n\n        Returns:\n            RegisteredFunction: The RegisteredFunction object rebuilt from the provided cmd_def dictionary", "chunk_size_bytes": 1732, "original_size_bytes": 1847, "start_byte": 8991, "end_byte": 10838}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:0de9e06aa987", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "RegisteredVariable", "qualified_name": "RegisteredVariable", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [226, 295], "text": "class RegisteredVariable(RegisteredArg):\n    \"\"\" Class to store information of a robot variable registered in the local namespace \"\"\"\n    def __init__(\n            self,\n            name: str,\n            description: str = \"\",\n            type: MxArgType = MxArgType.MX_ARG_TYPE_ANY,\n            length: Optional[int] = None,\n            units: Optional[MxArgUnit] = None,\n            cyclic_id: Optional[int] = None,\n            default: Optional[any] = None,\n            min: Optional[any] = None,\n            max: Optional[any] = None):\n        \"\"\" Constructor for this class", "hash": "0de9e06aa987", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "Class to store information of a robot variable registered in the local namespace", "chunk_size_bytes": 579, "original_size_bytes": 627, "start_byte": 10841, "end_byte": 13294}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:9681e78413c2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "RegisteredVariable.__init__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [229, 250], "text": "def __init__(\n            self,\n            name: str,\n            description: str = \"\",\n            type: MxArgType = MxArgType.MX_ARG_TYPE_ANY,\n            length: Optional[int] = None,\n            units: Optional[MxArgUnit] = None,\n            cyclic_id: Optional[int] = None,\n            default: Optional[any] = None,\n            min: Optional[any] = None,\n            max: Optional[any] = None):\n        \"\"\" Constructor for this class\n        Args:\n            See @ref RegisteredArg for arguments description.\n            This class adds the following arguments to base class:\n            module_name (str): Name of the module that has registered this variable\n        \"\"\"\n        super().__init__(name, description, type, length, units, default, min, max)\n        self.cyclic_id = cyclic_id\n        self._value = default", "hash": "9681e78413c2", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(\n            self,\n            name: str,\n            description: str = \"\",\n            #pylint: disable=redefined-builtin\n            type: MxArgType = MxArgType.MX_ARG_TYPE_ANY,\n            length: Optional[int] = None,\n            units: Optional[MxArgUnit] = None,\n            cyclic_id: Optional[int] = None,\n            default: Optional[any] = None,\n            min: Optional[any] = None,\n            max: Optional[any] = None)", "docstring": "Constructor for this class\n\n        Args:\n            See @ref RegisteredArg for arguments description.\n            This class adds the following arguments to base class:\n            module_name (str): Name of the module that has registered this variable", "chunk_size_bytes": 829, "original_size_bytes": 877, "start_byte": 10980, "end_byte": 11857}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:d4e1a5b939cb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "set_value", "qualified_name": "RegisteredVariable.set_value", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [252, 266], "text": "def set_value(self, value: any) -> any:\n        \"\"\"Set the variable's value. This function will attempt to \"cast\" the value into the expected type.\n        Args:\n            value (any): Value to set\n        Raises:\n            ValueError: Cannot set value (array of incorrect length for example)\n        Returns:\n            any: The previous value of the variable before this function call\n        \"\"\"\n        old_value = self._value\n        self._value = value\n        return old_value", "hash": "d4e1a5b939cb", "chunk_type": "method", "node_type": "function_definition", "signature": "set_value(self, value: any)", "docstring": "Set the variable's value. This function will attempt to \"cast\" the value into the expected type.\n\n        Args:\n            value (any): Value to set\n\n        Raises:\n            ValueError: Cannot set value (array of incorrect length for example)\n\n        Returns:\n            any: The previous value of the variable before this function call", "chunk_size_bytes": 488, "original_size_bytes": 491, "start_byte": 11863, "end_byte": 12354}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:5da84ebee648", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "get_value", "qualified_name": "RegisteredVariable.get_value", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [268, 270], "text": "def get_value(self) -> any:\n        \"\"\" Get the current variable value \"\"\"\n        return self._value", "hash": "5da84ebee648", "chunk_type": "method", "node_type": "function_definition", "signature": "get_value(self)", "docstring": "Get the current variable value", "chunk_size_bytes": 101, "original_size_bytes": 101, "start_byte": 12360, "end_byte": 12461}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:7a64c9ec6fdf", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "cast_value", "qualified_name": "RegisteredVariable.cast_value", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [273, 282], "text": "def cast_value(self, value: any):\n        \"\"\" Cast a value into the expected type for this variable \"\"\"\n        if self.type == MxArgType.MX_ARG_TYPE_INTEGER:\n            return int(value)\n        elif self.type == MxArgType.MX_ARG_TYPE_FLOAT:\n            return float(value)\n        elif self.type == MxArgType.MX_ARG_TYPE_STRING:\n            return str(value)\n        else:\n            return value", "hash": "7a64c9ec6fdf", "chunk_type": "method", "node_type": "function_definition", "signature": "cast_value(self, value: any)", "docstring": "Cast a value into the expected type for this variable", "chunk_size_bytes": 400, "original_size_bytes": 400, "start_byte": 12501, "end_byte": 12901}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:b136b874ad36", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__str__", "qualified_name": "RegisteredVariable.__str__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [284, 292], "text": "def __str__(self) -> str:\n        \"\"\" Returns string representation \"\"\"\n        if self.length is None:\n            return f'{self._value}'\n        else:\n            if isinstance(self._value, list):\n                return f'[{\", \".join([str(x) for x in self._value])}]'\n            else:\n                return f'[{self._value}]'", "hash": "b136b874ad36", "chunk_type": "method", "node_type": "function_definition", "signature": "__str__(self)", "docstring": "Returns string representation", "chunk_size_bytes": 330, "original_size_bytes": 330, "start_byte": 12907, "end_byte": 13237}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:078c4bf4772a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__repr__", "qualified_name": "RegisteredVariable.__repr__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [294, 295], "text": "def __repr__(self) -> str:\n        return str(self)", "hash": "078c4bf4772a", "chunk_type": "method", "node_type": "function_definition", "signature": "__repr__(self)", "docstring": null, "chunk_size_bytes": 51, "original_size_bytes": 51, "start_byte": 13243, "end_byte": 13294}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:04a756b844ff", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "AttributeName", "qualified_name": "AttributeName", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [298, 303], "text": "class AttributeName:\n    \"\"\" This class is a simple container that is used by AttributeContainer to store the full name (with prefixes)\n        of a registered attribute \"\"\"", "hash": "04a756b844ff", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "This class is a simple container that is used by AttributeContainer to store the full name (with prefixes)\n        of a registered attribute", "chunk_size_bytes": 173, "original_size_bytes": 173, "start_byte": 13297, "end_byte": 13531}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:088c37b103af", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "AttributeName.__init__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [302, 303], "text": "def __init__(self, name: str):\n        self.name = name", "hash": "088c37b103af", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self, name: str)", "docstring": null, "chunk_size_bytes": 55, "original_size_bytes": 55, "start_byte": 13476, "end_byte": 13531}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:0e366a1e5e2b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "AttributeContainer", "qualified_name": "AttributeContainer", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [306, 524], "text": "class AttributeContainer:\n    \"\"\" This class is used to recursively store attributes (variables or functions) by path into object and sub-object,\n    allowing code to later access attributes with code like:\n        Calling a registered function:\n            robot.my_module.my_sub_module.my_function(my_args)\n        Read or write a registered variable\n            robot.my_group.my_subgroup.my_variable += 2\n            print(f'robot.my_group.my_subgroup.my_variable')\n    This class supports saving the attributes in a local dictionary, or else using callback functions at run-time\n    to get/set registered attribute values dynamically (without actually storing the values in this class instance).\n    \"\"\"", "hash": "0e366a1e5e2b", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "This class is used to recursively store attributes (variables or functions) by path into object and sub-object,\n    allowing code to later access attributes with code like:\n        Calling a registered function:\n            robot.my_module.my_sub_module.my_function(my_args)\n        Read or write a registered variable\n            robot.my_group.my_subgroup.my_variable += 2\n            print(f'robot.my_group.my_subgroup.my_variable')\n\n    This class supports saving the attributes in a local dictionary, or else using callback functions at run-time\n    to get/set registered attribute values dynamically (without actually storing the values in this class instance).", "chunk_size_bytes": 708, "original_size_bytes": 709, "start_byte": 13534, "end_byte": 24967}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:4fd95dc29c79", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "AttributeContainer.__init__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [319, 323], "text": "def __init__(self):\n        self._get_attribute_callback: callable = None\n        self._set_attribute_callback: callable = None\n        self._attributes: dict[str, Union[str, AttributeContainer]] = {}", "hash": "4fd95dc29c79", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self)", "docstring": null, "chunk_size_bytes": 200, "original_size_bytes": 238, "start_byte": 14249, "end_byte": 14487}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:a6468c8e671e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "attach", "qualified_name": "AttributeContainer.attach", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [325, 336], "text": "def attach(self, get_attribute_callback: Callable[[str]], set_attribute_callback: Callable[[str, any]]):\n        \"\"\"Attach the callback functions that will be used to actually get and set the attributes when this\n            class is accessed\n        Args:\n            get_attribute_callback (callable): Function to call (with attribute full name as argument) to retrieve an\n                                               attribute that was registered in this container.\n            set_attribute_callback (callable): Function to call (with attribute full name as argument and value) to\n                                               change the value of an attribute that was registered in this container.\n        \"\"\"\n        self._get_attribute_callback = get_attribute_callback\n        self._set_attribute_callback = set_attribute_callback", "hash": "a6468c8e671e", "chunk_type": "method", "node_type": "function_definition", "signature": "attach(self, get_attribute_callback: Callable[[str]], set_attribute_callback: Callable[[str, any]])", "docstring": "Attach the callback functions that will be used to actually get and set the attributes when this\n            class is accessed\n\n        Args:\n            get_attribute_callback (callable): Function to call (with attribute full name as argument) to retrieve an\n                                               attribute that was registered in this container.\n            set_attribute_callback (callable): Function to call (with attribute full name as argument and value) to\n                                               change the value of an attribute that was registered in this container.", "chunk_size_bytes": 841, "original_size_bytes": 842, "start_byte": 14493, "end_byte": 15335}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:c077e3a4e354", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "detach", "qualified_name": "AttributeContainer.detach", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [338, 341], "text": "def detach(self):\n        \"\"\" Detach previously attached get/set callbacks \"\"\"\n        self._get_attribute_callback = None\n        self._set_attribute_callback = None", "hash": "c077e3a4e354", "chunk_type": "method", "node_type": "function_definition", "signature": "detach(self)", "docstring": "Detach previously attached get/set callbacks", "chunk_size_bytes": 166, "original_size_bytes": 166, "start_byte": 15341, "end_byte": 15507}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:8321cfdde932", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "register_attribute", "qualified_name": "AttributeContainer.register_attribute", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [343, 365], "text": "def register_attribute(self, attribute_name: str, attribute_full_name: str, attribute: Optional[any] = None):\n        \"\"\"Register one attribute into this attribute container (recursively)\n        Args:\n            attribute_name (str): Name of the attribute to register (partial for nested instances of this class)\n            attribute_full_name (str): Full attribute name (no prefix removal even when we're a nested instance)\n            attribute(any): Optional attribute value to register. If None, then self._get_attribute_callback will\n                            be used to retrieve the attribute\n        \"\"\"\n        if '.' in attribute_name:\n            prefix, sub_name = attribute_name.split('.', 1)\n            if prefix not in self._attributes:\n                self._attributes[prefix] = self.__class__()  # This should create AttributeContainer, or derived class\n                self._attributes[prefix].attach(self._get_attribute_callback, self._set_attribute_callback)\n            self._attributes[prefix].register_attribute(sub_name, attribute_full_name, attribute)\n        else:\n            if attribute is None:\n                self._attributes[attribute_name] = AttributeName(attribute_full_name)\n            else:\n                self._attributes[attribute_name] = attribute", "hash": "8321cfdde932", "chunk_type": "method", "node_type": "function_definition", "signature": "register_attribute(self, attribute_name: str, attribute_full_name: str, attribute: Optional[any] = None)", "docstring": "Register one attribute into this attribute container (recursively)\n\n        Args:\n            attribute_name (str): Name of the attribute to register (partial for nested instances of this class)\n            attribute_full_name (str): Full attribute name (no prefix removal even when we're a nested instance)\n            attribute(any): Optional attribute value to register. If None, then self._get_attribute_callback will\n                            be used to retrieve the attribute", "chunk_size_bytes": 1294, "original_size_bytes": 1501, "start_byte": 15513, "end_byte": 17014}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:2c0b0ddc05b5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unregister_attribute", "qualified_name": "AttributeContainer.unregister_attribute", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [367, 386], "text": "def unregister_attribute(self, attribute_name: str):\n        \"\"\"Unregister a previously registered attribute\n        Args:\n            attribute_name (str): The name of the attribute to unregister from this container\n        \"\"\"\n        if '.' in attribute_name:\n            prefix, sub_name = attribute_name.split('.', 1)\n            if prefix in self._attributes:\n                if isinstance(self._attributes[prefix], AttributeContainer):\n                    self._attributes[prefix].unregister_attribute(sub_name)\n                    if self._attributes[prefix].empty():\n                        del self._attributes[prefix]\n                else:\n                    del self._attributes[prefix]\n        else:\n            if attribute_name in self._attributes:\n                del self._attributes[attribute_name]", "hash": "2c0b0ddc05b5", "chunk_type": "method", "node_type": "function_definition", "signature": "unregister_attribute(self, attribute_name: str)", "docstring": "Unregister a previously registered attribute\n\n        Args:\n            attribute_name (str): The name of the attribute to unregister from this container", "chunk_size_bytes": 817, "original_size_bytes": 934, "start_byte": 17020, "end_byte": 17954}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:ec61839e3ec8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "get", "qualified_name": "AttributeContainer.get", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [388, 410], "text": "def get(self, attribute_name: str) -> Optional[any]:\n        \"\"\"Get the specified attribute by name, or return None if not found.\n           This is similar to accessing the container attribute directly (ex: container.my_attr) except that:\n           - here we use a recursive string to identify the attribute (attr_name.sub_name...)\n           - Here we return None if the attribute is not found instead of raising an exception.\n        Args:\n            attribute_name (str): Name of the attribute to get (including prefixes if appropriate)\n        Returns:\n            The found attribute value or None\n        \"\"\"\n        if '.' in attribute_name:\n            prefix, sub_name = attribute_name.split('.', 1)\n            if prefix not in self._attributes:\n                return None\n            return self._attributes[prefix].get(sub_name)\n        else:\n            if attribute_name not in self._attributes:\n                return None\n            return getattr(self, attribute_name)", "hash": "ec61839e3ec8", "chunk_type": "method", "node_type": "function_definition", "signature": "get(self, attribute_name: str)", "docstring": "Get the specified attribute by name, or return None if not found.\n           This is similar to accessing the container attribute directly (ex: container.my_attr) except that:\n           - here we use a recursive string to identify the attribute (attr_name.sub_name...)\n           - Here we return None if the attribute is not found instead of raising an exception.\n\n        Args:\n            attribute_name (str): Name of the attribute to get (including prefixes if appropriate)\n\n        Returns:\n            The found attribute value or None", "chunk_size_bytes": 990, "original_size_bytes": 1108, "start_byte": 17960, "end_byte": 19068}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:6c9b57f2f240", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "set", "qualified_name": "AttributeContainer.set", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [412, 442], "text": "def set(self, attribute_name: str, value: any) -> Optional[any]:\n        \"\"\"Set the specified attribute by name, or raise NotFoundException if not found.\n           This is similar to accessing the container attribute directly (ex: container.my_attr=...) except that\n           here we use a recursive string to identify the attribute (attr_name.sub_name...)\n        Args:\n            attribute_name (str):   Name of the attribute to get (including prefixes if appropriate)\n            value (any):            The new value to set for this attribute\n        Raises:\n            NotFoundException: The variable with specified name does not exist\n        Returns:\n            Optional[any]: The previous variable value.\n            Note that if the function returns None, it means that the variable existed and had a value None\n            (if the variable does not exist, this function raises NotFoundException)\n        \"\"\"\n        if '.' in attribute_name:\n            prefix, sub_name = attribute_name.split('.', 1)\n            if prefix not in self._attributes:\n                raise NotFoundException(f'Cannot set {attribute_name}, does not exist')\n            return self._attributes[prefix].set(sub_name, value)\n        else:\n            if attribute_name not in self._attributes:\n                raise NotFoundException(f'Cannot set {attribute_name}, does not exist')\n            prev_val = copy.deepcopy(getattr(self, attribute_name))\n            setattr(self, attribute_name, value)\n            return prev_val", "hash": "6c9b57f2f240", "chunk_type": "method", "node_type": "function_definition", "signature": "set(self, attribute_name: str, value: any)", "docstring": "Set the specified attribute by name, or raise NotFoundException if not found.\n           This is similar to accessing the container attribute directly (ex: container.my_attr=...) except that\n           here we use a recursive string to identify the attribute (attr_name.sub_name...)\n\n        Args:\n            attribute_name (str):   Name of the attribute to get (including prefixes if appropriate)\n            value (any):            The new value to set for this attribute\n\n        Raises:\n            NotFoundException: The variable with specified name does not exist\n\n        Returns:\n            Optional[any]: The previous variable value.\n            Note that if the function returns None, it means that the variable existed and had a value None\n            (if the variable does not exist, this function raises NotFoundException)", "chunk_size_bytes": 1518, "original_size_bytes": 1638, "start_byte": 19074, "end_byte": 20712}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:a9652be57b75", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "empty", "qualified_name": "AttributeContainer.empty", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [444, 446], "text": "def empty(self) -> bool:\n        \"\"\" Tells if there are attributes or sub-groups in this instance \"\"\"\n        return len(self._attributes) == 0", "hash": "a9652be57b75", "chunk_type": "method", "node_type": "function_definition", "signature": "empty(self)", "docstring": "Tells if there are attributes or sub-groups in this instance", "chunk_size_bytes": 143, "original_size_bytes": 143, "start_byte": 20718, "end_byte": 20861}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:a3c79afe4bfa", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__getattr__", "qualified_name": "AttributeContainer.__getattr__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [448, 486], "text": "def __getattr__(self, attr_name: str) -> any:\n        \"\"\"We override this to provide access to registered attributes as class attributes\n        Args:\n            attr_name (str): The name of the attribute to get (no prefix, attribute name only)\n        Raises:\n            AttributeError: No attribute is registered with this name\n            ModuleNotFoundError: No callback function attached, cannot retrieve the attribute value from parent module\n        Returns:\n            any: The retrieved attribute value\n        \"\"\"\n        if attr_name == \"_get_attribute_callback\":\n            return self._get_attribute_callback\n        if attr_name == \"_set_attribute_callback\":\n            return self._set_attribute_callback\n        if attr_name == \"_attributes\":\n            return self._attributes\n        if attr_name not in self._attributes:\n            raise AttributeError(f'Trying to get non-registered attribute {attr_name}')\n        if isinstance(self._attributes[attr_name], AttributeContainer):\n            return self._attributes[attr_name]\n        if isinstance(self._attributes[attr_name], AttributeName):\n            if self._get_attribute_callback is None:\n                raise ModuleNotFoundError(f'Attributes container has not been attached to get/set callbacks')\n            attribute_full_name: str = self._attributes[attr_name].name\n            return self._get_attribute_callback(attribute_full_name)\n        else:\n            return self._attributes[attr_name]", "hash": "a3c79afe4bfa", "chunk_type": "method", "node_type": "function_definition", "signature": "__getattr__(self, attr_name: str)", "docstring": "We override this to provide access to registered attributes as class attributes\n\n        Args:\n            attr_name (str): The name of the attribute to get (no prefix, attribute name only)\n\n        Raises:\n            AttributeError: No attribute is registered with this name\n            ModuleNotFoundError: No callback function attached, cannot retrieve the attribute value from parent module\n\n        Returns:\n            any: The retrieved attribute value", "chunk_size_bytes": 1484, "original_size_bytes": 1966, "start_byte": 20867, "end_byte": 22833}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:07b7f7c0f1a7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__setattr__", "qualified_name": "AttributeContainer.__setattr__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [488, 524], "text": "def __setattr__(self, attr_name: str, value=any):\n        \"\"\"We override this to provide access to registered attributes as class attributes\n        Args:\n            attr_name (str): The name of the attribute to set (no prefix, attribute name only)\n            value (_type_, optional): Value to set. Defaults to any.\n        Raises:\n            ValueError: Trying to assign a value into an already registered sub-group\n            AttributeError: No attribute with this name was registered\n            ModuleNotFoundError: No callback function attached, cannot set the attribute value into parent module\n        \"\"\"\n        if (attr_name == \"_get_attribute_callback\" or attr_name == \"_set_attribute_callback\"\n                or attr_name == \"_attributes\" or attr_name == \"_getting_reg_var\"):\n            return super().__setattr__(attr_name, value)\n        if attr_name not in self._attributes:\n            raise AttributeError(f'Trying to set non-registered attribute {attr_name}')\n        if isinstance(self._attributes[attr_name], AttributeContainer):\n            raise ValueError(f'Trying to assign a value to attribute group {attr_name}')\n        if isinstance(self._attributes[attr_name], AttributeName):\n            if self._set_attribute_callback is None:\n                raise ModuleNotFoundError(f'Attributes container has not been attached to get/set callbacks')\n            attribute_full_name: str = self._attributes[attr_name].name\n            return self._set_attribute_callback(attribute_full_name, value)\n        else:\n            self._attributes[attr_name] = value\n            return value", "hash": "07b7f7c0f1a7", "chunk_type": "method", "node_type": "function_definition", "signature": "__setattr__(self, attr_name: str, value=any)", "docstring": "We override this to provide access to registered attributes as class attributes\n\n        Args:\n            attr_name (str): The name of the attribute to set (no prefix, attribute name only)\n            value (_type_, optional): Value to set. Defaults to any.\n\n        Raises:\n            ValueError: Trying to assign a value into an already registered sub-group\n            AttributeError: No attribute with this name was registered\n            ModuleNotFoundError: No callback function attached, cannot set the attribute value into parent module", "chunk_size_bytes": 1610, "original_size_bytes": 2128, "start_byte": 22839, "end_byte": 24967}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:3789690f07ce", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "VariablesContainer", "qualified_name": "VariablesContainer", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [527, 550], "text": "class VariablesContainer(AttributeContainer):\n    \"\"\" This class is a specialization of AttributeContainer used to store variable values \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._getting_reg_var = False\n    def get(self, attribute_name: str) -> Optional[RegisteredVariable]:\n        \"\"\" Returns the RegisteredVariable object by name \"\"\"", "hash": "3789690f07ce", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "This class is a specialization of AttributeContainer used to store variable values", "chunk_size_bytes": 363, "original_size_bytes": 365, "start_byte": 24970, "end_byte": 26079}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:09fa43e1b26f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "VariablesContainer.__init__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [530, 532], "text": "def __init__(self):\n        super().__init__()\n        self._getting_reg_var = False", "hash": "09fa43e1b26f", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self)", "docstring": null, "chunk_size_bytes": 84, "original_size_bytes": 84, "start_byte": 25116, "end_byte": 25200}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:15df4571968f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "get", "qualified_name": "VariablesContainer.get", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [534, 540], "text": "def get(self, attribute_name: str) -> Optional[RegisteredVariable]:\n        \"\"\" Returns the RegisteredVariable object by name \"\"\"\n        self._getting_reg_var = True\n        var = super().get(attribute_name)\n        self._getting_reg_var = False\n        return var", "hash": "15df4571968f", "chunk_type": "method", "node_type": "function_definition", "signature": "get(self, attribute_name: str)", "docstring": "Returns the RegisteredVariable object by name", "chunk_size_bytes": 265, "original_size_bytes": 373, "start_byte": 25206, "end_byte": 25579}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:d4f3bdc2df37", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__getattr__", "qualified_name": "VariablesContainer.__getattr__", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [542, 550], "text": "def __getattr__(self, attr_name: str) -> any:\n        \"\"\" See base class doc. Here we just return the value from the registered variable.\n        This allows code that do robot.vars.myvar  to get the value directly, while robot.vars.get(\"myvar\") returns\n        a RegisteredVariable object\n        \"\"\"\n        reg_var = super().__getattr__(attr_name)\n        if isinstance(reg_var, RegisteredVariable) and not self._getting_reg_var:\n            return reg_var.get_value()\n        return reg_var", "hash": "d4f3bdc2df37", "chunk_type": "method", "node_type": "function_definition", "signature": "__getattr__(self, attr_name: str)", "docstring": "See base class doc. Here we just return the value from the registered variable.\n        This allows code that do robot.vars.myvar  to get the value directly, while robot.vars.get(\"myvar\") returns\n        a RegisteredVariable object", "chunk_size_bytes": 494, "original_size_bytes": 494, "start_byte": 25585, "end_byte": 26079}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:a63d5e5afe06", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ScriptUtils", "qualified_name": "ScriptUtils", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [553, 590], "text": "class ScriptUtils:\n    \"\"\" This class contains utility functions for simplified .mxpy scripts \"\"\"\n    @classmethod\n    def get_arg(cls,\n                args: list[any],\n                kwargs: dict[str, any],\n                index: Optional[int] = None,\n                name: Optional[str] = None,\n                default: Optional[any] = None) -> any:\n        \"\"\"", "hash": "a63d5e5afe06", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "This class contains utility functions for simplified .mxpy scripts", "chunk_size_bytes": 364, "original_size_bytes": 365, "start_byte": 26082, "end_byte": 27590}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:e676929e282b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "get_arg", "qualified_name": "ScriptUtils.get_arg", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [557, 590], "text": "def get_arg(cls,\n                args: list[any],\n                kwargs: dict[str, any],\n                index: Optional[int] = None,\n                name: Optional[str] = None,\n                default: Optional[any] = None) -> any:\n        \"\"\"\n        This is a utility function for user programs, in particular .mxpy programs.\n        They have access to *args and *kwargs, but using 'get_arg' by index and/or keyword is convenient.\n        Gets an argument from *args or **kwargs.\n        This function will first attempt to retrieve the argument by name from kwargs.\n        If not found, will try to retrieve the positional argument (by index) from args.\n        Args:\n            *args: Positional arguments.\n            **kwargs: Keyword arguments.\n            index: Index of the argument to retrieve from *args.\n            name: Name of the argument to retrieve from **kwargs.\n            default: Default value to return if the argument is not found.\n        Returns:\n            The retrieved argument or the default value.\n        \"\"\"\n        if name is not None and name in kwargs:\n            return kwargs.get(name, default)\n        if index is not None and index < len(args):\n            return args[index] if index < len(args) else default\n        return default", "hash": "e676929e282b", "chunk_type": "method", "node_type": "function_definition", "signature": "get_arg(cls,\n                args: list[any],\n                kwargs: dict[str, any],\n                index: Optional[int] = None,\n                name: Optional[str] = None,\n                default: Optional[any] = None)", "docstring": "This is a utility function for user programs, in particular .mxpy programs.\n        They have access to *args and *kwargs, but using 'get_arg' by index and/or keyword is convenient.\n        Gets an argument from *args or **kwargs.\n\n        This function will first attempt to retrieve the argument by name from kwargs.\n        If not found, will try to retrieve the positional argument (by index) from args.\n\n        Args:\n            *args: Positional arguments.\n            **kwargs: Keyword arguments.\n            index: Index of the argument to retrieve from *args.\n            name: Name of the argument to retrieve from **kwargs.\n            default: Default value to return if the argument is not found.\n\n        Returns:\n            The retrieved argument or the default value.", "chunk_size_bytes": 1281, "original_size_bytes": 1388, "start_byte": 26202, "end_byte": 27590}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:e0d42410eeb9", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "register_nested_function", "qualified_name": "register_nested_function", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [593, 620], "text": "def register_nested_function(function_full_name: str, get_parent_attr: Callable[[str]],\n                             set_parent_attr: Callable[[str, any]], function: callable):\n    \"\"\"This is a helper method to register a nested function into a namespace.\n    This function will take care to recursively create intermediate containers in case the function name contains\n    prefixes (like my_group.my_sub_group.my_function)\n    Args:\n        function_full_name (str): Name of the function to register (which may have a prefix)\n        get_parent_attr (Callable[[str]]): Callback function to get by name from the desired namespace\n        set_parent_attr (Callable[[str, any]]): Callback function to set by name into the desired namespace\n        function (callable): The function to register\n    \"\"\"\n    if '.' in function_full_name:\n        prefix, sub_name = function_full_name.split('.', 1)\n        attr_container: AttributeContainer = get_parent_attr(prefix)\n        if attr_container is None:\n            attr_container = AttributeContainer()\n            set_parent_attr(prefix, attr_container)\n        attr_container.register_attribute(sub_name, function_full_name, function)\n    else:\n        set_parent_attr(function_full_name, function)", "hash": "e0d42410eeb9", "chunk_type": "function", "node_type": "function_definition", "signature": "register_nested_function(function_full_name: str, get_parent_attr: Callable[[str]],\n                             set_parent_attr: Callable[[str, any]], function: callable)", "docstring": "This is a helper method to register a nested function into a namespace.\n    This function will take care to recursively create intermediate containers in case the function name contains\n    prefixes (like my_group.my_sub_group.my_function)\n\n    Args:\n        function_full_name (str): Name of the function to register (which may have a prefix)\n        get_parent_attr (Callable[[str]]): Callback function to get by name from the desired namespace\n        set_parent_attr (Callable[[str, any]]): Callback function to set by name into the desired namespace\n        function (callable): The function to register", "chunk_size_bytes": 1245, "original_size_bytes": 1613, "start_byte": 27593, "end_byte": 29206}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/robot_sidecar_classes.py:1f6f6d2662b8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unregister_nested_function", "qualified_name": "unregister_nested_function", "source_path": "mecademicpy/mecademicpy/robot_sidecar_classes.py", "loc": [623, 660], "text": "def unregister_nested_function(function_full_name: str, get_parent_attr: Callable[[str]],\n                               del_parent_attr: Callable[[str]]):\n    \"\"\"This is a helper method to recursively unregister a function from a namespace.\n    Args:\n        function_full_name (str): Name of the attribute to unregister (which may have a prefix)\n        get_parent_attr (Callable[[str]]): Callback function to get by name (or prefix) from the desired namespace\n        del_parent_attr (Callable[[str]]): Callback function to delete by name (or prefix) from the desired namespace\n    \"\"\"\n    if '.' in function_full_name:\n        prefix, sub_name = function_full_name.split('.', 1)\n        attr_container: AttributeContainer = get_parent_attr(prefix)\n        if attr_container is not None:\n            if isinstance(attr_container, AttributeContainer):\n                attr_container.unregister_attribute(sub_name)\n            else:\n                raise ValueError(f'Found attribute {prefix} in parent namespace but it is not an AttributeContainer')\n    else:\n        del_parent_attr(function_full_name)", "hash": "1f6f6d2662b8", "chunk_type": "function", "node_type": "function_definition", "signature": "unregister_nested_function(function_full_name: str, get_parent_attr: Callable[[str]],\n                               del_parent_attr: Callable[[str]])", "docstring": "This is a helper method to recursively unregister a function from a namespace.\n\n    Args:\n        function_full_name (str): Name of the attribute to unregister (which may have a prefix)\n        get_parent_attr (Callable[[str]]): Callback function to get by name (or prefix) from the desired namespace\n        del_parent_attr (Callable[[str]]): Callback function to delete by name (or prefix) from the desired namespace", "chunk_size_bytes": 1105, "original_size_bytes": 2681, "start_byte": 29209, "end_byte": 31890}
