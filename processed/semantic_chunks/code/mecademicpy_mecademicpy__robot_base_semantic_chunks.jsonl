{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:9dd43cb332f7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "copy", "qualified_name": "copy", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [9, 9], "text": "import copy", "hash": "9dd43cb332f7", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 11, "original_size_bytes": 11, "start_byte": 311, "end_byte": 322}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f720cee5b65c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "functools", "qualified_name": "functools", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [10, 10], "text": "import functools", "hash": "f720cee5b65c", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 16, "original_size_bytes": 16, "start_byte": 323, "end_byte": 339}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:412862caa3f7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ipaddress", "qualified_name": "ipaddress", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [11, 11], "text": "import ipaddress", "hash": "412862caa3f7", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 16, "original_size_bytes": 16, "start_byte": 340, "end_byte": 356}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f2f4a1237dbd", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "json", "qualified_name": "json", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [12, 12], "text": "import json", "hash": "f2f4a1237dbd", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 11, "original_size_bytes": 11, "start_byte": 357, "end_byte": 368}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:1e7b9f543d36", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "logging", "qualified_name": "logging", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [13, 13], "text": "import logging", "hash": "1e7b9f543d36", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 14, "original_size_bytes": 14, "start_byte": 369, "end_byte": 383}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8bd3f84ddc47", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "math", "qualified_name": "math", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [14, 14], "text": "import math", "hash": "8bd3f84ddc47", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 11, "original_size_bytes": 11, "start_byte": 384, "end_byte": 395}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:5757795d86dd", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "pathlib", "qualified_name": "pathlib", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [15, 15], "text": "import pathlib", "hash": "5757795d86dd", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 14, "original_size_bytes": 14, "start_byte": 396, "end_byte": 410}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:cd89a6634e6c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "queue", "qualified_name": "queue", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [16, 16], "text": "import queue", "hash": "cd89a6634e6c", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 12, "original_size_bytes": 12, "start_byte": 411, "end_byte": 423}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d11613a5082c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "socket", "qualified_name": "socket", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [17, 17], "text": "import socket", "hash": "d11613a5082c", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 13, "original_size_bytes": 13, "start_byte": 424, "end_byte": 437}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:818111220442", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "threading", "qualified_name": "threading", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [18, 18], "text": "import threading", "hash": "818111220442", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 16, "original_size_bytes": 16, "start_byte": 438, "end_byte": 454}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:e6125c442fc3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "time", "qualified_name": "time", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [19, 19], "text": "import time", "hash": "e6125c442fc3", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 11, "original_size_bytes": 11, "start_byte": 455, "end_byte": 466}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:3268efea0753", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "weakref", "qualified_name": "weakref", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [20, 20], "text": "import weakref", "hash": "3268efea0753", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 14, "original_size_bytes": 14, "start_byte": 467, "end_byte": 481}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:455b1b1b5bab", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ArgumentError", "qualified_name": "ArgumentError", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [21, 21], "text": "from argparse import ArgumentError", "hash": "455b1b1b5bab", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 34, "original_size_bytes": 34, "start_byte": 482, "end_byte": 516}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:39c21d3ad028", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Callable", "qualified_name": "Callable", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [22, 22], "text": "from typing import Callable, Optional, Tuple, Union", "hash": "39c21d3ad028", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 51, "original_size_bytes": 51, "start_byte": 517, "end_byte": 568}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:e142e4ed0314", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "requests", "qualified_name": "requests", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [24, 24], "text": "import requests", "hash": "e142e4ed0314", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 15, "original_size_bytes": 15, "start_byte": 570, "end_byte": 585}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:11b66ba3fb5e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "mecademicpy._robot_trajectory_logger as mx_traj", "qualified_name": "mecademicpy._robot_trajectory_logger as mx_traj", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [26, 26], "text": "import mecademicpy._robot_trajectory_logger as mx_traj", "hash": "11b66ba3fb5e", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 54, "original_size_bytes": 54, "start_byte": 587, "end_byte": 641}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c82777e3b2ec", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "mecademicpy.robot_global_functions as rgf", "qualified_name": "mecademicpy.robot_global_functions as rgf", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [27, 27], "text": "import mecademicpy.robot_global_functions as rgf", "hash": "c82777e3b2ec", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 48, "original_size_bytes": 48, "start_byte": 642, "end_byte": 690}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8e7d871cea3e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "mecademicpy.robot_sidecar_classes as rsc", "qualified_name": "mecademicpy.robot_sidecar_classes as rsc", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [28, 28], "text": "import mecademicpy.robot_sidecar_classes as rsc", "hash": "8e7d871cea3e", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 47, "original_size_bytes": 47, "start_byte": 691, "end_byte": 738}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:9f8c61f17836", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "VariablesContainer", "qualified_name": "VariablesContainer", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [29, 29], "text": "from mecademicpy.robot_sidecar_classes import VariablesContainer", "hash": "9f8c61f17836", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 64, "original_size_bytes": 64, "start_byte": 739, "end_byte": 803}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:e3269ed95593", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "MxRobotStatusCode as mx_st", "qualified_name": "MxRobotStatusCode as mx_st", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [32, 32], "text": "from .mx_robot_def import MxRobotStatusCode as mx_st", "hash": "e3269ed95593", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 52, "original_size_bytes": 52, "start_byte": 875, "end_byte": 927}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f6466ac7b775", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unknown", "qualified_name": "unknown", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [33, 33], "text": "from .mx_robot_def import *", "hash": "f6466ac7b775", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 27, "original_size_bytes": 27, "start_byte": 928, "end_byte": 955}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:9e7a5dc6e16d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unknown", "qualified_name": "unknown", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [34, 34], "text": "from .robot_classes import *", "hash": "9e7a5dc6e16d", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 28, "original_size_bytes": 28, "start_byte": 956, "end_byte": 984}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d801645ecc5e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "RobotTrajectories", "qualified_name": "RobotTrajectories", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [35, 35], "text": "from .robot_trajectory_files import RobotTrajectories", "hash": "d801645ecc5e", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 53, "original_size_bytes": 53, "start_byte": 985, "end_byte": 1038}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:5485e01f3db1", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unknown", "qualified_name": "unknown", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [36, 36], "text": "from .tools import *", "hash": "5485e01f3db1", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 20, "original_size_bytes": 20, "start_byte": 1039, "end_byte": 1059}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:778b0b562a2f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "disconnect_on_exception_decorator", "qualified_name": "disconnect_on_exception_decorator", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [48, 71], "text": "def disconnect_on_exception_decorator(func):\n    \"\"\"Decorator to call disconnect if an exception is raised. Needs to be declared outside of class.\n    Attributes\n    ----------\n    func : function object\n        Function to wrap.\n\"\"\"\n    @functools.wraps(func)\n    def wrap(self, *args, **kwargs):\n        try:\n            return func(self, *args, **kwargs)\n        except BaseException as e:\n            if self._disconnect_on_exception:\n                self._disconnect()\n                raise DisconnectError('Automatically disconnected as a result of exception, '\n                                      'set \\'disconnect_on_exception\\' to False to disable.') from e\n            else:\n                raise e\n    return wrap", "hash": "778b0b562a2f", "chunk_type": "function", "node_type": "function_definition", "signature": "disconnect_on_exception_decorator(func)", "docstring": "Decorator to call disconnect if an exception is raised. Needs to be declared outside of class.\n\n    Attributes\n    ----------\n    func : function object\n        Function to wrap.", "chunk_size_bytes": 726, "original_size_bytes": 825, "start_byte": 1358, "end_byte": 2183}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d767e409cc1c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_RobotEvents", "qualified_name": "_RobotEvents", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [74, 318], "text": "class _RobotEvents:\n    \"\"\"Class for storing possible status events for the Mecademic robot.\n    Attributes\n    ----------\n    on_connected : event\n        Set if robot is connected.\n    on_disconnected : event\n        Set if robot is disconnected.\n    on_status_updated : event\n        Set if robot status is updated.\n    on_network_config_updated : event\n        Set if robot network configuration is updated.\n    on_status_gripper_updated : event\n        Set if gripper status is updated.\n    on_external_tool_status_updated: event\n        Set if external tool status has been updated.\n    on_gripper_state_updated: event\n        Set if gripper state has been updated.\n    on_valve_state_updated: event\n        Set if pneumatic module valve state has been updated.\n    on_output_state_updated: event\n        Set if digital outputs state has been updated.\n    on_input_state_updated: event\n        Set if digital inputs state has been updated.\n    on_vacuum_state_updated: event\n        Set if IO expansion module's vacuum module state has been updated.\n    on_holding_part: event\n        Set if gripper or IO expansion's vacuum gripper is holding a part.\n    on_released_part: event\n        Set if gripper or IO expansion's vacuum gripper is not holding a part.\n    on_vacuum_purge_done: event\n        Set when the vacuum gripper is not purging.\n    on_io_status_updated: event\n        Set if IO expansion module's status has been updated.\n    on_activated : event\n        Set if robot is activated.\n    on_deactivated : event\n        Set if robot is deactivated.\n    on_homed : event\n        Set if robot is homed.\n    on_error : event\n        Set if robot is in error.\n    on_error_reset : event\n        Set if robot error has been reset.\n    on_safety_stop_reset : event\n        Set if all safety signals that require the power supply Reset function (estop and pstop1) are reset.\n    on_safety_stop_resettable : event\n        Set if the power supply Reset function is currently available to reset safety signals (estop and pstop1).\n    on_safety_stop_state_change : event\n        Set if any safety stop status changes (see RobotSafetyStatus)\n    on_motion_paused : event\n        Set if robot motion is paused.\n    on_motion_resumed : event\n        Set if robot motion is not paused.\n    on_motion_cleared : event\n        Set if there are no pending ClearMotion commands.\n    on_activate_sim : event\n        Set if robot is in sim mode.\n    on_deactivate_sim : event\n        Set if robot is not in sim mode.\n    on_activate_ext_tool_sim : event\n        Set if robot is in gripper sim mode.\n    on_deactivate_ext_tool_sim : event\n        Set if robot is not in gripper sim mode.\n    on_io_sim_enabled : event\n        Set if robot IO module is not in sim mode.\n    on_io_sim_disabled : event\n        Set if robot IO module is in sim mode.\n    on_activate_recovery_mode : event\n        Set if robot is in recovery mode.\n    on_deactivate_recovery_mode : event\n        Set if robot is not in recovery mode.\n    on_joints_updated : event\n        Set if joint angles has been updated.\n    on_pose_updated : event\n        Set if robot pose has been updated.\n    on_brakes_activated : event\n        Set if brakes are activated.\n    on_brakes_deactivated : event\n        Set if brakes are deactivated.\n    on_offline_program_started : event\n        Set if there has been a change in the offline program state.\n    on_offline_program_op_done : event\n        Set when offline program operation (list/load/save/delete) has completed.\n    on_end_of_block : event\n        Set if end of block has been reached.\n    on_end_of_cycle: event\n        Set if end of cycle has been reached.\n    on_time_scaling_changed: event\n        Set if time scaling has changed.\n\"\"\"", "hash": "d767e409cc1c", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "Class for storing possible status events for the Mecademic robot.\n\n    Attributes\n    ----------\n    on_connected : event\n        Set if robot is connected.\n    on_disconnected : event\n        Set if robot is disconnected.\n    on_status_updated : event\n        Set if robot status is updated.\n    on_network_config_updated : event\n        Set if robot network configuration is updated.\n    on_status_gripper_updated : event\n        Set if gripper status is updated.\n    on_external_tool_status_updated: event\n        Set if external tool status has been updated.\n    on_gripper_state_updated: event\n        Set if gripper state has been updated.\n    on_valve_state_updated: event\n        Set if pneumatic module valve state has been updated.\n    on_output_state_updated: event\n        Set if digital outputs state has been updated.\n    on_input_state_updated: event\n        Set if digital inputs state has been updated.\n    on_vacuum_state_updated: event\n        Set if IO expansion module's vacuum module state has been updated.\n    on_holding_part: event\n        Set if gripper or IO expansion's vacuum gripper is holding a part.\n    on_released_part: event\n        Set if gripper or IO expansion's vacuum gripper is not holding a part.\n    on_vacuum_purge_done: event\n        Set when the vacuum gripper is not purging.\n    on_io_status_updated: event\n        Set if IO expansion module's status has been updated.\n    on_activated : event\n        Set if robot is activated.\n    on_deactivated : event\n        Set if robot is deactivated.\n    on_homed : event\n        Set if robot is homed.\n    on_error : event\n        Set if robot is in error.\n    on_error_reset : event\n        Set if robot error has been reset.\n    on_safety_stop_reset : event\n        Set if all safety signals that require the power supply Reset function (estop and pstop1) are reset.\n    on_safety_stop_resettable : event\n        Set if the power supply Reset function is currently available to reset safety signals (estop and pstop1).\n    on_safety_stop_state_change : event\n        Set if any safety stop status changes (see RobotSafetyStatus)\n    on_motion_paused : event\n        Set if robot motion is paused.\n    on_motion_resumed : event\n        Set if robot motion is not paused.\n    on_motion_cleared : event\n        Set if there are no pending ClearMotion commands.\n    on_activate_sim : event\n        Set if robot is in sim mode.\n    on_deactivate_sim : event\n        Set if robot is not in sim mode.\n    on_activate_ext_tool_sim : event\n        Set if robot is in gripper sim mode.\n    on_deactivate_ext_tool_sim : event\n        Set if robot is not in gripper sim mode.\n    on_io_sim_enabled : event\n        Set if robot IO module is not in sim mode.\n    on_io_sim_disabled : event\n        Set if robot IO module is in sim mode.\n    on_activate_recovery_mode : event\n        Set if robot is in recovery mode.\n    on_deactivate_recovery_mode : event\n        Set if robot is not in recovery mode.\n    on_joints_updated : event\n        Set if joint angles has been updated.\n    on_pose_updated : event\n        Set if robot pose has been updated.\n    on_brakes_activated : event\n        Set if brakes are activated.\n    on_brakes_deactivated : event\n        Set if brakes are deactivated.\n    on_offline_program_started : event\n        Set if there has been a change in the offline program state.\n    on_offline_program_op_done : event\n        Set when offline program operation (list/load/save/delete) has completed.\n    on_end_of_block : event\n        Set if end of block has been reached.\n    on_end_of_cycle: event\n        Set if end of cycle has been reached.\n    on_time_scaling_changed: event\n        Set if time scaling has changed.", "chunk_size_bytes": 3753, "original_size_bytes": 3754, "start_byte": 2186, "end_byte": 12691}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a2b85a999a8b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "_RobotEvents.__init__", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [167, 270], "text": "def __init__(self):\n        self.on_connected = InterruptableEvent()\n        self.on_disconnected = InterruptableEvent()\n        self.on_status_updated = InterruptableEvent()\n        self.on_network_config_updated = InterruptableEvent()\n        self.on_status_gripper_updated = InterruptableEvent()\n        self.on_external_tool_status_updated = InterruptableEvent()\n        self.on_gripper_state_updated = InterruptableEvent()\n        self.on_valve_state_updated = InterruptableEvent()\n        self.on_output_state_updated = InterruptableEvent()\n        self.on_input_state_updated = InterruptableEvent()\n        self.on_vacuum_state_updated = InterruptableEvent()\n        self.on_holding_part = InterruptableEvent()\n        self.on_released_part = InterruptableEvent()\n        self.on_vacuum_purge_done = InterruptableEvent()\n        self.on_io_status_updated = InterruptableEvent()\n        self.on_activated = InterruptableEvent()\n        self.on_deactivated = InterruptableEvent()\n        self.on_homed = InterruptableEvent()\n        self.on_error = InterruptableEvent()\n        self.on_error_reset = InterruptableEvent()\n        self.on_safety_stop_reset = InterruptableEvent()\n        self.on_safety_stop_resettable = InterruptableEvent()\n        self.on_safety_stop_state_change = InterruptableEvent()\n        self.on_pstop2 = InterruptableEvent()\n        self.on_pstop2_resettable = InterruptableEvent()\n        self.on_pstop2_reset = InterruptableEvent()\n        self.on_estop = InterruptableEvent()\n        self.on_estop_reset = InterruptableEvent()\n        self.on_estop_resettable = InterruptableEvent()\n        self.on_motion_paused = InterruptableEvent()\n        self.on_motion_resumed = InterruptableEvent()\n        self.on_motion_cleared = InterruptableEvent()\n        self.on_activate_sim = InterruptableEvent()\n        self.on_deactivate_sim = InterruptableEvent()\n        self.on_activate_ext_tool_sim = InterruptableEvent()\n        self.on_deactivate_ext_tool_sim = InterruptableEvent()\n        self.on_io_sim_enabled = InterruptableEvent()\n        self.on_io_sim_disabled = InterruptableEvent()\n        self.on_activate_recovery_mode = InterruptableEvent()\n        self.on_deactivate_recovery_mode = InterruptableEvent()\n        self.on_joints_updated = InterruptableEvent()\n        self.on_pose_updated = InterruptableEvent()\n        self.on_brakes_activated = InterruptableEvent()\n        self.on_brakes_deactivated = InterruptableEvent()\n        self.on_offline_program_started = InterruptableEvent()\n        self.on_file_op_done = InterruptableEvent()\n        self.on_time_scaling_changed = InterruptableEvent()\n        self.on_end_of_block = InterruptableEvent()\n        self.on_end_of_cycle = InterruptableEvent()\n        self.on_disconnected.set()\n        self.on_deactivated.set()\n        self.on_error_reset.set()\n        self.on_safety_stop_reset.set()\n        self.on_safety_stop_resettable.set()\n        self.on_safety_stop_state_change.set()\n        self.on_pstop2_reset.set()\n        self.on_pstop2_resettable.set()\n        self.on_estop_reset.set()\n        self.on_estop_resettable.set()\n        self.on_motion_resumed.set()\n        self.on_deactivate_sim.set()\n        self.on_time_scaling_changed.set()\n        self.on_status_updated.set()\n        self.on_network_config_updated.set()\n        self.on_status_gripper_updated.set()\n        self.on_external_tool_status_updated.set()\n        self.on_gripper_state_updated.set()\n        self.on_valve_state_updated.set()\n        self.on_output_state_updated.set()\n        self.on_input_state_updated.set()\n        self.on_vacuum_state_updated.set()\n        self.on_holding_part.set()\n        self.on_released_part.set()\n        self.on_vacuum_purge_done.set()\n        self.on_io_status_updated.set()\n        self.on_joints_updated.set()\n        self.on_pose_updated.set()\n        self.on_brakes_activated.set()", "hash": "a2b85a999a8b", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self)", "docstring": null, "chunk_size_bytes": 3894, "original_size_bytes": 4000, "start_byte": 5946, "end_byte": 9946}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:2af464e75037", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "clear_all", "qualified_name": "_RobotEvents.clear_all", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [272, 277], "text": "def clear_all(self):\n        \"\"\"Clear all events.\n        \"\"\"\n        for interruptable_event in self.__dict__.values():\n            interruptable_event.clear()", "hash": "2af464e75037", "chunk_type": "method", "node_type": "function_definition", "signature": "clear_all(self)", "docstring": "Clear all events.", "chunk_size_bytes": 160, "original_size_bytes": 161, "start_byte": 9952, "end_byte": 10113}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:2030f42d2bfb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "abort_all", "qualified_name": "_RobotEvents.abort_all", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [279, 285], "text": "def abort_all(self, skipped_events: list[str] = None, message=\"\"):\n        \"\"\"Abort all events, except for events in skipped_events list.\n        \"\"\"\n        for event_name, interruptable_event in self.__dict__.items():\n            if not skipped_events or event_name not in skipped_events:\n                interruptable_event.abort(message)", "hash": "2030f42d2bfb", "chunk_type": "method", "node_type": "function_definition", "signature": "abort_all(self, skipped_events: list[str] = None, message=\"\")", "docstring": "Abort all events, except for events in skipped_events list.", "chunk_size_bytes": 341, "original_size_bytes": 342, "start_byte": 10119, "end_byte": 10461}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:7cae079359cf", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "abort_all_on_error", "qualified_name": "_RobotEvents.abort_all_on_error", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [287, 311], "text": "def abort_all_on_error(self, message=\"\"):\n        \"\"\"Abort all events in the specific case where the robot has reported an error.\n        \"\"\"\n        self.abort_all(\n            skipped_events=[\n                'on_connected',  # Don't abort a wait for \"on_connected\" (should be done by now anyways)\n                'on_deactivated',  # Don't abort waiting for \"on_deactivated\". WaitDeactivated is can be used in error\n                'on_status_updated',  # Don't abort a wait for \"on_status_updated\", that's what we're doing!\n                'on_network_config_updated',  # Don't abort a wait for \"on_network_config_updated\", available in error\n                'on_error_reset',  # Don't abort a wait for \"on_error_reset\" because we got an error\n                'on_end_of_cycle',  # Don't abort a wait for \"on_end_of_cycle\", cycles should continue during error\n                'on_activate_recovery_mode',  # Don't abort wait for \"on_activate_recovery_mode\", available in error\n                'on_deactivate_recovery_mode',  # Don't abort wait for \"on_deactivate_recovery_mode\", available in error\n                'on_safety_stop_resettable',  # The \"Safety stop resettable\" state may still change while in error\n                'on_safety_stop_reset',  # The Safety stop reset state may still change while in error\n                'on_safety_stop_state_change',  # The \"Safety stop resettable\" state may still change while in error\n                'on_estop_reset',  # The EStop state may still change while in error\n                'on_pstop2_resettable',  # The \"PStop2 resettable\" state may still change while in error\n                'on_pstop2_reset',  # The PStop2 state may still change while in error\n                'on_estop_resettable',  # The \"EStop resettable\" state may still change while in error\n                'on_estop_reset',  # The EStop state may still change while in error\n                'on_time_scaling_changed',  # The set time scaling still works in error\n            ],\n            message=message)", "hash": "7cae079359cf", "chunk_type": "method", "node_type": "function_definition", "signature": "abort_all_on_error(self, message=\"\")", "docstring": "Abort all events in the specific case where the robot has reported an error.", "chunk_size_bytes": 2033, "original_size_bytes": 2034, "start_byte": 10467, "end_byte": 12501}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:13dde69e2da1", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "clear_abort_all", "qualified_name": "_RobotEvents.clear_abort_all", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [313, 318], "text": "def clear_abort_all(self):\n        \"\"\"Clear aborts for all events.\n        \"\"\"\n        for interruptable_event in self.__dict__.values():\n            interruptable_event.clear_abort()", "hash": "13dde69e2da1", "chunk_type": "method", "node_type": "function_definition", "signature": "clear_abort_all(self)", "docstring": "Clear aborts for all events.", "chunk_size_bytes": 183, "original_size_bytes": 184, "start_byte": 12507, "end_byte": 12691}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:6b196112a070", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_CallbackQueue", "qualified_name": "_CallbackQueue", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [321, 385], "text": "class _CallbackQueue():\n    \"\"\"Queue class for storing triggered callbacks. Only registered callbacks are added to the queue.\n    Attributes\n    ----------\n    _queue : queue\n        Queue to use to store callback names and associated data.\n    _registered_callbacks : set\n        Set of names of registered callbacks.\n\"\"\"", "hash": "6b196112a070", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "Queue class for storing triggered callbacks. Only registered callbacks are added to the queue.\n\n    Attributes\n    ----------\n    _queue : queue\n        Queue to use to store callback names and associated data.\n    _registered_callbacks : set\n        Set of names of registered callbacks.", "chunk_size_bytes": 322, "original_size_bytes": 323, "start_byte": 12694, "end_byte": 14734}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:41d2468d24a2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "_CallbackQueue.__init__", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [332, 338], "text": "def __init__(self, robot_callbacks):\n        self._queue = queue.Queue()\n        self._registered_callbacks = set()\n        for attr in robot_callbacks.__dict__:\n            if robot_callbacks.__dict__[attr] is not None:\n                self._registered_callbacks.add(attr)", "hash": "41d2468d24a2", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self, robot_callbacks)", "docstring": null, "chunk_size_bytes": 273, "original_size_bytes": 274, "start_byte": 13023, "end_byte": 13297}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:5b98d73272d3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "qsize", "qualified_name": "_CallbackQueue.qsize", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [340, 344], "text": "def qsize(self) -> int:\n        \"\"\"Returns the queue size.\n        \"\"\"\n        return self._queue.qsize()", "hash": "5b98d73272d3", "chunk_type": "method", "node_type": "function_definition", "signature": "qsize(self)", "docstring": "Returns the queue size.", "chunk_size_bytes": 105, "original_size_bytes": 106, "start_byte": 13303, "end_byte": 13409}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:10c20cd3ff2b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "register", "qualified_name": "_CallbackQueue.register", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [346, 349], "text": "def register(self, callback_name):\n        \"\"\" Register a callback so it's enabled\"\"\"\n        if not callback_name in self._registered_callbacks:\n            self._registered_callbacks.add(callback_name)", "hash": "10c20cd3ff2b", "chunk_type": "method", "node_type": "function_definition", "signature": "register(self, callback_name)", "docstring": "Register a callback so it's enabled", "chunk_size_bytes": 203, "original_size_bytes": 203, "start_byte": 13415, "end_byte": 13618}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:86086229e2e8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unregister", "qualified_name": "_CallbackQueue.unregister", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [351, 354], "text": "def unregister(self, callback_name):\n        \"\"\" Unregister a callback so it's no longer called\"\"\"\n        if callback_name in self._registered_callbacks:\n            self._registered_callbacks.remove(callback_name)", "hash": "86086229e2e8", "chunk_type": "method", "node_type": "function_definition", "signature": "unregister(self, callback_name)", "docstring": "Unregister a callback so it's no longer called", "chunk_size_bytes": 215, "original_size_bytes": 215, "start_byte": 13624, "end_byte": 13839}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:7b5dd0ee4145", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "put", "qualified_name": "_CallbackQueue.put", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [356, 368], "text": "def put(self, callback_name, data=None):\n        \"\"\"Put the callback name and associated data into the queue if is registered.\n        Parameters\n        ----------\n        callback_name : str\n            Name of callback.\n        data : any object type\n            Associated data.\n        \"\"\"\n        if callback_name in self._registered_callbacks or callback_name == _TERMINATE:\n            self._queue.put((callback_name, data))", "hash": "7b5dd0ee4145", "chunk_type": "method", "node_type": "function_definition", "signature": "put(self, callback_name, data=None)", "docstring": "Put the callback name and associated data into the queue if is registered.\n\n        Parameters\n        ----------\n        callback_name : str\n            Name of callback.\n        data : any object type\n            Associated data.", "chunk_size_bytes": 432, "original_size_bytes": 434, "start_byte": 13845, "end_byte": 14279}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:44a92a8d505b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "get", "qualified_name": "_CallbackQueue.get", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [370, 385], "text": "def get(self, block=False, timeout: float = None) -> tuple[str, str]:\n        \"\"\"Get the next callback in the queue.\n        Parameters\n        ----------\n        block : bool\n            Block on next available callback if true.\n        timeout : float\n            Maximum time to wait on a callback.\n        Returns\n        -------\n        tuple of callback name and data\n        \"\"\"\n        return self._queue.get(block=block, timeout=timeout)", "hash": "44a92a8d505b", "chunk_type": "method", "node_type": "function_definition", "signature": "get(self, block=False, timeout: float = None)", "docstring": "Get the next callback in the queue.\n\n        Parameters\n        ----------\n        block : bool\n            Block on next available callback if true.\n        timeout : float\n            Maximum time to wait on a callback.\n\n        Returns\n        -------\n        tuple of callback name and data", "chunk_size_bytes": 446, "original_size_bytes": 449, "start_byte": 14285, "end_byte": 14734}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:4b804c9597bc", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_Robot", "qualified_name": "_Robot", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [388, 5949], "text": "class _Robot:\n    \"\"\"Class for controlling a Mecademic robot.\n    Attributes (private, please use public methods instead, i.e. methods not starting with underscore)\n    ----------\n    _address : string\n        The IP address associated to the Mecademic Robot.\n    _command_socket : socket object\n        Socket connecting to the command port of the Mecademic robot.\n    _monitor_socket : socket object\n        Socket connecting to the monitor port of the Mecademic robot.\n    _rx_thread : thread handle\n        Thread used to receive messages from the command port.\n    _command_rx_queue : queue\n        Queue used to temporarily store messages from the command port.\n    _tx_thread : thread handle\n        Thread used to transmit messages to the command port.\n    _command_tx_queue : queue\n        Queue used to temporarily store commands to be sent to the command port.\n    _monitor_rx_thread : thread handle\n        Thread used to receive messages from the monitor port.\n    _monitor_rx_queue : queue\n        Queue used to temporarily store messages from the monitor port.\n    _rx_timestamp : float\n        Last time a message was received from the robot\n    _rx_handler_thread : thread handle\n        Thread used to read messages from the command response queue.\n    _monitor_rx_handler_thread : thread handle\n        Thread used to read messages from the monitor queue.\n    _main_lock : recursive lock object\n        Used to protect internal state of the robot object.\n    _robot_info: RobotInfo object\n        Store information concerning robot (ex.: serial number)\n    _robot_rt_data : RobotRtData object\n        Stores current robot real-time data.\n        All attributes of this object are the latest captured on monitor port, so they don't necessarily share the same\n        timestamp\n    _robot_rt_data_stable : RobotRtData object\n        Stores current robot real-time data, but all attributes of object share the same timestamp\n    _robot_status: RobotStatus object\n        Stores current robot status\n    _robot_safety_status: RobotSafetyStatus object\n        Stores current robot safety status\n    _robot_psu_inputs: RobotPowerSupplyInputs object\n        Stores current robot power supply input states\n    _robot_collision_status: CollisionStatus\n        Stores current collision status (self collision and work zone boundary)\n    _gripper_status: GripperStatus object\n        Stores current gripper status\n    _external_tool_status: ExtToolStatus object\n        Stores current external tool status\n    _gripper_state: GripperState object\n        Stores current gripper state\n    _gripper_state_before_last_move : GripperState object\n        Stores gripper state at the time a Open/Close/Move gripper command is sent\n        (then used to accelerate WaitGripperMoveCompletion in case target_pos_reached is already True when its called\n         because otherwise it's not possible to know if the move has completed, or not yet started)\n    _valve_state: ValveState object\n        Stores current pneumatic valve state\n    _psu_io_status: IoStatus object\n        Stores current PSU IO module status\n    _io_module_status: IoStatus object\n        Stores current IO module status\n    _vacuum_state: IoStatus object\n        Stores current IO module's vacuum gripper state\n    _sig_gen_status: IoStatus object\n        Stores current signal generator status\n    _fw_update_status: Firmware update status\n        Stores current firmware update status reported by the robot\n    _robot_events : RobotEvents object\n        Stores events related to the robot state.\n    _file_logger : RobotDataLogger object\n        Collects RobotInformation, all RobotRtData and SentCommands during determined period\n    _monitoring_interval : float\n        Initial monitoring interval to restore after logging session\n    _robot_callbacks : RobotCallbacks instance\n        Stores user-defined callback functions.\n    _callback_queue : queue\n        Queue storing triggered callbacks.\n    _callback_thread : thread handle\n        Callbacks will run in this thread if so configured.\n    _user_checkpoints : dictionary\n        Stores checkpoints set or expected by user.\n    _internal_checkpoints : dictionary\n        Stores checkpoints set internally by the Robot class.\n    _internal_checkpoint_counter : int\n        Stores the next available checkpoint id for internal checkpoints.\n    _enable_synchronous_mode : boolean\n        If enabled, commands block until action is completed.\n    _clear_motion_requests : int\n        Number of pending ClearMotion requests.\n    logger : logger object\n        Logger used throughout class.\n    default_timeout : float\n        Default timeout to use for blocking operations.\n    _tmp_rt_joint_pos : list of float\n        Values from legacy mx_st.MX_ST_GET_JOINTS event received in current cycle\n    _tmp_rt_cart_pos : list of float\n        Values from legacy mx_st.MX_ST_GET_POSE event received in current cycle\n    _tx_sync : integer\n        Value sent in the most recent \"SyncCmdQueue\" request sent to robot\n    _rx_sync : integer\n        Most recent response to \"SyncCmdQueue\" (mx_st.MX_ST_SYNC_CMD_QUEUE) received from the robot\n\"\"\"", "hash": "4b804c9597bc", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "Class for controlling a Mecademic robot.\n\n    Attributes (private, please use public methods instead, i.e. methods not starting with underscore)\n    ----------\n    _address : string\n        The IP address associated to the Mecademic Robot.\n    _command_socket : socket object\n        Socket connecting to the command port of the Mecademic robot.\n    _monitor_socket : socket object\n        Socket connecting to the monitor port of the Mecademic robot.\n\n    _rx_thread : thread handle\n        Thread used to receive messages from the command port.\n    _command_rx_queue : queue\n        Queue used to temporarily store messages from the command port.\n    _tx_thread : thread handle\n        Thread used to transmit messages to the command port.\n    _command_tx_queue : queue\n        Queue used to temporarily store commands to be sent to the command port.\n    _monitor_rx_thread : thread handle\n        Thread used to receive messages from the monitor port.\n    _monitor_rx_queue : queue\n        Queue used to temporarily store messages from the monitor port.\n    _rx_timestamp : float\n        Last time a message was received from the robot\n\n    _rx_handler_thread : thread handle\n        Thread used to read messages from the command response queue.\n    _monitor_rx_handler_thread : thread handle\n        Thread used to read messages from the monitor queue.\n\n    _main_lock : recursive lock object\n        Used to protect internal state of the robot object.\n\n    _robot_info: RobotInfo object\n        Store information concerning robot (ex.: serial number)\n    _robot_rt_data : RobotRtData object\n        Stores current robot real-time data.\n        All attributes of this object are the latest captured on monitor port, so they don't necessarily share the same\n        timestamp\n    _robot_rt_data_stable : RobotRtData object\n        Stores current robot real-time data, but all attributes of object share the same timestamp\n    _robot_status: RobotStatus object\n        Stores current robot status\n    _robot_safety_status: RobotSafetyStatus object\n        Stores current robot safety status\n    _robot_psu_inputs: RobotPowerSupplyInputs object\n        Stores current robot power supply input states\n    _robot_collision_status: CollisionStatus\n        Stores current collision status (self collision and work zone boundary)\n    _gripper_status: GripperStatus object\n        Stores current gripper status\n    _external_tool_status: ExtToolStatus object\n        Stores current external tool status\n    _gripper_state: GripperState object\n        Stores current gripper state\n    _gripper_state_before_last_move : GripperState object\n        Stores gripper state at the time a Open/Close/Move gripper command is sent\n        (then used to accelerate WaitGripperMoveCompletion in case target_pos_reached is already True when its called\n         because otherwise it's not possible to know if the move has completed, or not yet started)\n    _valve_state: ValveState object\n        Stores current pneumatic valve state\n    _psu_io_status: IoStatus object\n        Stores current PSU IO module status\n    _io_module_status: IoStatus object\n        Stores current IO module status\n    _vacuum_state: IoStatus object\n        Stores current IO module's vacuum gripper state\n    _sig_gen_status: IoStatus object\n        Stores current signal generator status\n    _fw_update_status: Firmware update status\n        Stores current firmware update status reported by the robot\n    _robot_events : RobotEvents object\n        Stores events related to the robot state.\n\n    _file_logger : RobotDataLogger object\n        Collects RobotInformation, all RobotRtData and SentCommands during determined period\n    _monitoring_interval : float\n        Initial monitoring interval to restore after logging session\n\n    _robot_callbacks : RobotCallbacks instance\n        Stores user-defined callback functions.\n    _callback_queue : queue\n        Queue storing triggered callbacks.\n    _callback_thread : thread handle\n        Callbacks will run in this thread if so configured.\n\n    _user_checkpoints : dictionary\n        Stores checkpoints set or expected by user.\n    _internal_checkpoints : dictionary\n        Stores checkpoints set internally by the Robot class.\n    _internal_checkpoint_counter : int\n        Stores the next available checkpoint id for internal checkpoints.\n\n    _enable_synchronous_mode : boolean\n        If enabled, commands block until action is completed.\n\n    _clear_motion_requests : int\n        Number of pending ClearMotion requests.\n\n    logger : logger object\n        Logger used throughout class.\n\n    default_timeout : float\n        Default timeout to use for blocking operations.\n\n    _tmp_rt_joint_pos : list of float\n        Values from legacy mx_st.MX_ST_GET_JOINTS event received in current cycle\n    _tmp_rt_cart_pos : list of float\n        Values from legacy mx_st.MX_ST_GET_POSE event received in current cycle\n\n    _tx_sync : integer\n        Value sent in the most recent \"SyncCmdQueue\" request sent to robot\n    _rx_sync : integer\n        Most recent response to \"SyncCmdQueue\" (mx_st.MX_ST_SYNC_CMD_QUEUE) received from the robot", "chunk_size_bytes": 5161, "original_size_bytes": 5175, "start_byte": 14737, "end_byte": 274235}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:e3f00ccf2fe0", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "_Robot.__init__", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [506, 740], "text": "def __init__(self):\n        \"\"\"Constructor for an instance of the Robot class.\n        \"\"\"\n        self.logger = logging.getLogger(__name__)\n        self._is_initialized = False\n        self._offline_mode = False\n        self._robot_callbacks = RobotCallbacks()\n        self._run_callbacks_in_separate_thread = False\n        self._reset()\n        self._send_cmd_handlers: dict[str, Callable] = {\n            'activaterobot': self._sending_ActivateRobot,\n            'deletefile': self._sending_DeleteFile,\n            'deleteprogram': self._sending_DeleteFile,\n            'clearmotion': self._sending_ClearMotion,\n            'listfiles': self._sending_ListFiles,\n            'listprograms': self._sending_ListFiles,\n            'loadfile': self._sending_LoadFile,\n            'loadprogram': self._sending_LoadFile,\n            'home': self._sending_Home,\n            'savefile': self._sending_SaveFile,\n            'saveprogram': self._sending_SaveFile,\n            'setmonitoringinterval': self._sending_SetMonitoringInterval,\n            'settimescaling': self._sending_SetTimeScaling,\n            'startprogram': self._sending_StartProgram,\n        }\n        self._messages_handlers = {\n            mx_st.MX_ST_NOT_ACTIVATED:  # 1005\n            lambda response: self._invalidate_checkpoints('robot is not activated', forced=False),\n            mx_st.MX_ST_ALREADY_ERR:  # 1011\n            lambda response: self._invalidate_checkpoints('robot is in error', forced=False),\n            mx_st.MX_ST_ACTIVATION_ERR:  # 1013\n            self._handle_activation_err,\n            mx_st.MX_ST_HOMING_ERR:  # 1014\n            self._handle_homing_err,\n            mx_st.MX_ST_IMPOSSIBLE_RESET_ERR:  # 1025\n            self._handle_impossible_reset_err,\n            mx_st.MX_ST_LIST_FILES_ERR:  # 1500\n            lambda response: self._robot_events.on_file_op_done.abort(\"Failed to list files\"),\n            mx_st.MX_ST_LOAD_FILE_ERR:  # 1501\n            self._handle_load_file_err,\n            mx_st.MX_ST_SAVE_FILE_ERR:  # 1502\n            self._handle_save_file_err,\n            mx_st.MX_ST_DELETE_FILE_ERR:  # 1503\n            self._handle_delete_file_err,\n            mx_st.MX_ST_GET_STATUS_ROBOT:  # 2007\n            self._handle_robot_status_response,\n            mx_st.MX_ST_BRAKES_OFF:  # 2008\n            lambda response: self._set_brakes_engaged(False),\n            mx_st.MX_ST_BRAKES_ON:  # 2010\n            lambda response: self._set_brakes_engaged(True),\n            mx_st.MX_ST_TIME_SCALING:  # 2015\n            self._handle_get_time_scaling_response,\n            mx_st.MX_ST_GET_JOINTS:  # 2026\n            self._handle_get_joints_legacy,\n            mx_st.MX_ST_GET_POSE:  # 2027\n            self._handle_get_pose_legacy,\n            mx_st.MX_ST_GET_CONF:  # 2029\n            self._handle_get_conf_legacy,\n            mx_st.MX_ST_GET_CONF_TURN:  # 2036\n            self._handle_get_conf_turn_legacy,\n            mx_st.MX_ST_PAUSE_MOTION:  # 2042\n            self._handle_pause_motion,\n            mx_st.MX_ST_RESUME_MOTION:  # 2043\n            self._handle_resume_motion,\n            mx_st.MX_ST_CLEAR_MOTION:  # 2044\n            self._handle_clear_motion,\n            mx_st.MX_ST_EXTTOOL_SIM:  # 2047\n            self._handle_ext_tool_sim_status_legacy,\n            MX_ST_EXTTOOL_SIM_OFF:  # 2048\n            self._handle_ext_tool_sim_status_off,\n            mx_st.MX_ST_RECOVERY_MODE_ON:  # 2049\n            lambda response: self._handle_recovery_mode_status(True),\n            mx_st.MX_ST_RECOVERY_MODE_OFF:  # 2050\n            lambda response: self._handle_recovery_mode_status(False),\n            mx_st.MX_ST_OFFLINE_START:  # 2063\n            self._handle_offline_start,\n            mx_st.MX_ST_GET_STATUS_GRIPPER:  # 2079\n            self._handle_gripper_status_response,\n            mx_st.MX_ST_GET_ROBOT_SERIAL:  # 2083\n            self._handle_robot_get_robot_serial_response,\n            mx_st.MX_ST_GET_EXT_TOOL_FW_VERSION:  # 2086\n            self._handle_ext_tool_fw_version,\n            mx_st.MX_ST_GET_NETWORK_CFG:  # 2089\n            self._handle_get_network_cfg_response,\n            mx_st.MX_ST_SYNC_CMD_QUEUE:  # 2097\n            self._handle_sync_response,\n            mx_st.MX_ST_GET_REAL_TIME_MONITORING:  # 2117\n            self._handle_get_realtime_monitoring_response,\n            mx_st.MX_ST_GET_OPERATION_MODE:  # 2176\n            self._handle_get_operation_mode,\n            mx_st.MX_ST_CONNECTION_WATCHDOG:  # 2177\n            lambda response: self._set_connection_watchdog_enabled(self._parse_response_bool(response)[0]),\n            mx_st.MX_ST_GET_COLLISION_STATUS:  # 2182\n            self._handle_collision_status_response,\n            mx_st.MX_ST_GET_WORK_ZONE_STATUS:  # 2183\n            self._handle_work_zone_status_response,\n            mx_st.MX_ST_RT_TARGET_JOINT_POS:  # 2200\n            self._handle_target_joint_pos,\n            mx_st.MX_ST_RT_TARGET_CART_POS:  # 2201\n            self._handle_target_cart_pos,\n            mx_st.MX_ST_RT_TARGET_JOINT_VEL:  # 2202\n            self._handle_target_joint_vel,\n            mx_st.MX_ST_RT_TARGET_JOINT_TORQ:  # 2203\n            self._handle_target_joint_torq,\n            mx_st.MX_ST_RT_TARGET_CART_VEL:  # 2204\n            self._handle_target_cart_vel,\n            mx_st.MX_ST_RT_TARGET_CONF:  # 2208\n            self._handle_target_conf,\n            mx_st.MX_ST_RT_TARGET_CONF_TURN:  # 2209\n            self._handle_target_conf_turn,\n            mx_st.MX_ST_RT_JOINT_POS:  # 2210\n            self._handle_joint_pos,\n            mx_st.MX_ST_RT_CART_POS:  # 2211\n            self._handle_cart_pos,\n            mx_st.MX_ST_RT_JOINT_VEL:  # 2212\n            self._handle_joint_vel,\n            mx_st.MX_ST_RT_JOINT_TORQ:  # 2213\n            self._handle_joint_torq,\n            mx_st.MX_ST_RT_CART_VEL:  # 2214\n            self._handle_cart_vel,\n            mx_st.MX_ST_RT_CONF:  # 2218\n            self._handle_conf,\n            mx_st.MX_ST_RT_CONF_TURN:  # 2219\n            self._handle_conf_turn,\n            mx_st.MX_ST_RT_ACCELEROMETER:  # 2220\n            self._handle_accelerometer,\n            mx_st.MX_ST_RT_ABS_JOINT_POS:  # 2221\n            self._handle_abs_joint_pos,\n            mx_st.MX_ST_RT_EFFECTIVE_TIME_SCALING:  # 2222\n            self._handle_effective_time_scaling_data,\n            mx_st.MX_ST_RT_VM:  # 2223\n            self._handle_rt_vm,\n            mx_st.MX_ST_RT_CURRENT:  # 2224\n            self._handle_rt_current,\n            mx_st.MX_ST_RT_CHECKPOINT:  # 2227\n            self._handle_rt_checkpoint,\n            mx_st.MX_ST_RT_WRF:  # 2228\n            self._handle_wrf,\n            mx_st.MX_ST_RT_TRF:  # 2229\n            self._handle_trf,\n            mx_st.MX_ST_RT_CYCLE_END:  # 2230\n            self._handle_cycle_end,\n            mx_st.MX_ST_RT_EXTTOOL_STATUS:  # 2300\n            self._handle_external_tool_status_response,\n            mx_st.MX_ST_RT_VALVE_STATE:  # 2310\n            self._handle_valve_state_response,\n            mx_st.MX_ST_RT_GRIPPER_STATE:  # 2320\n            self._handle_gripper_state_response,\n            mx_st.MX_ST_RT_GRIPPER_FORCE:  # 2321\n            self._handle_gripper_force_response,\n            mx_st.MX_ST_RT_GRIPPER_POS:  # 2322\n            self._handle_gripper_pos_response,\n            mx_st.MX_ST_RT_IO_STATUS:  # 2330\n            self._handle_io_status,\n            mx_st.MX_ST_RT_OUTPUT_STATE:  # 2340\n            self._handle_output_state,\n            mx_st.MX_ST_RT_INPUT_STATE:  # 2341\n            self._handle_input_state,\n            mx_st.MX_ST_RT_VACUUM_STATE:  # 2342\n            self._handle_vacuum_state,\n            mx_st.MX_ST_RT_VACUUM_PRESSURE:  # 2343\n            self._handle_vacuum_pressure,\n            mx_st.MX_ST_LIST_FILES:  # 2500\n            self._handle_file_op_done,\n            mx_st.MX_ST_LOAD_FILE:  # 2501\n            self._handle_file_op_done,\n            mx_st.MX_ST_SAVE_FILE:  # 2502\n            self._handle_file_op_done,\n            mx_st.MX_ST_DELETE_FILE:  # 2503\n            self._handle_file_op_done,\n            mx_st.MX_ST_EOB:  # 3012\n            self._handle_eob,\n            mx_st.MX_ST_NO_OFFLINE_SAVED:  # 3017\n            self._handle_offline_program_error,\n            mx_st.MX_ST_OFFLINE_INVALID:  # 3020\n            self._handle_offline_program_error,\n            mx_st.MX_ST_TORQUE_LIMIT_STATUS:  # 3028\n            self._handle_torque_limit_status,\n            mx_st.MX_ST_CHECKPOINT_REACHED:  # 3030\n            lambda response: self._handle_checkpoint(response, discarded=False),\n            mx_st.MX_ST_PSTOP2:  # 3032\n            self._handle_pstop2_state,\n            mx_st.MX_ST_FW_UPDATE_PROGRESS:  # 3038\n            self._handle_fw_update_progress,\n            mx_st.MX_ST_CHECKPOINT_DISCARDED:  # 3040\n            lambda response: self._handle_checkpoint(response, discarded=True),\n            mx_st.MX_ST_PSTOP1:  # 3069\n            self._handle_pstop1_state,\n            mx_st.MX_ST_ESTOP:  # 3070\n            self._handle_estop_state,\n            mx_st.MX_ST_SAFE_STOP_OPERATION_MODE:  # 3080\n            self._handle_operation_mode_stop_state,\n            mx_st.MX_ST_SAFE_STOP_ENABLING_DEVICE_RELEASED:  # 3081\n            self._handle_enabling_device_released_stop_state,\n            mx_st.MX_ST_SAFE_STOP_VOLTAGE_FLUCTUATION:  # 3082\n            self._handle_voltage_fluctuation_stop_state,\n            mx_st.MX_ST_SAFE_STOP_REBOOT:  # 3083\n            self._handle_reboot_stop_state,\n            mx_st.MX_ST_SAFE_STOP_REDUNDANCY_FAULT:  # 3084\n            self._handle_redundancy_fault_stop_state,\n            mx_st.MX_ST_SAFE_STOP_STANDSTILL_FAULT:  # 3085\n            self._handle_standstill_fault_stop_state,\n            mx_st.MX_ST_SAFE_STOP_CONNECTION_DROPPED:  # 3086\n            self._handle_connection_dropped_stop_state,\n            mx_st.MX_ST_SAFE_STOP_MINOR_ERROR:  # 3087\n            self._handle_minor_error_stop_state,\n            mx_st.MX_ST_DICT_CMD_ADDED:  # 3200\n            self._handle_dict_cmd_added,\n            mx_st.MX_ST_DICT_CMD_REMOVED:  # 3201\n            self._handle_dict_cmd_removed,\n            mx_st.MX_ST_SIDECAR_STATUS:  # 3203\n            self._handle_sidecar_status,\n            mx_st.MX_ST_VARIABLE_ADDED:  # 3310\n            self._handle_variable_added,\n            mx_st.MX_ST_VARIABLE_REMOVED:  # 3311\n            self._handle_variable_removed,\n        }\n        self._sidecar_registered_functions: dict[str, rsc.RegisteredFunction] = {}\n        self._sidecar_overridden_functions: dict[str, callable] = {}\n        self._sidecar_status: list[RobotSidecarStatus] = []\n        self._registered_vars_by_name: dict[str, rsc.RegisteredVariable] = {}\n        self._registered_cyclic_id: dict[int, Union[rsc.RegisteredFunction, rsc.RegisteredVariable]] = {}\n        self.vars = VariablesContainer()\n        self.vars.attach(self._get_variable, self._set_variable)", "hash": "e3f00ccf2fe0", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self)", "docstring": "Constructor for an instance of the Robot class.", "chunk_size_bytes": 10845, "original_size_bytes": 11413, "start_byte": 19918, "end_byte": 31331}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:12c01f72d138", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__del__", "qualified_name": "_Robot.__del__", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [742, 752], "text": "def __del__(self):\n        \"\"\"Destructor for an instance of the Robot class.\n        Warnings\n        --------\n        In python, the  destructor is called by garbage collector, it may not be called when Robot object\n        instance is released so make sure to explicitly Disconnect from the robot, or use \"with\" block if you\n        need to control when the disconnection with robot occurs.\n        \"\"\"\n        self._reset()\n        self.UnregisterCallbacks()", "hash": "12c01f72d138", "chunk_type": "method", "node_type": "function_definition", "signature": "__del__(self)", "docstring": "Destructor for an instance of the Robot class.\n\n        Warnings\n        --------\n        In python, the  destructor is called by garbage collector, it may not be called when Robot object\n        instance is released so make sure to explicitly Disconnect from the robot, or use \"with\" block if you\n        need to control when the disconnection with robot occurs.", "chunk_size_bytes": 461, "original_size_bytes": 462, "start_byte": 31337, "end_byte": 31799}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d2ce28b855b9", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__enter__", "qualified_name": "_Robot.__enter__", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [754, 765], "text": "def __enter__(self):\n        \"\"\"Function called when entering \"with\" block with a Robot object instance.\n        Raises\n        ------\n        InvalidStateError\n            Exception raised if robot is already connected when entering \"with\" statement (since by design the usage\n            of the \"with\" statement is to ensure proper disconnection from the robot at the end of the \"with\" scope\n        \"\"\"\n        if self.IsConnected():\n            raise InvalidStateError('Robot cannot be connected when entering \\'with\\' block')\n        return self", "hash": "d2ce28b855b9", "chunk_type": "method", "node_type": "function_definition", "signature": "__enter__(self)", "docstring": "Function called when entering \"with\" block with a Robot object instance.\n\n        Raises\n        ------\n        InvalidStateError\n            Exception raised if robot is already connected when entering \"with\" statement (since by design the usage\n            of the \"with\" statement is to ensure proper disconnection from the robot at the end of the \"with\" scope", "chunk_size_bytes": 550, "original_size_bytes": 551, "start_byte": 31805, "end_byte": 32356}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c8c182c8b31f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__exit__", "qualified_name": "_Robot.__exit__", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [768, 773], "text": "def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Function called when exiting \"with\" block with a Robot object instance.\n        This forces disconnection with the robot and reset of all states, except registered callbacks\n        which remain attached in case the same Robot object is reconnected later.\n        \"\"\"\n        self._reset()", "hash": "c8c182c8b31f", "chunk_type": "method", "node_type": "function_definition", "signature": "__exit__(self, exc_type, exc_value, traceback)", "docstring": "Function called when exiting \"with\" block with a Robot object instance.\n        This forces disconnection with the robot and reset of all states, except registered callbacks\n        which remain attached in case the same Robot object is reconnected later.", "chunk_size_bytes": 352, "original_size_bytes": 352, "start_byte": 32404, "end_byte": 32756}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:4bdd458b8af6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_reset", "qualified_name": "_Robot._reset", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [775, 858], "text": "def _reset(self):\n        \"\"\" Reset the Robot class (disconnects, stop threads, clears queues, etc).\n        (this code is common to constructor, destructor and __exit__ implicit functions)\n        Only thing that is not reset are registered callbacks.\n        \"\"\"\n        if self._is_initialized and self.IsConnected():\n            self._disconnect()\n        self._address = None\n        self._port = None\n        self._command_socket = None\n        self._monitor_socket = None\n        self._rx_thread = None\n        self._tx_thread = None\n        self._monitor_rx_thread = None\n        self._rx_handler_thread = None\n        self._monitor_rx_handler_thread = None\n        self._main_lock = threading.RLock()\n        self._callback_queue = _CallbackQueue(self._robot_callbacks)\n        self._callback_thread = None\n        self._network_config = NetworkConfig()\n        self._robot_info = RobotInfo()\n        self._robot_rt_data = None\n        self._robot_rt_data_stable = None\n        self._robot_status = RobotStatus()\n        self._robot_safety_status = RobotSafetyStatus()\n        self._robot_psu_inputs = RobotPowerSupplyInputs()\n        self._robot_collision_status = CollisionStatus()\n        self._first_robot_status_received = False\n        self._using_legacy_json_api = False\n        self._gripper_status = GripperStatus()\n        self._external_tool_status = ExtToolStatus()\n        self._gripper_state = GripperState()\n        self._gripper_state_before_last_move = GripperState()\n        self._valve_state = ValveState()\n        self._psu_io_status = IoStatus()\n        self._io_module_status = IoStatus()\n        self._vacuum_state = VacuumState()\n        self._sig_gen_status = IoStatus()\n        self._robot_events = _RobotEvents()\n        self._reset_fw_update_status()\n        self._file_logger = None\n        self._monitoring_interval = None\n        self._monitoring_interval_to_restore = None\n        self._auto_connection_watchdog = False\n        self._auto_connection_watchdog_last = 0\n        self._reset_disconnect_attributes()\n        self._enable_synchronous_mode = None\n        self._disconnect_on_exception = None\n        self._offline_mode = None\n        self._sidecar_mode = None\n        self._monitor_mode = None\n        self.default_timeout = DEFAULT_WAIT_TIMEOUT\n        self._tmp_rt_joint_pos = None\n        self._tmp_rt_cart_pos = None\n        self._is_sync = InterruptableEvent()\n        self._is_sync.set()\n        self._tx_sync = 0\n        self._tx_sync_pending = 0\n        self._rx_sync = 0\n        self._captured_trajectory = None\n        self._unregister_functions(remote_attributes_only=False)\n        self._is_initialized = True", "hash": "4bdd458b8af6", "chunk_type": "method", "node_type": "function_definition", "signature": "_reset(self)", "docstring": "Reset the Robot class (disconnects, stop threads, clears queues, etc).\n        (this code is common to constructor, destructor and __exit__ implicit functions)\n        Only thing that is not reset are registered callbacks.", "chunk_size_bytes": 2672, "original_size_bytes": 3012, "start_byte": 32762, "end_byte": 35774}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:98f6af6775a2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_reset_disconnect_attributes", "qualified_name": "_Robot._reset_disconnect_attributes", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [860, 877], "text": "def _reset_disconnect_attributes(self):\n        \"\"\" Reset class attributes that need to be reset following a disconnection with the robot \"\"\"\n        if not self._offline_mode:\n            self._command_rx_queue = queue.Queue()\n            self._command_tx_queue = queue.Queue()\n            self._monitor_rx_queue = queue.Queue()\n        self._rx_timestamp = 0\n        self._monitor_timeout_used = False\n        self._custom_response_events = list()\n        self._user_checkpoints = dict()\n        self._internal_checkpoints = dict()\n        self._internal_checkpoint_counter = MX_CHECKPOINT_ID_MAX + 1\n        self._clear_motion_requests = 0\n        self._unregister_functions(remote_attributes_only=True)\n        self._unregister_variables()", "hash": "98f6af6775a2", "chunk_type": "method", "node_type": "function_definition", "signature": "_reset_disconnect_attributes(self)", "docstring": "Reset class attributes that need to be reset following a disconnection with the robot", "chunk_size_bytes": 743, "original_size_bytes": 746, "start_byte": 35780, "end_byte": 36526}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b09e0c508a0d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_unregister_functions", "qualified_name": "_Robot._unregister_functions", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [879, 897], "text": "def _unregister_functions(self, remote_attributes_only: bool):\n        \"\"\"Unregister all functions that are no longer relevant\n        Args:\n            remote_attributes_only (_type_): True -> Unregister only attributes that were remotely created.\n                                                     (this is typically done when disconnecting from the robot and we\n                                                      must cleanup functions that the robot reported to us earlier)\n                                             False -> Unregister all functions (i.e. we're destroying)\n        \"\"\"\n        if not self._is_initialized:\n            return\n        functions_to_unregister: list[str] = []\n        for function_name, function in self._sidecar_registered_functions.items():\n            if not remote_attributes_only or not function.locally_created:\n                functions_to_unregister.append(function_name)\n        for function_name in functions_to_unregister:\n            self._sidecar_unregister_function(function_name)", "hash": "b09e0c508a0d", "chunk_type": "method", "node_type": "function_definition", "signature": "_unregister_functions(self, remote_attributes_only: bool)", "docstring": "Unregister all functions that are no longer relevant\n\n        Args:\n            remote_attributes_only (_type_): True -> Unregister only attributes that were remotely created.\n                                                     (this is typically done when disconnecting from the robot and we\n                                                      must cleanup functions that the robot reported to us earlier)\n                                             False -> Unregister all functions (i.e. we're destroying)", "chunk_size_bytes": 1036, "original_size_bytes": 1118, "start_byte": 36532, "end_byte": 37650}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:491bdcd50b2c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_unregister_variables", "qualified_name": "_Robot._unregister_variables", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [899, 910], "text": "def _unregister_variables(self):\n        \"\"\" Unregister all robot variables \"\"\"\n        if not self._is_initialized:\n            return\n        variables_to_unregister: list[str] = []\n        for name, _ in self._registered_vars_by_name.items():\n            variables_to_unregister.append(name)\n        for name in variables_to_unregister:\n            self._unregister_variable(name)", "hash": "491bdcd50b2c", "chunk_type": "method", "node_type": "function_definition", "signature": "_unregister_variables(self)", "docstring": "Unregister all robot variables", "chunk_size_bytes": 383, "original_size_bytes": 465, "start_byte": 37656, "end_byte": 38121}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b9f6ec1941db", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_reset_fw_update_status", "qualified_name": "_Robot._reset_fw_update_status", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [912, 916], "text": "def _reset_fw_update_status(self):\n        self._fw_update_status = UpdateProgress()\n        self._fw_update_reboot_timestamp = 0.0  # Timestamp, non-zero while rebooting\n        self._fw_update_started: bool = False\n        self._fw_update_reboot_done: bool = False", "hash": "b9f6ec1941db", "chunk_type": "method", "node_type": "function_definition", "signature": "_reset_fw_update_status(self)", "docstring": null, "chunk_size_bytes": 266, "original_size_bytes": 266, "start_byte": 38127, "end_byte": 38393}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f00c311a7f33", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_rx_thread_fct", "qualified_name": "_Robot._rx_thread_fct", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [923, 970], "text": "def _rx_thread_fct(self, robot_socket: socket.socket, rx_queue: queue.Queue):\n        \"\"\"Handle received data on the socket.\n        Parameters\n        ----------\n        robot_socket : socket\n            Socket to use for receiving data.\n        rx_queue : queue\n            Thread-safe queue to push complete messages onto.\n        logger : logger instance\n            Logger to use.\n        \"\"\"\n        remainder = ''\n        while True:\n            try:\n                robot_socket.setblocking(True)\n                raw_responses = robot_socket.recv(1024)\n            except (ConnectionAbortedError, BrokenPipeError, OSError):\n                break\n            if raw_responses == b'':\n                break\n            responses = raw_responses.decode('ascii').split('\\0')\n            if remainder != '':\n                responses[0] = remainder + responses[0]\n            remainder = responses[-1]\n            for response in responses[:-1]:\n                rx_queue.put(Message.from_string(response))\n        if self._rx_handler_thread is not None:\n            self.logger.warning(f'Rx thread: TCP socket with the robot has been closed')\n        rx_queue.put(_TERMINATE)", "hash": "f00c311a7f33", "chunk_type": "method", "node_type": "function_definition", "signature": "_rx_thread_fct(self, robot_socket: socket.socket, rx_queue: queue.Queue)", "docstring": "Handle received data on the socket.\n\n        Parameters\n        ----------\n        robot_socket : socket\n            Socket to use for receiving data.\n\n        rx_queue : queue\n            Thread-safe queue to push complete messages onto.\n\n        logger : logger instance\n            Logger to use.", "chunk_size_bytes": 1178, "original_size_bytes": 1696, "start_byte": 38639, "end_byte": 40335}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:9d43e78c25c8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_tx_thread_fct", "qualified_name": "_Robot._tx_thread_fct", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [972, 996], "text": "def _tx_thread_fct(self, robot_socket: socket.socket, tx_queue: queue.Queue):\n        \"\"\"Handle sending data on the socket.\n        Parameters\n        ----------\n        robot_socket : socket\n            Socket to use for sending data.\n        tx_queue : queue\n            Thread-safe queue to get messages from.\n        logger : logger instance\n            Logger to use.\n        \"\"\"\n        while True:\n            command: str = tx_queue.get(block=True)\n            if command == _TERMINATE:\n                return\n            else:\n                self.logger.debug(f'Socket Tx - Command: {command}')\n                robot_socket.sendall((command + '\\0').encode('ascii'))", "hash": "9d43e78c25c8", "chunk_type": "method", "node_type": "function_definition", "signature": "_tx_thread_fct(self, robot_socket: socket.socket, tx_queue: queue.Queue)", "docstring": "Handle sending data on the socket.\n\n        Parameters\n        ----------\n        robot_socket : socket\n            Socket to use for sending data.\n\n        tx_queue : queue\n            Thread-safe queue to get messages from.\n\n        logger : logger instance\n            Logger to use.", "chunk_size_bytes": 675, "original_size_bytes": 818, "start_byte": 40341, "end_byte": 41159}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:13ba8138edbf", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_connect_socket", "qualified_name": "_Robot._connect_socket", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [999, 1025], "text": "def _connect_socket(logger: logging.Logger, address: str, port: int, socket_timeout=1.0) -> socket.socket:\n        \"\"\"Connects to an arbitrary socket.\n        Parameters\n        ----------\n        logger : logger instance\n            Logger to use.\n        address : string\n            Address to use.\n        port : int\n            Port number to use.\n        socket_timeout: seconds\n            Time allocated (in seconds) to connect to robot\n        Returns\n        -------\n        new_socket : socket object\n            Successfully-connected socket object.\n        \"\"\"\n        logger.debug(f'Attempting to connect to {address}:{port}')\n        new_socket: socket.socket = socket_connect_loop(address, port, socket_timeout)\n        new_socket.settimeout(socket_timeout)\n        return new_socket", "hash": "13ba8138edbf", "chunk_type": "method", "node_type": "function_definition", "signature": "_connect_socket(logger: logging.Logger, address: str, port: int, socket_timeout=1.0)", "docstring": "Connects to an arbitrary socket.\n\n        Parameters\n        ----------\n        logger : logger instance\n            Logger to use.\n        address : string\n            Address to use.\n        port : int\n            Port number to use.\n        socket_timeout: seconds\n            Time allocated (in seconds) to connect to robot\n\n        Returns\n        -------\n        new_socket : socket object\n            Successfully-connected socket object.", "chunk_size_bytes": 799, "original_size_bytes": 839, "start_byte": 41183, "end_byte": 42022}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:cce66ab4e941", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_callbacks", "qualified_name": "_Robot._handle_callbacks", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1027, 1065], "text": "def _handle_callbacks(self, polling=False):\n        \"\"\"Runs callbacks found in callback_queue.\"\"\"\n        is_connected = True\n        while True:\n            if polling and self._callback_queue.qsize() == 0:\n                return\n            try:\n                callback_name, data = self._callback_queue.get(block=True, timeout=0.1)\n            except Exception:\n                if is_connected:\n                    is_connected = self.IsConnected()\n                    continue\n                else:\n                    break\n            if callback_name == _TERMINATE:\n                return\n            callback_function = self._robot_callbacks.__dict__[callback_name]\n            if callback_function is not None:\n                if data is not None:\n                    callback_function(data)\n                else:\n                    callback_function()", "hash": "cce66ab4e941", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_callbacks(self, polling=False)", "docstring": "Runs callbacks found in callback_queue.", "chunk_size_bytes": 863, "original_size_bytes": 1780, "start_byte": 42028, "end_byte": 43808}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:6c8e56a6c500", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "RegisterCallbacks", "qualified_name": "_Robot.RegisterCallbacks", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1073, 1086], "text": "def RegisterCallbacks(self, callbacks: RobotCallbacks, run_callbacks_in_separate_thread: bool):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not isinstance(callbacks, RobotCallbacks):\n            raise TypeError('Callbacks object is not the appropriate class.')\n        if self.IsConnected():\n            raise InvalidStateError('Callbacks cannot be set if already connected.')\n        self._callback_queue = _CallbackQueue(callbacks)\n        self._robot_callbacks = callbacks\n        self._run_callbacks_in_separate_thread = run_callbacks_in_separate_thread", "hash": "6c8e56a6c500", "chunk_type": "method", "node_type": "function_definition", "signature": "RegisterCallbacks(self, callbacks: RobotCallbacks, run_callbacks_in_separate_thread: bool)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 591, "original_size_bytes": 766, "start_byte": 44122, "end_byte": 44888}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:3608cdb8508e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "RegisterCallback", "qualified_name": "_Robot.RegisterCallback", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1088, 1093], "text": "def RegisterCallback(self, callback_name: str, callback_method: Callable[[], None]):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not hasattr(self._robot_callbacks, callback_name):\n            raise ValueError(f'Unknown callback name {callback_name}')\n        setattr(self._robot_callbacks, callback_name, callback_method)\n        self._callback_queue.register(callback_name)", "hash": "3608cdb8508e", "chunk_type": "method", "node_type": "function_definition", "signature": "RegisterCallback(self, callback_name: str, callback_method: Callable[[], None])", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 408, "original_size_bytes": 408, "start_byte": 44894, "end_byte": 45302}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a3905787d117", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "UnregisterCallbacks", "qualified_name": "_Robot.UnregisterCallbacks", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1095, 1103], "text": "def UnregisterCallbacks(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        self._stop_callback_thread()\n        self._robot_callbacks = RobotCallbacks()\n        self._callback_queue = _CallbackQueue(self._robot_callbacks)\n        if not self.IsConnected():\n            self._run_callbacks_in_separate_thread = False\n            self._callback_thread = None", "hash": "a3905787d117", "chunk_type": "method", "node_type": "function_definition", "signature": "UnregisterCallbacks(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 387, "original_size_bytes": 388, "start_byte": 45308, "end_byte": 45696}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:13ed72cd004b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "UnregisterCallback", "qualified_name": "_Robot.UnregisterCallback", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1105, 1110], "text": "def UnregisterCallback(self, callback_name: str):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not hasattr(self._robot_callbacks, callback_name):\n            raise ValueError(f'Unknown callback name {callback_name}')\n        setattr(self._robot_callbacks, callback_name, None)\n        self._callback_queue.unregister(callback_name)", "hash": "13ed72cd004b", "chunk_type": "method", "node_type": "function_definition", "signature": "UnregisterCallback(self, callback_name: str)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 364, "original_size_bytes": 364, "start_byte": 45702, "end_byte": 46066}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:dc219dec162b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_start_callback_thread", "qualified_name": "_Robot._start_callback_thread", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1112, 1116], "text": "def _start_callback_thread(self):\n        if self._run_callbacks_in_separate_thread and self._callback_thread is None:\n            self._callback_thread = threading.Thread(target=self._handle_callbacks)\n            self._callback_thread.daemon = True  # Make sure thread does not prevent application from quitting\n            self._callback_thread.start()", "hash": "dc219dec162b", "chunk_type": "method", "node_type": "function_definition", "signature": "_start_callback_thread(self)", "docstring": null, "chunk_size_bytes": 355, "original_size_bytes": 355, "start_byte": 46072, "end_byte": 46427}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:1e12ad0de89b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_stop_callback_thread", "qualified_name": "_Robot._stop_callback_thread", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1118, 1123], "text": "def _stop_callback_thread(self):\n        if self._callback_thread:\n            self._callback_queue.put(_TERMINATE)\n            if self._callback_thread != threading.current_thread():\n                self._callback_thread.join(timeout=self.default_timeout)\n                self._callback_thread = None", "hash": "1e12ad0de89b", "chunk_type": "method", "node_type": "function_definition", "signature": "_stop_callback_thread(self)", "docstring": null, "chunk_size_bytes": 301, "original_size_bytes": 301, "start_byte": 46433, "end_byte": 46734}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:e003a5e18dba", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_Connect", "qualified_name": "_Robot._Connect", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1127, 1328], "text": "def _Connect(self,\n                 address: str = MX_DEFAULT_ROBOT_IP,\n                 enable_synchronous_mode: bool = False,\n                 disconnect_on_exception: bool = True,\n                 monitor_mode: bool = False,\n                 sidecar_mode: bool = False,\n                 offline_mode: bool = False,\n                 timeout: float = 1.0):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        try:\n            with self._main_lock:\n                if self.IsConnected():\n                    return  # Still connected -> Do nothing\n                if not isinstance(address, str):\n                    raise TypeError(f'Invalid IP address ({address}).')\n                self._enable_synchronous_mode = enable_synchronous_mode\n                self._disconnect_on_exception = disconnect_on_exception\n                self._offline_mode = offline_mode\n                self._sidecar_mode = sidecar_mode\n                self._monitor_mode = monitor_mode\n                self._reset_disconnect_attributes()\n                addr_port = address.split(':')\n                mode_str = \"monitoring mode\" if self._monitor_mode else \"control mode\"\n                if len(addr_port) > 1:\n                    self._port = int(addr_port[1])\n                    address = addr_port[0]\n                else:\n                    self._port = MX_ROBOT_TCP_PORT_FEED if self._monitor_mode else MX_ROBOT_TCP_PORT_CONTROL\n                if self._fw_update_reboot_timestamp == 0:  # Don't print this trace when reconnecting during update\n                    self.logger.info(f\"Connecting to robot {address}:{self._port} ({mode_str})\")\n                ipaddress.ip_address(address)\n                self._address = address\n                self._robot_status = RobotStatus()\n                self._robot_safety_status = RobotSafetyStatus()\n                self._robot_psu_inputs = RobotPowerSupplyInputs()\n                self._robot_collision_status = CollisionStatus()\n                self._first_robot_status_received = False\n                self._using_legacy_json_api = False\n                if not self._monitor_mode:\n                    self._initialize_command_socket(timeout)\n                    self._initialize_command_connection()\n                else:\n                    self._monitor_timeout_used = True\n                self._robot_events.clear_all()\n                self._robot_events.on_deactivated.set()\n                self._robot_events.on_error_reset.set()\n                self._robot_events.on_safety_stop_reset.set()\n                self._robot_events.on_safety_stop_resettable.set()\n                self._robot_events.on_safety_stop_state_change.set()\n                self._set_robot_operation_mode(MxRobotOperationMode.MX_ROBOT_OPERATION_MODE_AUTO)\n                self._set_reset_ready(False)\n                self._robot_events.on_pstop2_reset.set()\n                self._robot_events.on_pstop2_resettable.set()\n                self._robot_events.on_estop_reset.set()\n                self._robot_events.on_estop_resettable.set()\n                self._robot_events.on_motion_resumed.set()\n                self._set_brakes_engaged(True)\n                self._set_connection_watchdog_enabled(False)\n                self._robot_events.on_status_updated.set()\n                self._robot_events.on_network_config_updated.set()\n                self._robot_events.on_status_gripper_updated.set()\n                self._robot_events.on_external_tool_status_updated.set()\n                self._robot_events.on_gripper_state_updated.set()\n                self._robot_events.on_valve_state_updated.set()\n                self._robot_events.on_output_state_updated.set()\n                self._robot_events.on_input_state_updated.set()\n                self._robot_events.on_vacuum_state_updated.set()\n                self._robot_events.on_holding_part.set()\n                self._robot_events.on_released_part.set()\n                self._robot_events.on_vacuum_purge_done.set()\n                self._robot_events.on_io_status_updated.set()\n                self._robot_events.on_joints_updated.set()\n                self._robot_events.on_pose_updated.set()\n            if (self._robot_info.version.is_at_least(11, 1, 5) and (self._port == MX_ROBOT_TCP_PORT_CONTROL)):\n                self._send_custom_command('EnableJsonMode()',\n                                          expected_responses=None,\n                                          timeout=None,\n                                          skip_internal_check=True)\n            connect_to_monitoring_port = True\n            if not self._monitor_mode and self._robot_info.version.major >= 8:\n                can_query_robot_info = True\n                if not self._robot_info.rt_message_capable:\n                    self._send_custom_command('GetStatusRobot',\n                                              expected_responses=[mx_st.MX_ST_GET_STATUS_ROBOT],\n                                              timeout=self.default_timeout,\n                                              skip_internal_check=True)\n                    if self._robot_status.error_status:\n                        can_query_robot_info = False\n                if can_query_robot_info:\n                    self._send_custom_command('GetRobotSerial',\n                                              expected_responses=[mx_st.MX_ST_GET_ROBOT_SERIAL],\n                                              timeout=self.default_timeout,\n                                              skip_internal_check=True)\n                    full_version_response = self._send_custom_command('GetFwVersionFull',\n                                                                      [mx_st.MX_ST_GET_FW_VERSION_FULL],\n                                                                      timeout=self.default_timeout,\n                                                                      skip_internal_check=True)\n                    full_version = full_version_response.data\n                    self._robot_info.version.update_version(full_version)\n                    if self._robot_info.rt_message_capable:\n                        self._send_custom_command('GetRealTimeMonitoring',\n                                                  expected_responses=[mx_st.MX_ST_GET_REAL_TIME_MONITORING],\n                                                  timeout=self.default_timeout,\n                                                  skip_internal_check=True)\n                        monitoring_interval_response = self._send_custom_command(\n                            'GetMonitoringInterval',\n                            expected_responses=[mx_st.MX_ST_GET_MONITORING_INTERVAL],\n                            timeout=self.default_timeout,\n                            skip_internal_check=True)\n                        if isinstance(monitoring_interval_response, Message):\n                            self._monitoring_interval = float(f'{monitoring_interval_response.data}')\n                            self._monitoring_interval_to_restore = self._monitoring_interval\n                    if self._robot_info.rt_on_ctrl_port_capable:\n                        connect_to_monitoring_port = False  # We won't need to connect to monitoring port\n                        if self._sidecar_mode:\n                            pass\n                        else:\n                            if self._robot_info.sidecar_capable:\n                                self._send_custom_command('SetDictMonitoring(1,0)',\n                                                          expected_responses=None,\n                                                          timeout=None,\n                                                          skip_internal_check=True)\n                                self._send_custom_command('SetVariablesMonitoring(1)',\n                                                          expected_responses=None,\n                                                          timeout=None,\n                                                          skip_internal_check=True)\n                            self._send_custom_command('SetCtrlPortMonitoring(1)',\n                                                      expected_responses=[mx_st.MX_ST_GET_STATUS_ROBOT],\n                                                      timeout=self.default_timeout,\n                                                      skip_internal_check=True)\n                        self._monitor_timeout_used = True\n                    else:\n                        self._send_custom_command('GetStatusRobot',\n                                                  expected_responses=[mx_st.MX_ST_GET_STATUS_ROBOT],\n                                                  timeout=self.default_timeout,\n                                                  skip_internal_check=True)\n            if connect_to_monitoring_port:\n                with self._main_lock:\n                    self._initialize_monitoring_socket(timeout)\n                    self._initialize_monitoring_connection()\n            self._robot_info.ip_address = address\n            self.logger.info(f'{self._robot_info}')  # Note: This will print \"Connected to...\"\n            if self._robot_info.version.major < 8:\n                self.logger.warning('Python API not supported for firmware under version 8')\n            self._robot_events.on_connected.set()\n            self._callback_queue.put('on_connected')\n            self._start_callback_thread()\n        except Exception as e:\n            if self._fw_update_reboot_timestamp == 0:  # Don't print this trace when reconnecting during firmware update\n                self.logger.info(f'Failed to connect: {e}')\n            self._disconnect()\n            raise CommunicationError(e) from e", "hash": "e003a5e18dba", "chunk_type": "method", "node_type": "function_definition", "signature": "_Connect(self,\n                 address: str = MX_DEFAULT_ROBOT_IP,\n                 enable_synchronous_mode: bool = False,\n                 disconnect_on_exception: bool = True,\n                 monitor_mode: bool = False,\n                 sidecar_mode: bool = False,\n                 offline_mode: bool = False,\n                 timeout: float = 1.0)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 9755, "original_size_bytes": 11553, "start_byte": 46772, "end_byte": 58325}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8eab27e905eb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Disconnect", "qualified_name": "_Robot.Disconnect", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1330, 1337], "text": "def Disconnect(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self.IsConnected():\n            if self._fw_update_reboot_timestamp == 0:  # Don't print this trace when reconnecting during firmware update\n                self.logger.info('Disconnecting from the robot.')\n            self._disconnect()\n        else:\n            self.logger.debug('Ignoring Disconnect() called on a non-connected robot.')", "hash": "8eab27e905eb", "chunk_type": "method", "node_type": "function_definition", "signature": "Disconnect(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 439, "original_size_bytes": 439, "start_byte": 58331, "end_byte": 58770}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:523499696448", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_disconnect", "qualified_name": "_Robot._disconnect", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1339, 1384], "text": "def _disconnect(self):\n        \"\"\"\n        Internal function to disconnect Mecademic Robot object from the Mecademic robot and cleanup internal states.\n        \"\"\"\n        self._shut_down_queue_threads()\n        self._invalidate_interruptable_events(message=\"Ask to disconnect from the robot\")\n        with self._main_lock:\n            message = \"explicitly disconnected from the robot\"\n            self._shut_down_socket_threads()\n            self._invalidate_checkpoints(message, forced=True)\n            self._invalidate_interruptable_events_on_clear_motion(message)\n            self._reset_disconnect_attributes()\n            if self._command_socket is not None:\n                try:\n                    self._command_socket.close()\n                except Exception as e:\n                    self.logger.error(f'Error closing command socket: {e}')\n                self._command_socket = None\n            if self._monitor_socket is not None:\n                try:\n                    self._monitor_socket.close()\n                except Exception as e:\n                    self.logger.error(f'Error closing monitoring socket: {e}')\n                self._monitor_socket = None\n            self._robot_events.on_connected.clear()\n            self._robot_events.on_disconnected.set()\n            self._callback_queue.put('on_disconnected')\n            self._robot_events.abort_all(message=message)\n        self._stop_callback_thread()", "hash": "523499696448", "chunk_type": "method", "node_type": "function_definition", "signature": "_disconnect(self)", "docstring": "Internal function to disconnect Mecademic Robot object from the Mecademic robot and cleanup internal states.", "chunk_size_bytes": 1432, "original_size_bytes": 1978, "start_byte": 58776, "end_byte": 60754}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ba5c3f2aaed2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "IsConnected", "qualified_name": "_Robot.IsConnected", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1386, 1398], "text": "def IsConnected(self) -> bool:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._robot_events.on_connected.is_set():\n            try:\n                self._check_internal_states(refresh_monitoring_mode=True)\n                return True\n            except Exception:\n                if not self._fw_update_status.in_progress:\n                    self.logger.info('Connection to robot was lost.')\n                return False\n        else:\n            return False", "hash": "ba5c3f2aaed2", "chunk_type": "method", "node_type": "function_definition", "signature": "IsConnected(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 496, "original_size_bytes": 549, "start_byte": 60760, "end_byte": 61309}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:3db7f89a1b36", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "IsControlling", "qualified_name": "_Robot.IsControlling", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1400, 1404], "text": "def IsControlling(self) -> bool:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not self.IsConnected() or self._monitor_mode:\n            return False\n        return True", "hash": "3db7f89a1b36", "chunk_type": "method", "node_type": "function_definition", "signature": "IsControlling(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 201, "original_size_bytes": 201, "start_byte": 61315, "end_byte": 61516}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8eece23b2587", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "IsSynchronousMode", "qualified_name": "_Robot.IsSynchronousMode", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1406, 1410], "text": "def IsSynchronousMode(self) -> bool:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not self.IsConnected() or not self._enable_synchronous_mode:\n            return False\n        return True", "hash": "8eece23b2587", "chunk_type": "method", "node_type": "function_definition", "signature": "IsSynchronousMode(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 220, "original_size_bytes": 220, "start_byte": 61522, "end_byte": 61742}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:07702392ead7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ConnectionWatchdog", "qualified_name": "_Robot.ConnectionWatchdog", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1412, 1423], "text": "def ConnectionWatchdog(self, timeout: float, message: Optional[str] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            if message is not None and self._robot_info.version.is_at_least(11, 1):\n                watchdog_ags = {\n                    MX_JSON_KEY_CONNECTION_WATCHDOG_TIMEOUT: timeout,\n                    MX_JSON_KEY_CONNECTION_WATCHDOG_MESSAGE: message\n                }\n                self._send_json_command('-ConnectionWatchdog', watchdog_ags)\n            else:\n                self._send_custom_command(f\"-ConnectionWatchdog({timeout})\")", "hash": "07702392ead7", "chunk_type": "method", "node_type": "function_definition", "signature": "ConnectionWatchdog(self, timeout: float, message: Optional[str] = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 619, "original_size_bytes": 653, "start_byte": 61748, "end_byte": 62401}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:990a61df587d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "AutoConnectionWatchdog", "qualified_name": "_Robot.AutoConnectionWatchdog", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1425, 1431], "text": "def AutoConnectionWatchdog(self, enable: bool, timeout: float = 0, message: Optional[str] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            if self._auto_connection_watchdog and not enable:\n                self.ConnectionWatchdog(timeout, message)\n            self._auto_connection_watchdog = enable", "hash": "990a61df587d", "chunk_type": "method", "node_type": "function_definition", "signature": "AutoConnectionWatchdog(self, enable: bool, timeout: float = 0, message: Optional[str] = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 367, "original_size_bytes": 458, "start_byte": 62407, "end_byte": 62865}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:70b029734ce3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ActivateRobot", "qualified_name": "_Robot.ActivateRobot", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1434, 1441], "text": "def ActivateRobot(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('ActivateRobot')\n        if self._enable_synchronous_mode:\n            self.WaitActivated()", "hash": "70b029734ce3", "chunk_type": "method", "node_type": "function_definition", "signature": "ActivateRobot(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 286, "original_size_bytes": 287, "start_byte": 62910, "end_byte": 63197}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:794aa3175b9b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sending_ActivateRobot", "qualified_name": "_Robot._sending_ActivateRobot", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1444, 1447], "text": "def _sending_ActivateRobot(self, args: list[str]):\n        \"\"\" This function updates internal states when sending ActivateRobot command to the robot \"\"\"\n        self._robot_events.on_activated.clear_abort()\n        self._robot_events.on_homed.clear_abort()", "hash": "794aa3175b9b", "chunk_type": "method", "node_type": "function_definition", "signature": "_sending_ActivateRobot(self, args: list[str])", "docstring": "This function updates internal states when sending ActivateRobot command to the robot", "chunk_size_bytes": 256, "original_size_bytes": 256, "start_byte": 63241, "end_byte": 63497}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f01d60adbc2c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "DeactivateRobot", "qualified_name": "_Robot.DeactivateRobot", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1449, 1456], "text": "def DeactivateRobot(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('DeactivateRobot')\n        if self._enable_synchronous_mode:\n            self.WaitDeactivated()", "hash": "f01d60adbc2c", "chunk_type": "method", "node_type": "function_definition", "signature": "DeactivateRobot(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 292, "original_size_bytes": 293, "start_byte": 63503, "end_byte": 63796}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f884243eb685", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Home", "qualified_name": "_Robot.Home", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1459, 1466], "text": "def Home(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('Home')\n        if self._enable_synchronous_mode:\n            self.WaitHomed()", "hash": "f884243eb685", "chunk_type": "method", "node_type": "function_definition", "signature": "Home(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 264, "original_size_bytes": 265, "start_byte": 63841, "end_byte": 64106}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b8a80966d113", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sending_Home", "qualified_name": "_Robot._sending_Home", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1469, 1471], "text": "def _sending_Home(self, args: list[str]):\n        \"\"\" This function updates internal states when sending Home command to the robot \"\"\"\n        self._robot_events.on_homed.clear_abort()", "hash": "b8a80966d113", "chunk_type": "method", "node_type": "function_definition", "signature": "_sending_Home(self, args: list[str])", "docstring": "This function updates internal states when sending Home command to the robot", "chunk_size_bytes": 184, "original_size_bytes": 184, "start_byte": 64150, "end_byte": 64334}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:5b94ce4bed25", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "PauseMotion", "qualified_name": "_Robot.PauseMotion", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1474, 1481], "text": "def PauseMotion(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('PauseMotion')\n        if self._enable_synchronous_mode:\n            self._robot_events.on_motion_paused.wait(timeout=self.default_timeout)", "hash": "5b94ce4bed25", "chunk_type": "method", "node_type": "function_definition", "signature": "PauseMotion(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 332, "original_size_bytes": 333, "start_byte": 64379, "end_byte": 64712}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ac8f7eef6327", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ResumeMotion", "qualified_name": "_Robot.ResumeMotion", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1484, 1491], "text": "def ResumeMotion(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('ResumeMotion')\n        if self._enable_synchronous_mode:\n            self.WaitMotionResumed(timeout=self.default_timeout)", "hash": "ac8f7eef6327", "chunk_type": "method", "node_type": "function_definition", "signature": "ResumeMotion(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 316, "original_size_bytes": 317, "start_byte": 64757, "end_byte": 65074}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:36e7e18fcaea", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ClearMotion", "qualified_name": "_Robot.ClearMotion", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1494, 1501], "text": "def ClearMotion(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('ClearMotion')\n        if self._enable_synchronous_mode:\n            self.WaitMotionCleared(timeout=self.default_timeout)", "hash": "36e7e18fcaea", "chunk_type": "method", "node_type": "function_definition", "signature": "ClearMotion(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 314, "original_size_bytes": 315, "start_byte": 65119, "end_byte": 65434}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:98fb64b28726", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sending_ClearMotion", "qualified_name": "_Robot._sending_ClearMotion", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1504, 1512], "text": "def _sending_ClearMotion(self, args: list[str]):\n        \"\"\" This function updates internal states when sending ClearMotion command to the robot \"\"\"\n        message = \"ClearMotion\"\n        self._clear_motion_requests += 1\n        self._robot_events.on_motion_cleared.clear()\n        self._invalidate_checkpoints(message, forced=False)\n        self._invalidate_interruptable_events_on_clear_motion(message)", "hash": "98fb64b28726", "chunk_type": "method", "node_type": "function_definition", "signature": "_sending_ClearMotion(self, args: list[str])", "docstring": "This function updates internal states when sending ClearMotion command to the robot", "chunk_size_bytes": 405, "original_size_bytes": 582, "start_byte": 65478, "end_byte": 66060}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ff0e53b527f1", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_monitoring_interval_internal", "qualified_name": "_Robot._set_monitoring_interval_internal", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1516, 1526], "text": "def _set_monitoring_interval_internal(self, t: float):\n        \"\"\"Sets the rate at which the monitoring port sends data.\n        Parameters\n        ----------\n        t : float\n            Monitoring interval duration in seconds.\n        \"\"\"\n        with self._main_lock:\n            self._send_command('SetMonitoringInterval', [t])", "hash": "ff0e53b527f1", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_monitoring_interval_internal(self, t: float)", "docstring": "Sets the rate at which the monitoring port sends data.\n\n        Parameters\n        ----------\n        t : float\n            Monitoring interval duration in seconds.", "chunk_size_bytes": 332, "original_size_bytes": 334, "start_byte": 66094, "end_byte": 66428}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:46b5049d83fb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sending_SetMonitoringInterval", "qualified_name": "_Robot._sending_SetMonitoringInterval", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1528, 1531], "text": "def _sending_SetMonitoringInterval(self, args: list[str]):\n        \"\"\" This function updates internal states when sending SetMonitoringInterval command to the robot \"\"\"\n        self._monitoring_interval = float(args[0])\n        self._refresh_auto_connection_watchdog(force=True)", "hash": "46b5049d83fb", "chunk_type": "method", "node_type": "function_definition", "signature": "_sending_SetMonitoringInterval(self, args: list[str])", "docstring": "This function updates internal states when sending SetMonitoringInterval command to the robot", "chunk_size_bytes": 278, "original_size_bytes": 278, "start_byte": 66434, "end_byte": 66712}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:455ea86dc9cc", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetStatusGripper", "qualified_name": "_Robot.GetStatusGripper", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1533, 1557], "text": "def GetStatusGripper(self, synchronous_update: bool = False, timeout: float = None) -> GripperStatus:\n        \"\"\"Return a copy of the current gripper status.\n           LEGACY. Use GetRtExtToolStatus and GetRtGripperState instead.\n        Parameters\n        ----------\n        synchronous_update: boolean\n            True -> Synchronously get updated gripper status. False -> Get latest known status.\n        timeout: float, defaults to DEFAULT_WAIT_TIMEOUT\n            Timeout (in seconds) waiting for synchronous response from the robot.\n        Returns\n        -------\n        GripperStatus\n            Object containing the current gripper status\n        \"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetStatusGripper', None, self._robot_events.on_status_gripper_updated, timeout)\n        with self._main_lock:\n            return copy.deepcopy(self._gripper_status)", "hash": "455ea86dc9cc", "chunk_type": "method", "node_type": "function_definition", "signature": "GetStatusGripper(self, synchronous_update: bool = False, timeout: float = None)", "docstring": "Return a copy of the current gripper status.\n           LEGACY. Use GetRtExtToolStatus and GetRtGripperState instead.\n\n        Parameters\n        ----------\n        synchronous_update: boolean\n            True -> Synchronously get updated gripper status. False -> Get latest known status.\n        timeout: float, defaults to DEFAULT_WAIT_TIMEOUT\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        GripperStatus\n            Object containing the current gripper status", "chunk_size_bytes": 966, "original_size_bytes": 1029, "start_byte": 66718, "end_byte": 67747}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ee76975a3c85", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitGripperMoveCompletion", "qualified_name": "_Robot.WaitGripperMoveCompletion", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1559, 1654], "text": "def WaitGripperMoveCompletion(self, timeout: Optional[float] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not self._robot_info.gripper_pos_ctrl_capable:\n            raise NotImplementedError(f\"Unsupported method for this firmware version\")\n        if timeout is not None and timeout <= 0:\n            raise ValueError(\"timeout must be None or a positive value\")\n        DEFAULT_START_MOVE_TIMEOUT = 0.2\n        DEFAULT_COMPLETE_MOVE_TIMEOUT = 5\n        if timeout is not None:\n            complete_move_timeout = timeout\n        else:\n            complete_move_timeout = DEFAULT_COMPLETE_MOVE_TIMEOUT\n        if not self._enable_synchronous_mode:\n            start_time = time.monotonic()\n            checkpoint = self._set_checkpoint_internal()\n            checkpoint.wait(complete_move_timeout)\n            complete_move_timeout -= (time.monotonic() - start_time)\n        start_move_timeout = DEFAULT_START_MOVE_TIMEOUT\n        if start_move_timeout > complete_move_timeout:\n            start_move_timeout = complete_move_timeout\n        holding_part_seen_false = not self._gripper_state_before_last_move.holding_part\n        pos_reached_seen_false = not self._gripper_state_before_last_move.target_pos_reached\n        current_time = time.monotonic()\n        start_time = current_time\n        timeout_time = start_time + start_move_timeout\n        waiting_move_start = True\n        while current_time < timeout_time:\n            wait_duration = timeout_time - current_time\n            self.logger.debug(f'WaitGripperMoveCompletion: Waiting for {wait_duration}s')\n            try:\n                self._robot_events.on_gripper_state_updated.wait(wait_duration)\n                with self._main_lock:\n                    gripper_state = self._gripper_state\n                    self._robot_events.on_gripper_state_updated.clear()\n                    self.logger.debug(f'WaitGripperMoveCompletion: New state is {str(gripper_state)}')\n                if waiting_move_start:\n                    if gripper_state.target_pos_reached:\n                        if pos_reached_seen_false:\n                            self.logger.debug(f'WaitGripperMoveCompletion: target_pos_reached')\n                            return\n                        if gripper_state.opened and not self._gripper_state_before_last_move.opened:\n                            self.logger.debug(f'WaitGripperMoveCompletion: now opened (was not)')\n                            return\n                        if gripper_state.closed and not self._gripper_state_before_last_move.closed:\n                            self.logger.debug(f'WaitGripperMoveCompletion: now closed (was not)')\n                            return\n                    if holding_part_seen_false and gripper_state.holding_part:\n                        self.logger.debug(f'WaitGripperMoveCompletion: holding_part')\n                        return\n                    if gripper_state.holding_part is False:\n                        self.logger.debug(f'WaitGripperMoveCompletion: holding_part_seen_false')\n                        holding_part_seen_false = True\n                    if gripper_state.target_pos_reached is False:\n                        self.logger.debug(f'WaitGripperMoveCompletion: pos_reached_seen_false')\n                        pos_reached_seen_false = True\n                else:\n                    if gripper_state.target_pos_reached or gripper_state.holding_part:\n                        self.logger.debug(f'WaitGripperMoveCompletion: move completed ')\n                        return\n            except TimeoutException:\n                if waiting_move_start:\n                    self.logger.debug(f'WaitGripperMoveCompletion: start_move_timeout reached')\n                    gripper_state = self._gripper_state\n                    if gripper_state.target_pos_reached or gripper_state.holding_part:\n                        self.logger.debug(\n                            f'WaitGripperMoveCompletion: start_move_timeout reached with no change detected')\n                        return\n                    waiting_move_start = False\n                    timeout_time = start_time + complete_move_timeout\n            current_time = time.monotonic()\n        if not gripper_state.target_pos_reached and not gripper_state.holding_part:\n            self.logger.warning(f'WaitGripperMoveCompletion: Timeout reached')\n            raise TimeoutException('Timeout while waiting for gripper to complete movement.')", "hash": "ee76975a3c85", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitGripperMoveCompletion(self, timeout: Optional[float] = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 4488, "original_size_bytes": 5501, "start_byte": 67753, "end_byte": 73254}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:0a9641345669", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GripperOpen", "qualified_name": "_Robot.GripperOpen", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1656, 1666], "text": "def GripperOpen(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        self._gripper_state_before_last_move = copy.deepcopy(self._gripper_state)\n        self._send_motion_command('GripperOpen')\n        if self._enable_synchronous_mode and self._robot_info.gripper_pos_ctrl_capable and self.GetRtExtToolStatus(\n        ).is_gripper():\n            gripper_state = self.GetRtGripperState(synchronous_update=True)\n            if gripper_state.opened and gripper_state.target_pos_reached:\n                return\n            self.WaitGripperMoveCompletion()", "hash": "0a9641345669", "chunk_type": "method", "node_type": "function_definition", "signature": "GripperOpen(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 578, "original_size_bytes": 579, "start_byte": 73260, "end_byte": 73839}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:802418394c0f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GripperClose", "qualified_name": "_Robot.GripperClose", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1668, 1678], "text": "def GripperClose(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        self._gripper_state_before_last_move = copy.deepcopy(self._gripper_state)\n        self._send_motion_command('GripperClose')\n        if self._enable_synchronous_mode and self._robot_info.gripper_pos_ctrl_capable and self.GetRtExtToolStatus(\n        ).is_gripper():\n            gripper_state = self.GetRtGripperState(synchronous_update=True)\n            if gripper_state.closed and gripper_state.target_pos_reached:\n                return\n            self.WaitGripperMoveCompletion()", "hash": "802418394c0f", "chunk_type": "method", "node_type": "function_definition", "signature": "GripperClose(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 580, "original_size_bytes": 581, "start_byte": 73845, "end_byte": 74426}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:4241b333c496", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "MoveGripper", "qualified_name": "_Robot.MoveGripper", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1680, 1694], "text": "def MoveGripper(self, target: Union[bool, float]):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if isinstance(target, bool):\n            if target:\n                self.GripperOpen()\n            else:\n                self.GripperClose()\n        else:\n            self._gripper_state_before_last_move = copy.deepcopy(self._gripper_state)\n            self._send_motion_command('MoveGripper', [target])\n            if self._enable_synchronous_mode:\n                rt_data = self.GetRobotRtData(synchronous_update=True)\n                if math.isclose(rt_data.rt_gripper_pos.data[0], target, abs_tol=0.1):\n                    return\n                self.WaitGripperMoveCompletion()", "hash": "4241b333c496", "chunk_type": "method", "node_type": "function_definition", "signature": "MoveGripper(self, target: Union[bool, float])", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 708, "original_size_bytes": 708, "start_byte": 74432, "end_byte": 75140}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f5189d211bd9", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetOutputState", "qualified_name": "_Robot.SetOutputState", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1696, 1700], "text": "def SetOutputState(self, bank_id: MxIoBankId, *output_states: Union[MxDigitalIoState, int, str]):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        final_args = list(output_states)\n        final_args.insert(0, bank_id)\n        self._send_motion_command('SetOutputState', final_args)", "hash": "f5189d211bd9", "chunk_type": "method", "node_type": "function_definition", "signature": "SetOutputState(self, bank_id: MxIoBankId, *output_states: Union[MxDigitalIoState, int, str])", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 307, "original_size_bytes": 307, "start_byte": 75146, "end_byte": 75453}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:2c5fed6a25bc", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetOutputState_Immediate", "qualified_name": "_Robot.SetOutputState_Immediate", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1702, 1721], "text": "def SetOutputState_Immediate(self, bank_id: MxIoBankId, *output_states: Union[MxDigitalIoState, int, str]):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        send_now = True\n        desired_state = list(output_states)\n        if self._enable_synchronous_mode:\n            if self.IsDesiredIoState(bank_id, False, *desired_state):\n                send_now = False\n        if send_now:\n            final_args = copy.deepcopy(desired_state)\n            final_args.insert(0, bank_id)\n            self._send_immediate_command('SetOutputState_Immediate', final_args,\n                                         self._robot_events.on_output_state_updated)\n            if self._enable_synchronous_mode:\n                self.WaitIOState(bank_id, False, *desired_state, self.default_timeout)", "hash": "2c5fed6a25bc", "chunk_type": "method", "node_type": "function_definition", "signature": "SetOutputState_Immediate(self, bank_id: MxIoBankId, *output_states: Union[MxDigitalIoState, int, str])", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 803, "original_size_bytes": 1278, "start_byte": 75459, "end_byte": 76737}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b87a4e467330", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitForAnyCheckpoint", "qualified_name": "_Robot.WaitForAnyCheckpoint", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1723, 1732], "text": "def WaitForAnyCheckpoint(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if '*' not in self._internal_checkpoints:\n                self._internal_checkpoints['*'] = list()\n            event = InterruptableEvent()\n            self._internal_checkpoints['*'].append(event)\n        event.wait(timeout=timeout)", "hash": "b87a4e467330", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitForAnyCheckpoint(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 439, "original_size_bytes": 440, "start_byte": 76743, "end_byte": 77183}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:6005906ab769", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitConnected", "qualified_name": "_Robot.WaitConnected", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1734, 1739], "text": "def WaitConnected(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_connected.wait(timeout=timeout)", "hash": "6005906ab769", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitConnected(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 247, "original_size_bytes": 306, "start_byte": 77189, "end_byte": 77495}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c2e991d1300f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitDisconnected", "qualified_name": "_Robot.WaitDisconnected", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1741, 1759], "text": "def WaitDisconnected(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        start_time = time.monotonic()\n        while True:\n            try:\n                if self.IsConnected():\n                    self._robot_events.on_disconnected.wait(timeout=0.1)\n                else:\n                    break\n            except TimeoutException as e:\n                if time.monotonic() - start_time > timeout:\n                    raise e\n                pass\n            except Exception as e:\n                raise e", "hash": "c2e991d1300f", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitDisconnected(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 633, "original_size_bytes": 765, "start_byte": 77501, "end_byte": 78266}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8b66f896feb9", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitActivated", "qualified_name": "_Robot.WaitActivated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1761, 1769], "text": "def WaitActivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            if robot_model_is_mg2(self.GetRobotInfo().robot_model):\n                timeout = 5.0\n            else:\n                timeout = 30.0\n        self._robot_events.on_activated.wait(timeout=timeout)", "hash": "8b66f896feb9", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitActivated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 351, "original_size_bytes": 410, "start_byte": 78272, "end_byte": 78682}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c982db9763cd", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitDeactivated", "qualified_name": "_Robot.WaitDeactivated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1771, 1776], "text": "def WaitDeactivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_deactivated.wait(timeout=timeout)", "hash": "c982db9763cd", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitDeactivated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 251, "original_size_bytes": 310, "start_byte": 78688, "end_byte": 78998}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f28824100231", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitHomed", "qualified_name": "_Robot.WaitHomed", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1778, 1786], "text": "def WaitHomed(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            if robot_model_is_mg2(self.GetRobotInfo().robot_model):\n                timeout = 5.0\n            else:\n                timeout = 40.0\n        self._robot_events.on_homed.wait(timeout=timeout)", "hash": "f28824100231", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitHomed(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 343, "original_size_bytes": 402, "start_byte": 79004, "end_byte": 79406}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:553cff08b575", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitSimActivated", "qualified_name": "_Robot.WaitSimActivated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1788, 1793], "text": "def WaitSimActivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_activate_sim.wait(timeout=timeout)", "hash": "553cff08b575", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitSimActivated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 253, "original_size_bytes": 312, "start_byte": 79412, "end_byte": 79724}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f9780cc9fa1b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitSimDeactivated", "qualified_name": "_Robot.WaitSimDeactivated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1795, 1800], "text": "def WaitSimDeactivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_deactivate_sim.wait(timeout=timeout)", "hash": "f9780cc9fa1b", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitSimDeactivated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 257, "original_size_bytes": 316, "start_byte": 79730, "end_byte": 80046}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ba3c0ea332a3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitExtToolSimActivated", "qualified_name": "_Robot.WaitExtToolSimActivated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1802, 1807], "text": "def WaitExtToolSimActivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_activate_ext_tool_sim.wait(timeout=timeout)", "hash": "ba3c0ea332a3", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitExtToolSimActivated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 269, "original_size_bytes": 328, "start_byte": 80052, "end_byte": 80380}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:457cb1da70a4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitExtToolSimDeactivated", "qualified_name": "_Robot.WaitExtToolSimDeactivated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1809, 1814], "text": "def WaitExtToolSimDeactivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_deactivate_ext_tool_sim.wait(timeout=timeout)", "hash": "457cb1da70a4", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitExtToolSimDeactivated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 273, "original_size_bytes": 332, "start_byte": 80386, "end_byte": 80718}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:245d3287cdd5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitIoSimEnabled", "qualified_name": "_Robot.WaitIoSimEnabled", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1817, 1823], "text": "def WaitIoSimEnabled(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_io_sim_enabled.wait(timeout=timeout)", "hash": "245d3287cdd5", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitIoSimEnabled(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 313, "original_size_bytes": 373, "start_byte": 80762, "end_byte": 81135}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:50d826ae3296", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitIoSimDisabled", "qualified_name": "_Robot.WaitIoSimDisabled", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1826, 1832], "text": "def WaitIoSimDisabled(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_io_sim_disabled.wait(timeout=timeout)", "hash": "50d826ae3296", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitIoSimDisabled(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 315, "original_size_bytes": 375, "start_byte": 81179, "end_byte": 81554}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:0b66f53254ce", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "IsDesiredIoState", "qualified_name": "_Robot.IsDesiredIoState", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1834, 1868], "text": "def IsDesiredIoState(self, bank_id: MxIoBankId, is_input: bool, *args: Union[MxDigitalIoState, int, str]) -> bool:\n        \"\"\"See IsDesiredOutputState / IsDesiredInputState\n        \"\"\"\n        expected_states = list(args)\n        is_desired_state = True\n        with self._main_lock:\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                if is_input:\n                    curr_state = self._robot_rt_data.rt_io_module_inputs\n                else:\n                    curr_state = self._robot_rt_data.rt_io_module_outputs\n            elif bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                if is_input:\n                    curr_state = self._robot_rt_data.rt_sig_gen_inputs\n                else:\n                    curr_state = self._robot_rt_data.rt_sig_gen_outputs\n            else:\n                is_desired_state = False\n                curr_state = None\n            if curr_state is not None:\n                idx = 0\n                while idx < len(expected_states) and idx < len(curr_state.data):\n                    desired = expected_states[idx]\n                    if (desired == 0 or desired == MxDigitalIoState.MX_DIGITAL_IO_STATE_0\n                            or str(desired).lower() == 'off'):\n                        if curr_state.data[idx] != 0:\n                            is_desired_state = False\n                            break\n                    elif (desired == 1 or desired == MxDigitalIoState.MX_DIGITAL_IO_STATE_1\n                          or str(desired).lower() == 'on'):\n                        if curr_state.data[idx] != 1:\n                            is_desired_state = False\n                            break\n                    idx = idx + 1\n        return is_desired_state", "hash": "0b66f53254ce", "chunk_type": "method", "node_type": "function_definition", "signature": "IsDesiredIoState(self, bank_id: MxIoBankId, is_input: bool, *args: Union[MxDigitalIoState, int, str])", "docstring": "See IsDesiredOutputState / IsDesiredInputState", "chunk_size_bytes": 1740, "original_size_bytes": 1740, "start_byte": 81560, "end_byte": 83300}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f9d5e0b192a3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitIOState", "qualified_name": "_Robot.WaitIOState", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1870, 1891], "text": "def WaitIOState(self,\n                    bank_id: MxIoBankId,\n                    is_input: bool,\n                    *args: Union[MxDigitalIoState, int, str],\n                    timeout: float = None):\n        \"\"\"See WaitOutputState/WaitInputState\n        \"\"\"\n        expected_states = list(args)\n        if timeout is None:\n            timeout = self.default_timeout\n        start_wait = time.monotonic()\n        event = self._robot_events.on_input_state_updated if is_input else self._robot_events.on_output_state_updated\n        while not self.IsDesiredIoState(bank_id, is_input, *expected_states):\n            try:\n                event.wait(timeout=0.01)\n            except TimeoutException as e:\n                elapsed_ms = time.monotonic() - start_wait\n                if elapsed_ms > timeout:\n                    raise e\n            event.clear()", "hash": "f9d5e0b192a3", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitIOState(self,\n                    bank_id: MxIoBankId,\n                    is_input: bool,\n                    *args: Union[MxDigitalIoState, int, str],\n                    timeout: float = None)", "docstring": "See WaitOutputState/WaitInputState", "chunk_size_bytes": 858, "original_size_bytes": 897, "start_byte": 83306, "end_byte": 84203}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f21e2d01294a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitRecoveryMode", "qualified_name": "_Robot.WaitRecoveryMode", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1893, 1901], "text": "def WaitRecoveryMode(self, activated: bool, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if activated:\n            self._robot_events.on_activate_recovery_mode.wait(timeout=timeout)\n        else:\n            self._robot_events.on_deactivate_recovery_mode.wait(timeout=timeout)", "hash": "f21e2d01294a", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitRecoveryMode(self, activated: bool, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 401, "original_size_bytes": 460, "start_byte": 84209, "end_byte": 84669}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ee426cb1703d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitForError", "qualified_name": "_Robot.WaitForError", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1903, 1907], "text": "def WaitForError(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_error.wait(timeout=timeout)", "hash": "ee426cb1703d", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitForError(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 242, "original_size_bytes": 242, "start_byte": 84675, "end_byte": 84917}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c4eff0e14176", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitErrorReset", "qualified_name": "_Robot.WaitErrorReset", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1909, 1914], "text": "def WaitErrorReset(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_error_reset.wait(timeout=timeout)", "hash": "c4eff0e14176", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitErrorReset(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 250, "original_size_bytes": 309, "start_byte": 84923, "end_byte": 85232}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:88fea25a3460", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitPStop2ResetDeprecated", "qualified_name": "_Robot.WaitPStop2ResetDeprecated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1916, 1921], "text": "def WaitPStop2ResetDeprecated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_pstop2_reset.wait(timeout=timeout)", "hash": "88fea25a3460", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitPStop2ResetDeprecated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 262, "original_size_bytes": 321, "start_byte": 85238, "end_byte": 85559}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ac9ed299fe68", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitPStop2ResettableDeprecated", "qualified_name": "_Robot.WaitPStop2ResettableDeprecated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1923, 1928], "text": "def WaitPStop2ResettableDeprecated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_pstop2_resettable.wait(timeout=timeout)", "hash": "ac9ed299fe68", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitPStop2ResettableDeprecated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 272, "original_size_bytes": 331, "start_byte": 85565, "end_byte": 85896}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a4578c54716c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitEStopResetDeprecated", "qualified_name": "_Robot.WaitEStopResetDeprecated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1930, 1935], "text": "def WaitEStopResetDeprecated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_estop_reset.wait(timeout=timeout)", "hash": "a4578c54716c", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitEStopResetDeprecated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 260, "original_size_bytes": 319, "start_byte": 85902, "end_byte": 86221}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:3972a1bd1337", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitEStopResettableDeprecated", "qualified_name": "_Robot.WaitEStopResettableDeprecated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1937, 1942], "text": "def WaitEStopResettableDeprecated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_estop_resettable.wait(timeout=timeout)", "hash": "3972a1bd1337", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitEStopResettableDeprecated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 270, "original_size_bytes": 329, "start_byte": 86227, "end_byte": 86556}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a9b67333c66a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitSafetyStopReset", "qualified_name": "_Robot.WaitSafetyStopReset", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1944, 1949], "text": "def WaitSafetyStopReset(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_safety_stop_reset.wait(timeout=timeout)", "hash": "a9b67333c66a", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitSafetyStopReset(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 261, "original_size_bytes": 320, "start_byte": 86562, "end_byte": 86882}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:5b83eacc06dc", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitSafetyStopResettable", "qualified_name": "_Robot.WaitSafetyStopResettable", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1951, 1956], "text": "def WaitSafetyStopResettable(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_safety_stop_resettable.wait(timeout=timeout)", "hash": "5b83eacc06dc", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitSafetyStopResettable(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 271, "original_size_bytes": 330, "start_byte": 86888, "end_byte": 87218}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:7a73c11f95a7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitSafetyStopStateChange", "qualified_name": "_Robot.WaitSafetyStopStateChange", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1958, 1965], "text": "def WaitSafetyStopStateChange(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_safety_stop_state_change.clear()\n        self._robot_events.on_safety_stop_state_change.wait(timeout=timeout)", "hash": "7a73c11f95a7", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitSafetyStopStateChange(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 337, "original_size_bytes": 397, "start_byte": 87224, "end_byte": 87621}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:857196cb07df", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitMotionResumed", "qualified_name": "_Robot.WaitMotionResumed", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1967, 1972], "text": "def WaitMotionResumed(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_motion_resumed.wait(timeout=timeout)", "hash": "857196cb07df", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitMotionResumed(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 256, "original_size_bytes": 315, "start_byte": 87627, "end_byte": 87942}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:842f6f7afbcb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitMotionPaused", "qualified_name": "_Robot.WaitMotionPaused", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1974, 1979], "text": "def WaitMotionPaused(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_motion_paused.wait(timeout=timeout)", "hash": "842f6f7afbcb", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitMotionPaused(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 254, "original_size_bytes": 313, "start_byte": 87948, "end_byte": 88261}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:465fb091bd09", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitMotionCleared", "qualified_name": "_Robot.WaitMotionCleared", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1981, 1986], "text": "def WaitMotionCleared(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_motion_cleared.wait(timeout=timeout)", "hash": "465fb091bd09", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitMotionCleared(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 256, "original_size_bytes": 315, "start_byte": 88267, "end_byte": 88582}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:112404d71b5c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitEndOfCycle", "qualified_name": "_Robot.WaitEndOfCycle", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1988, 1996], "text": "def WaitEndOfCycle(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._robot_events.on_end_of_cycle.is_set():\n            self._robot_events.on_end_of_cycle.clear()\n        if timeout is None:\n            timeout = 2\n        self._robot_events.on_end_of_cycle.wait(timeout=timeout)", "hash": "112404d71b5c", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitEndOfCycle(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 343, "original_size_bytes": 403, "start_byte": 88588, "end_byte": 88991}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:dd1dede2f470", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "WaitIdle", "qualified_name": "_Robot.WaitIdle", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [1998, 2018], "text": "def WaitIdle(self, timeout: float = None, wait_rt_data=False):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            if self._robot_status.error_status:\n                raise InterruptException('Robot is in error')\n        checkpoint = self._set_checkpoint_internal()\n        start_time = time.monotonic()\n        checkpoint.wait(timeout=timeout)\n        end_time = time.monotonic()\n        if timeout:\n            remaining_timeout = timeout - (end_time - start_time)\n        else:\n            remaining_timeout = None\n        if remaining_timeout is None or remaining_timeout > 0:\n            self._robot_events.on_end_of_block.wait(timeout=remaining_timeout)\n        if wait_rt_data:\n            self.WaitEndOfCycle()", "hash": "dd1dede2f470", "chunk_type": "method", "node_type": "function_definition", "signature": "WaitIdle(self, timeout: float = None, wait_rt_data=False)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 775, "original_size_bytes": 841, "start_byte": 88997, "end_byte": 89838}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:73e61b7e4303", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ResetError", "qualified_name": "_Robot.ResetError", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2020, 2027], "text": "def ResetError(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('ResetError')\n        if self._enable_synchronous_mode:\n            self._robot_events.on_error_reset.wait(timeout=self.default_timeout)", "hash": "73e61b7e4303", "chunk_type": "method", "node_type": "function_definition", "signature": "ResetError(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 328, "original_size_bytes": 329, "start_byte": 89844, "end_byte": 90173}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:9464d5574b16", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ResetPStop2Deprecated", "qualified_name": "_Robot.ResetPStop2Deprecated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2029, 2043], "text": "def ResetPStop2Deprecated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if self._robot_info.version.is_at_least(9, 2):\n                self._send_command('ResetPStop2')\n            else:\n                self._send_command('ResetPStop')\n        if self._enable_synchronous_mode:\n            if timeout is None:\n                timeout = 2\n            self._robot_events.on_motion_resumed.wait(timeout)", "hash": "9464d5574b16", "chunk_type": "method", "node_type": "function_definition", "signature": "ResetPStop2Deprecated(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 535, "original_size_bytes": 657, "start_byte": 90179, "end_byte": 90836}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c2a85183cb06", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Delay", "qualified_name": "_Robot.Delay", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2045, 2056], "text": "def Delay(self, t: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if not self._robot_events.on_homed.is_set():\n                raise InvalidStateError('This command requires robot to be homed.')\n            self._send_command('Delay', [t])\n            if self._enable_synchronous_mode:\n                checkpoint = self._set_checkpoint_internal()\n        if self._enable_synchronous_mode:\n            checkpoint.wait()", "hash": "c2a85183cb06", "chunk_type": "method", "node_type": "function_definition", "signature": "Delay(self, t: float)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 530, "original_size_bytes": 531, "start_byte": 90842, "end_byte": 91373}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b6763725e006", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "VacuumGripReleaseImmediate", "qualified_name": "_Robot.VacuumGripReleaseImmediate", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2058, 2084], "text": "def VacuumGripReleaseImmediate(self, release: bool):\n        \"\"\"See VacuumGrip_Immediate/VacuumRelease_Immediate\"\"\"\n        expected_vacuum_on = False if release else True\n        if self._enable_synchronous_mode and self._vacuum_state.vacuum_on == expected_vacuum_on:\n            return\n        else:\n            if release:\n                self._send_immediate_command('VacuumRelease_Immediate', None,\n                                             self._robot_events.on_vacuum_state_updated)\n            else:\n                self._send_immediate_command('VacuumGrip_Immediate', None, self._robot_events.on_vacuum_state_updated)\n            if self._enable_synchronous_mode:\n                start_wait = time.monotonic()\n                while self._vacuum_state.vacuum_on != expected_vacuum_on:\n                    try:\n                        self._robot_events.on_vacuum_state_updated.wait(timeout=self.default_timeout)\n                    except TimeoutException as e:\n                        elapsed_sec = time.monotonic() - start_wait\n                        if elapsed_sec > self.default_timeout:\n                            raise e\n                    self._robot_events.on_vacuum_state_updated.clear()", "hash": "b6763725e006", "chunk_type": "method", "node_type": "function_definition", "signature": "VacuumGripReleaseImmediate(self, release: bool)", "docstring": "See VacuumGrip_Immediate/VacuumRelease_Immediate", "chunk_size_bytes": 1210, "original_size_bytes": 1714, "start_byte": 91379, "end_byte": 93093}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d49d16e17543", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "StartProgram", "qualified_name": "_Robot.StartProgram", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2086, 2096], "text": "def StartProgram(self, n: int | str, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('StartProgram', [n])\n        if self._enable_synchronous_mode:\n            try:\n                self._robot_events.on_offline_program_started.wait(timeout=timeout)\n            except InterruptException as e:\n                raise InvalidStateError(str(e)) from e", "hash": "d49d16e17543", "chunk_type": "method", "node_type": "function_definition", "signature": "StartProgram(self, n: int | str, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 493, "original_size_bytes": 494, "start_byte": 93099, "end_byte": 93593}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:df5ca2d9d53d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sending_StartProgram", "qualified_name": "_Robot._sending_StartProgram", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2098, 2100], "text": "def _sending_StartProgram(self, args: list[str]):\n        \"\"\" This function updates internal states when sending StartProgram command to the robot \"\"\"\n        self._robot_events.on_offline_program_started.clear()", "hash": "df5ca2d9d53d", "chunk_type": "method", "node_type": "function_definition", "signature": "_sending_StartProgram(self, args: list[str])", "docstring": "This function updates internal states when sending StartProgram command to the robot", "chunk_size_bytes": 212, "original_size_bytes": 212, "start_byte": 93599, "end_byte": 93811}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:2b3607abdb56", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ListFiles", "qualified_name": "_Robot.ListFiles", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2102, 2124], "text": "def ListFiles(self, timeout: float = None) -> dict:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = OFFLINE_PROGRAM_OP_DEFAULT_TIMEOUT\n        with self._main_lock:\n            self._check_internal_states()\n            if self._robot_info.version.is_at_least(11, 1, 3):\n                self._send_command('ListFiles')\n            else:\n                self._send_command('ListPrograms')\n        try:\n            response = self._robot_events.on_file_op_done.wait(timeout=timeout)\n        except InterruptException as e:\n            raise InvalidStateError(str(e)) from e\n        data = response.json_data.get(MX_JSON_KEY_DATA, {})\n        if \"programs\" in data:\n            return data[\"programs\"]\n        elif \"files\" in data:\n            return data[\"files\"]\n        else:\n            return {}", "hash": "2b3607abdb56", "chunk_type": "method", "node_type": "function_definition", "signature": "ListFiles(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 865, "original_size_bytes": 925, "start_byte": 93817, "end_byte": 94742}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:edc850a60352", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sending_ListFiles", "qualified_name": "_Robot._sending_ListFiles", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2126, 2128], "text": "def _sending_ListFiles(self, args: list[str]):\n        \"\"\" This function updates internal states when sending ListFiles command to the robot \"\"\"\n        self._robot_events.on_file_op_done.clear()", "hash": "edc850a60352", "chunk_type": "method", "node_type": "function_definition", "signature": "_sending_ListFiles(self, args: list[str])", "docstring": "This function updates internal states when sending ListFiles command to the robot", "chunk_size_bytes": 195, "original_size_bytes": 195, "start_byte": 94748, "end_byte": 94943}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:9be8dfbac889", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "LoadFile", "qualified_name": "_Robot.LoadFile", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2130, 2149], "text": "def LoadFile(self, name: str, timeout: float = None) -> dict:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = OFFLINE_PROGRAM_OP_DEFAULT_TIMEOUT\n        with self._main_lock:\n            self._check_internal_states()\n            self._robot_events.on_file_op_done.clear()\n            json_data = {\"name\": name}\n            if self._robot_info.version.is_at_least(11, 1, 3):\n                self._send_json_command('LoadFile', json_data)\n            else:\n                self._send_json_command('LoadProgram', json_data)\n        try:\n            response = self._robot_events.on_file_op_done.wait(timeout=timeout)\n        except InterruptException as e:\n            raise InvalidStateError(str(e)) from e\n        return response.json_data.get(MX_JSON_KEY_DATA, {})", "hash": "9be8dfbac889", "chunk_type": "method", "node_type": "function_definition", "signature": "LoadFile(self, name: str, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 833, "original_size_bytes": 894, "start_byte": 94949, "end_byte": 95843}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f84b4e550c34", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sending_LoadFile", "qualified_name": "_Robot._sending_LoadFile", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2151, 2153], "text": "def _sending_LoadFile(self, args: list[str]):\n        \"\"\" This function updates internal states when sending LoadFile command to the robot \"\"\"\n        self._robot_events.on_file_op_done.clear()", "hash": "f84b4e550c34", "chunk_type": "method", "node_type": "function_definition", "signature": "_sending_LoadFile(self, args: list[str])", "docstring": "This function updates internal states when sending LoadFile command to the robot", "chunk_size_bytes": 193, "original_size_bytes": 193, "start_byte": 95849, "end_byte": 96042}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8fb814910e7d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SaveFile", "qualified_name": "_Robot.SaveFile", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2155, 2175], "text": "def SaveFile(self, name: str, content: str, timeout: float = None, allow_invalid=False, overwrite=False):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = OFFLINE_PROGRAM_OP_DEFAULT_TIMEOUT\n        with self._main_lock:\n            self._check_internal_states()\n            self._robot_events.on_file_op_done.clear()\n            if self._robot_info.version.is_at_least(11, 1, 3):\n                json_data = {\"name\": name, \"content\": content, \"allowInvalid\": allow_invalid, \"overwrite\": overwrite}\n                self._send_json_command('SaveFile', json_data)\n            else:\n                json_data = {\"name\": name, \"program\": content, \"allowInvalid\": allow_invalid, \"overwrite\": overwrite}\n                self._send_json_command('SaveProgram', json_data)\n        try:\n            self._robot_events.on_file_op_done.wait(timeout=timeout)\n        except InterruptException as e:\n            raise InvalidStateError(str(e)) from e", "hash": "8fb814910e7d", "chunk_type": "method", "node_type": "function_definition", "signature": "SaveFile(self, name: str, content: str, timeout: float = None, allow_invalid=False, overwrite=False)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 1003, "original_size_bytes": 1065, "start_byte": 96048, "end_byte": 97113}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:893d5b1e3d68", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sending_SaveFile", "qualified_name": "_Robot._sending_SaveFile", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2177, 2179], "text": "def _sending_SaveFile(self, args: list[str]):\n        \"\"\" This function updates internal states when sending SaveFile command to the robot \"\"\"\n        self._robot_events.on_file_op_done.clear()", "hash": "893d5b1e3d68", "chunk_type": "method", "node_type": "function_definition", "signature": "_sending_SaveFile(self, args: list[str])", "docstring": "This function updates internal states when sending SaveFile command to the robot", "chunk_size_bytes": 193, "original_size_bytes": 193, "start_byte": 97119, "end_byte": 97312}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ff00c2b1b50d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "DeleteFile", "qualified_name": "_Robot.DeleteFile", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2181, 2198], "text": "def DeleteFile(self, name: str, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = OFFLINE_PROGRAM_OP_DEFAULT_TIMEOUT\n        with self._main_lock:\n            self._check_internal_states()\n            json_data = {\"name\": name}\n            if self._robot_info.version.is_at_least(11, 1, 3):\n                self._send_json_command('DeleteFile', json_data)\n            else:\n                self._send_json_command('DeleteProgram', json_data)\n        try:\n            self._robot_events.on_file_op_done.wait(timeout=timeout)\n        except InterruptException as e:\n            raise InvalidStateError(str(e)) from e", "hash": "ff00c2b1b50d", "chunk_type": "method", "node_type": "function_definition", "signature": "DeleteFile(self, name: str, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 705, "original_size_bytes": 766, "start_byte": 97318, "end_byte": 98084}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:263ca854de80", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sending_DeleteFile", "qualified_name": "_Robot._sending_DeleteFile", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2200, 2202], "text": "def _sending_DeleteFile(self, args: list[str]):\n        \"\"\" This function updates internal states when sending DeleteFile command to the robot \"\"\"\n        self._robot_events.on_file_op_done.clear()", "hash": "263ca854de80", "chunk_type": "method", "node_type": "function_definition", "signature": "_sending_DeleteFile(self, args: list[str])", "docstring": "This function updates internal states when sending DeleteFile command to the robot", "chunk_size_bytes": 197, "original_size_bytes": 197, "start_byte": 98090, "end_byte": 98287}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f9b20ec6d05e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRtExtToolStatus", "qualified_name": "_Robot.GetRtExtToolStatus", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2204, 2220], "text": "def GetRtExtToolStatus(self,\n                           include_timestamp: bool = False,\n                           synchronous_update: bool = False,\n                           timeout: float = None) -> ExtToolStatus:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetRtExtToolStatus', None, self._robot_events.on_external_tool_status_updated,\n                                    timeout)\n        with self._main_lock:\n            if include_timestamp:\n                return copy.deepcopy(self._robot_rt_data.rt_external_tool_status)\n            else:\n                return copy.deepcopy(self._external_tool_status)", "hash": "f9b20ec6d05e", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRtExtToolStatus(self,\n                           include_timestamp: bool = False,\n                           synchronous_update: bool = False,\n                           timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 776, "original_size_bytes": 836, "start_byte": 98293, "end_byte": 99129}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d1a5cb9b28a4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetNetworkCfg", "qualified_name": "_Robot.GetNetworkCfg", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2222, 2232], "text": "def GetNetworkCfg(self, synchronous_update: bool = False, timeout: float = None) -> NetworkConfig:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetNetworkConfig', None, self._robot_events.on_network_config_updated, timeout)\n        with self._main_lock:\n            return copy.deepcopy(self._network_config)", "hash": "d1a5cb9b28a4", "chunk_type": "method", "node_type": "function_definition", "signature": "GetNetworkCfg(self, synchronous_update: bool = False, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 469, "original_size_bytes": 648, "start_byte": 99135, "end_byte": 99783}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:17709bc7afcb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRtIoStatus", "qualified_name": "_Robot.GetRtIoStatus", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2234, 2258], "text": "def GetRtIoStatus(self,\n                      bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                      include_timestamp: bool = False,\n                      synchronous_update: bool = False,\n                      timeout: float = None) -> IoStatus:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command(f'GetRtIoStatus({bank_id})', None, self._robot_events.on_io_status_updated, timeout)\n        with self._main_lock:\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                if include_timestamp:\n                    return copy.deepcopy(self._robot_rt_data.rt_io_module_status)\n                else:\n                    return copy.deepcopy(self._io_module_status)\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                if include_timestamp:\n                    return copy.deepcopy(self._robot_rt_data.rt_sig_gen_status)\n                else:\n                    return copy.deepcopy(self._sig_gen_status)\n            else:\n                raise MecademicException(\"Argument Error in Command : GetRtIoStatus\")", "hash": "17709bc7afcb", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRtIoStatus(self,\n                      bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                      include_timestamp: bool = False,\n                      synchronous_update: bool = False,\n                      timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 1228, "original_size_bytes": 1288, "start_byte": 99789, "end_byte": 101077}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a5ffba0cd769", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRtGripperState", "qualified_name": "_Robot.GetRtGripperState", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2260, 2275], "text": "def GetRtGripperState(self,\n                          include_timestamp: bool = False,\n                          synchronous_update: bool = False,\n                          timeout: float = None) -> GripperState:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetRtGripperState', None, self._robot_events.on_gripper_state_updated, timeout)\n        with self._main_lock:\n            if include_timestamp:\n                return copy.deepcopy(self._robot_rt_data.rt_gripper_state)\n            else:\n                return copy.deepcopy(self._gripper_state)", "hash": "a5ffba0cd769", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRtGripperState(self,\n                          include_timestamp: bool = False,\n                          synchronous_update: bool = False,\n                          timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 713, "original_size_bytes": 773, "start_byte": 101083, "end_byte": 101856}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d9fd83d4d20d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRtValveState", "qualified_name": "_Robot.GetRtValveState", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2277, 2292], "text": "def GetRtValveState(self,\n                        include_timestamp: bool = False,\n                        synchronous_update: bool = False,\n                        timeout: float = None) -> ValveState:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetRtValveState', None, self._robot_events.on_valve_state_updated, timeout)\n        with self._main_lock:\n            if include_timestamp:\n                return copy.deepcopy(self._robot_rt_data.rt_valve_state)\n            else:\n                return copy.deepcopy(self._valve_state)", "hash": "d9fd83d4d20d", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRtValveState(self,\n                        include_timestamp: bool = False,\n                        synchronous_update: bool = False,\n                        timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 695, "original_size_bytes": 755, "start_byte": 101862, "end_byte": 102617}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:4ef93648a9e6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRtOutputState", "qualified_name": "_Robot.GetRtOutputState", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2294, 2312], "text": "def GetRtOutputState(self,\n                         bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                         synchronous_update: bool = False,\n                         timeout: float = None) -> TimestampedData:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command(f'GetRtOutputState({bank_id})', None, self._robot_events.on_output_state_updated,\n                                    timeout)\n        with self._main_lock:\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                return copy.deepcopy(self._robot_rt_data.rt_io_module_outputs)\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                return copy.deepcopy(self._robot_rt_data.rt_sig_gen_outputs)\n            else:\n                return TimestampedData.zeros(0, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_UNAVAILABLE)", "hash": "4ef93648a9e6", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRtOutputState(self,\n                         bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                         synchronous_update: bool = False,\n                         timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 995, "original_size_bytes": 1055, "start_byte": 102623, "end_byte": 103678}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:08fae5d3b421", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRtInputState", "qualified_name": "_Robot.GetRtInputState", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2314, 2333], "text": "def GetRtInputState(self,\n                        bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                        synchronous_update: bool = False,\n                        timeout: float = None) -> TimestampedData:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command(f'GetRtInputState({bank_id})', None, self._robot_events.on_input_state_updated,\n                                    timeout)\n        with self._main_lock:\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                return copy.deepcopy(self._robot_rt_data.rt_io_module_inputs)\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                return copy.deepcopy(self._robot_rt_data.rt_sig_gen_inputs)\n            else:\n                return TimestampedData.zeros(0, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_UNAVAILABLE)", "hash": "08fae5d3b421", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRtInputState(self,\n                        bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                        synchronous_update: bool = False,\n                        timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 987, "original_size_bytes": 1048, "start_byte": 103684, "end_byte": 104732}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d960e8bf1079", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRtVacuumState", "qualified_name": "_Robot.GetRtVacuumState", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2335, 2350], "text": "def GetRtVacuumState(self,\n                         include_timestamp: bool = False,\n                         synchronous_update: bool = False,\n                         timeout: float = None) -> VacuumState:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command(f'GetRtVacuumState()', None, self._robot_events.on_vacuum_state_updated, timeout)\n        with self._main_lock:\n            if include_timestamp:\n                return copy.deepcopy(self._robot_rt_data.rt_vacuum_state)\n            else:\n                return copy.deepcopy(self._vacuum_state)", "hash": "d960e8bf1079", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRtVacuumState(self,\n                         include_timestamp: bool = False,\n                         synchronous_update: bool = False,\n                         timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 707, "original_size_bytes": 767, "start_byte": 104738, "end_byte": 105505}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:2ed3f38f8ab3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRtTargetJointPos", "qualified_name": "_Robot.GetRtTargetJointPos", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2352, 2377], "text": "def GetRtTargetJointPos(self,\n                            include_timestamp: bool = False,\n                            synchronous_update: bool = False,\n                            timeout: float = None) -> TimestampedData:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            if self._robot_info.rt_message_capable:\n                self._send_sync_command('GetRtTargetJointPos', None, self._robot_events.on_joints_updated, timeout)\n            else:\n                self._send_sync_command('GetJoints', None, self._robot_events.on_joints_updated, timeout)\n            self._robot_events.on_joints_updated.wait(timeout=timeout)\n        with self._main_lock:\n            if include_timestamp:\n                if not self._robot_info.rt_message_capable:\n                    raise InvalidStateError('Cannot provide timestamp with current robot firmware or model.')\n                else:\n                    return copy.deepcopy(self._robot_rt_data.rt_target_joint_pos)\n            return copy.deepcopy(self._robot_rt_data.rt_target_joint_pos.data)", "hash": "2ed3f38f8ab3", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRtTargetJointPos(self,\n                            include_timestamp: bool = False,\n                            synchronous_update: bool = False,\n                            timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 1172, "original_size_bytes": 1441, "start_byte": 105511, "end_byte": 106952}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ea8d0057e7ec", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRtTargetCartPos", "qualified_name": "_Robot.GetRtTargetCartPos", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2379, 2401], "text": "def GetRtTargetCartPos(self,\n                           include_timestamp: bool = False,\n                           synchronous_update: bool = False,\n                           timeout: float = None) -> TimestampedData:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            if self._robot_info.rt_message_capable:\n                self._send_sync_command('GetRtTargetCartPos', None, self._robot_events.on_pose_updated, timeout)\n            else:\n                self._send_sync_command('GetPose', None, self._robot_events.on_pose_updated, timeout)\n        with self._main_lock:\n            if include_timestamp:\n                if not self._robot_info.rt_message_capable:\n                    raise InvalidStateError('Cannot provide timestamp with current robot firmware or model.')\n                else:\n                    return copy.deepcopy(self._robot_rt_data.rt_target_cart_pos)\n            return copy.deepcopy(self._robot_rt_data.rt_target_cart_pos.data)", "hash": "ea8d0057e7ec", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRtTargetCartPos(self,\n                           include_timestamp: bool = False,\n                           synchronous_update: bool = False,\n                           timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 1088, "original_size_bytes": 1257, "start_byte": 106958, "end_byte": 108215}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:3f53fee4d516", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetMonitoringInterval", "qualified_name": "_Robot.SetMonitoringInterval", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2403, 2408], "text": "def SetMonitoringInterval(self, t: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._set_monitoring_interval_internal(t)\n            self._monitoring_interval_to_restore = t", "hash": "3f53fee4d516", "chunk_type": "method", "node_type": "function_definition", "signature": "SetMonitoringInterval(self, t: float)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 288, "original_size_bytes": 288, "start_byte": 108221, "end_byte": 108509}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:10fd932bde28", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetRealTimeMonitoring", "qualified_name": "_Robot.SetRealTimeMonitoring", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2410, 2418], "text": "def SetRealTimeMonitoring(self, *events: tuple):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if isinstance(events, tuple):\n                event_list = list(events)\n            else:\n                event_list = events\n            self._send_command('SetRealTimeMonitoring', event_list)", "hash": "10fd932bde28", "chunk_type": "method", "node_type": "function_definition", "signature": "SetRealTimeMonitoring(self, *events: tuple)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 393, "original_size_bytes": 393, "start_byte": 108515, "end_byte": 108908}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:81b8d8a5b112", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetRtc", "qualified_name": "_Robot.SetRtc", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2420, 2424], "text": "def SetRtc(self, t: int):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('SetRtc', [t])", "hash": "81b8d8a5b112", "chunk_type": "method", "node_type": "function_definition", "signature": "SetRtc(self, t: int)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 210, "original_size_bytes": 210, "start_byte": 108914, "end_byte": 109124}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:01b11286e0b6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ActivateSim", "qualified_name": "_Robot.ActivateSim", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2426, 2435], "text": "def ActivateSim(self, mode: Optional[MxRobotSimulationMode] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if mode is None:\n                self._send_command(f'ActivateSim()')\n            else:\n                self._send_command(f'ActivateSim({int(mode)})')\n        if self._enable_synchronous_mode:\n            self._robot_events.on_activate_sim.wait(timeout=self.default_timeout)", "hash": "01b11286e0b6", "chunk_type": "method", "node_type": "function_definition", "signature": "ActivateSim(self, mode: Optional[MxRobotSimulationMode] = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 495, "original_size_bytes": 495, "start_byte": 109130, "end_byte": 109625}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c888263881b3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "DeactivateSim", "qualified_name": "_Robot.DeactivateSim", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2437, 2443], "text": "def DeactivateSim(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('DeactivateSim')\n        if self._enable_synchronous_mode:\n            self._robot_events.on_deactivate_sim.wait(timeout=self.default_timeout)", "hash": "c888263881b3", "chunk_type": "method", "node_type": "function_definition", "signature": "DeactivateSim(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 337, "original_size_bytes": 337, "start_byte": 109631, "end_byte": 109968}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:3b99c6c0889c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetExtToolSim", "qualified_name": "_Robot.SetExtToolSim", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2445, 2459], "text": "def SetExtToolSim(self, sim_ext_tool_type: int = MxExtToolType.MX_EXT_TOOL_MEGP25_SHORT):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if sim_ext_tool_type != MxExtToolType.MX_EXT_TOOL_NONE and not self._robot_info.gripper_pos_ctrl_capable:\n            sim_ext_tool_type = 1\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('SetExtToolSim', [sim_ext_tool_type])\n        if self._enable_synchronous_mode:\n            if sim_ext_tool_type == MxExtToolType.MX_EXT_TOOL_NONE:\n                self.WaitExtToolSimDeactivated()\n            else:\n                self.WaitExtToolSimActivated()", "hash": "3b99c6c0889c", "chunk_type": "method", "node_type": "function_definition", "signature": "SetExtToolSim(self, sim_ext_tool_type: int = MxExtToolType.MX_EXT_TOOL_MEGP25_SHORT)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 669, "original_size_bytes": 740, "start_byte": 109974, "end_byte": 110714}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b8864228b635", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetIoSim", "qualified_name": "_Robot.SetIoSim", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2461, 2471], "text": "def SetIoSim(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, enable: bool = True):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('SetIoSim', [bank_id, 1 if enable else 0])\n        if self._enable_synchronous_mode:\n            if enable:\n                self.WaitIoSimEnabled(bank_id)\n            else:\n                self.WaitIoSimDisabled(bank_id)", "hash": "b8864228b635", "chunk_type": "method", "node_type": "function_definition", "signature": "SetIoSim(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, enable: bool = True)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 489, "original_size_bytes": 490, "start_byte": 110720, "end_byte": 111210}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a212b8fc1af2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetRecoveryMode", "qualified_name": "_Robot.SetRecoveryMode", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2473, 2483], "text": "def SetRecoveryMode(self, activated: bool = True):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('SetRecoveryMode', f'{1 if activated else 0}')\n        if self._enable_synchronous_mode:\n            if activated:\n                self._robot_events.on_activate_recovery_mode.wait(timeout=self.default_timeout)\n            else:\n                self._robot_events.on_deactivate_recovery_mode.wait(timeout=self.default_timeout)", "hash": "a212b8fc1af2", "chunk_type": "method", "node_type": "function_definition", "signature": "SetRecoveryMode(self, activated: bool = True)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 547, "original_size_bytes": 548, "start_byte": 111216, "end_byte": 111764}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c2d5d09713c7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetTimeScaling", "qualified_name": "_Robot.SetTimeScaling", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2485, 2492], "text": "def SetTimeScaling(self, p: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('SetTimeScaling', [p])\n        if self._enable_synchronous_mode:\n            self._robot_events.on_time_scaling_changed.wait(timeout=self.default_timeout)", "hash": "c2d5d09713c7", "chunk_type": "method", "node_type": "function_definition", "signature": "SetTimeScaling(self, p: float)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 360, "original_size_bytes": 361, "start_byte": 111770, "end_byte": 112131}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:86ed8042d1ae", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sending_SetTimeScaling", "qualified_name": "_Robot._sending_SetTimeScaling", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2494, 2496], "text": "def _sending_SetTimeScaling(self, args: list[str]):\n        \"\"\" This function updates internal states when sending SetTimeScaling command to the robot \"\"\"\n        self._robot_events.on_time_scaling_changed.clear()", "hash": "86ed8042d1ae", "chunk_type": "method", "node_type": "function_definition", "signature": "_sending_SetTimeScaling(self, args: list[str])", "docstring": "This function updates internal states when sending SetTimeScaling command to the robot", "chunk_size_bytes": 213, "original_size_bytes": 213, "start_byte": 112137, "end_byte": 112350}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:fc8d6cacb904", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetJointLimitsCfg", "qualified_name": "_Robot.SetJointLimitsCfg", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2498, 2509], "text": "def SetJointLimitsCfg(self, e: bool = True):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetJointLimitsCfg({1 if e else 0})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_JOINT_LIMITS_CFG, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetJointLimitsCfg\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetJointLimitsCfg', f\"{1 if e else 0}\")", "hash": "fc8d6cacb904", "chunk_type": "method", "node_type": "function_definition", "signature": "SetJointLimitsCfg(self, e: bool = True)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 750, "original_size_bytes": 750, "start_byte": 112356, "end_byte": 113106}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:2b19528a1c0b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetJointLimits", "qualified_name": "_Robot.SetJointLimits", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2511, 2522], "text": "def SetJointLimits(self, n: int, lower_limit: float, upper_limit: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetJointLimits({n},{lower_limit},{upper_limit})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_JOINT_LIMITS, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetJointLimits\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetJointLimits', f\"{n},{lower_limit},{upper_limit}\")", "hash": "2b19528a1c0b", "chunk_type": "method", "node_type": "function_definition", "signature": "SetJointLimits(self, n: int, lower_limit: float, upper_limit: float)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 798, "original_size_bytes": 798, "start_byte": 113112, "end_byte": 113910}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8a022d9215e9", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetWorkZoneCfg", "qualified_name": "_Robot.SetWorkZoneCfg", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2524, 2537], "text": "def SetWorkZoneCfg(self,\n                       severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR,\n                       mode: MxWorkZoneMode = MxWorkZoneMode.MX_WORK_ZONE_MODE_FCP_IN_WORK_ZONE):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetWorkZoneCfg({severity},{mode})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_WORK_ZONE_CFG, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetWorkZoneCfg\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetWorkZoneCfg', f\"{severity},{mode}\")", "hash": "8a022d9215e9", "chunk_type": "method", "node_type": "function_definition", "signature": "SetWorkZoneCfg(self,\n                       severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR,\n                       mode: MxWorkZoneMode = MxWorkZoneMode.MX_WORK_ZONE_MODE_FCP_IN_WORK_ZONE)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 912, "original_size_bytes": 912, "start_byte": 113916, "end_byte": 114828}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:fd96f1fde055", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetWorkZoneLimits", "qualified_name": "_Robot.SetWorkZoneLimits", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2539, 2550], "text": "def SetWorkZoneLimits(self, x_min: float, y_min: float, z_min: float, x_max: float, y_max: float, z_max: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetWorkZoneLimits({x_min}, {y_min}, {z_min}, {x_max}, {y_max}, {z_max})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_WORK_ZONE_LIMITS, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetWorkZoneLimits\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetWorkZoneLimits', [x_min, y_min, z_min, x_max, y_max, z_max])", "hash": "fd96f1fde055", "chunk_type": "method", "node_type": "function_definition", "signature": "SetWorkZoneLimits(self, x_min: float, y_min: float, z_min: float, x_max: float, y_max: float, z_max: float)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 879, "original_size_bytes": 879, "start_byte": 114834, "end_byte": 115713}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:68d6de87a013", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetCollisionCfg", "qualified_name": "_Robot.SetCollisionCfg", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2552, 2563], "text": "def SetCollisionCfg(self, severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetCollisionCfg({severity})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_COLLISION_CFG, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetCollisionCfg\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetCollisionCfg', f\"{severity}\")", "hash": "68d6de87a013", "chunk_type": "method", "node_type": "function_definition", "signature": "SetCollisionCfg(self, severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 782, "original_size_bytes": 782, "start_byte": 115719, "end_byte": 116501}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:70bf0b73b492", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetToolSphere", "qualified_name": "_Robot.SetToolSphere", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2565, 2576], "text": "def SetToolSphere(self, x: float, y: float, z: float, r: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetToolSphere({x}, {y}, {z}, {r})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_TOOL_SPHERE, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetToolSphere\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetToolSphere', [x, y, z, r])", "hash": "70bf0b73b492", "chunk_type": "method", "node_type": "function_definition", "signature": "SetToolSphere(self, x: float, y: float, z: float, r: float)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 750, "original_size_bytes": 750, "start_byte": 116507, "end_byte": 117257}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:7a45d98f876b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetTorqueLimitsCfg", "qualified_name": "_Robot.SetTorqueLimitsCfg", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2578, 2588], "text": "def SetTorqueLimitsCfg(\n            self,\n            severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR,\n            skip_acceleration: MxTorqueLimitsMode = MxTorqueLimitsMode.MX_TORQUE_LIMITS_MODE_DELTA_WITH_EXPECTED):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if isinstance(severity, str):\n            severity_int = TORQUE_LIMIT_SEVERITIES[severity]\n        else:\n            severity_int = severity\n        skip_acceleration_int = 1 if skip_acceleration else 0\n        self._send_motion_command('SetTorqueLimitsCfg', [severity_int, skip_acceleration_int])", "hash": "7a45d98f876b", "chunk_type": "method", "node_type": "function_definition", "signature": "SetTorqueLimitsCfg(\n            self,\n            severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR,\n            skip_acceleration: MxTorqueLimitsMode = MxTorqueLimitsMode.MX_TORQUE_LIMITS_MODE_DELTA_WITH_EXPECTED)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 610, "original_size_bytes": 610, "start_byte": 117263, "end_byte": 117873}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f305d42bb62b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetTorqueLimits", "qualified_name": "_Robot.SetTorqueLimits", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2590, 2597], "text": "def SetTorqueLimits(self, *args: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        expect_count = self._robot_info.num_joints\n        if len(args) != expect_count:\n            raise ValueError(\n                f'SetTorqueLimits: Incorrect number of joints sent {len(args)}, command. expecting: {expect_count}.')\n        self._send_motion_command('SetTorqueLimits', args)", "hash": "f305d42bb62b", "chunk_type": "method", "node_type": "function_definition", "signature": "SetTorqueLimits(self, *args: float)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 403, "original_size_bytes": 404, "start_byte": 117879, "end_byte": 118283}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:4d737d1281e6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetPStop2Cfg", "qualified_name": "_Robot.SetPStop2Cfg", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2599, 2610], "text": "def SetPStop2Cfg(self, severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_CLEAR_MOTION):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetPStop2Cfg({severity})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_PSTOP2_CFG, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetPStop2Cfg\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetPStop2Cfg', f\"{severity}\")", "hash": "4d737d1281e6", "chunk_type": "method", "node_type": "function_definition", "signature": "SetPStop2Cfg(self, severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_CLEAR_MOTION)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 774, "original_size_bytes": 774, "start_byte": 118289, "end_byte": 119063}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:81b242c11028", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetSimModeCfg", "qualified_name": "_Robot.SetSimModeCfg", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2612, 2623], "text": "def SetSimModeCfg(self, default_sim_mode=MxRobotSimulationMode.MX_SIM_MODE_REAL_TIME):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetSimModeCfg({default_sim_mode})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_SIM_MODE_CFG, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetSimModeCfg\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetSimModeCfg', f\"{default_sim_mode}\")", "hash": "81b242c11028", "chunk_type": "method", "node_type": "function_definition", "signature": "SetSimModeCfg(self, default_sim_mode=MxRobotSimulationMode.MX_SIM_MODE_REAL_TIME)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 782, "original_size_bytes": 782, "start_byte": 119069, "end_byte": 119851}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:09e8753cef10", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetPayload", "qualified_name": "_Robot.SetPayload", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2625, 2627], "text": "def SetPayload(self, mass: float, x: float, y: float, z: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        self._send_motion_command('SetPayload', [mass, x, y, z])", "hash": "09e8753cef10", "chunk_type": "method", "node_type": "function_definition", "signature": "SetPayload(self, mass: float, x: float, y: float, z: float)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 196, "original_size_bytes": 196, "start_byte": 119857, "end_byte": 120053}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:4464086669a2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ActivateBrakes", "qualified_name": "_Robot.ActivateBrakes", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2629, 2642], "text": "def ActivateBrakes(self, activated: bool = True):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if activated:\n                self._send_command('BrakesOn')\n            else:\n                self._send_command('BrakesOff')\n        if self._enable_synchronous_mode:\n            if activated:\n                self._robot_events.on_brakes_activated.wait(timeout=self.default_timeout)\n            else:\n                self._robot_events.on_brakes_deactivated.wait(timeout=self.default_timeout)", "hash": "4464086669a2", "chunk_type": "method", "node_type": "function_definition", "signature": "ActivateBrakes(self, activated: bool = True)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 595, "original_size_bytes": 596, "start_byte": 120059, "end_byte": 120655}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:24a249f63a6b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRobotInfo", "qualified_name": "_Robot.GetRobotInfo", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2644, 2647], "text": "def GetRobotInfo(self) -> RobotInfo:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            return copy.deepcopy(self._robot_info)", "hash": "24a249f63a6b", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRobotInfo(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 184, "original_size_bytes": 184, "start_byte": 120661, "end_byte": 120845}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:471e77cf8723", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetRobotRtData", "qualified_name": "_Robot.GetRobotRtData", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2649, 2655], "text": "def GetRobotRtData(self, synchronous_update: bool = False, timeout: float = None) -> RobotRtData:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if synchronous_update:\n            self.WaitEndOfCycle(timeout)\n        with self._main_lock:\n            return copy.deepcopy(self._robot_rt_data_stable)", "hash": "471e77cf8723", "chunk_type": "method", "node_type": "function_definition", "signature": "GetRobotRtData(self, synchronous_update: bool = False, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 327, "original_size_bytes": 328, "start_byte": 120851, "end_byte": 121179}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:6377c0612317", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetStatusRobot", "qualified_name": "_Robot.GetStatusRobot", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2657, 2669], "text": "def GetStatusRobot(self, synchronous_update: bool = False, timeout: float = None) -> RobotStatus:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            if self._using_legacy_json_api:\n                with self._main_lock:\n                    self._send_command('GetMotionStatus')\n            self._send_sync_command('GetStatusRobot', None, self._robot_events.on_status_updated, timeout)\n        with self._main_lock:\n            return copy.deepcopy(self._robot_status)", "hash": "6377c0612317", "chunk_type": "method", "node_type": "function_definition", "signature": "GetStatusRobot(self, synchronous_update: bool = False, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 596, "original_size_bytes": 656, "start_byte": 121185, "end_byte": 121841}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:50cf1a2d3f9e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetSafetyStatus", "qualified_name": "_Robot.GetSafetyStatus", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2671, 2680], "text": "def GetSafetyStatus(self, synchronous_update: bool = False, timeout: float = None) -> RobotSafetyStatus:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetStatusRobot', None, self._robot_events.on_status_updated, timeout)\n        with self._main_lock:\n            return copy.deepcopy(self._robot_safety_status)", "hash": "50cf1a2d3f9e", "chunk_type": "method", "node_type": "function_definition", "signature": "GetSafetyStatus(self, synchronous_update: bool = False, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 470, "original_size_bytes": 530, "start_byte": 121847, "end_byte": 122377}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:7ece67c81542", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetSidecarStatus", "qualified_name": "_Robot.GetSidecarStatus", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2682, 2706], "text": "def GetSidecarStatus(self,\n                         idx: Optional[int] = None,\n                         synchronous_update: bool = False,\n                         timeout: float = None) -> Optional[RobotSidecarStatus]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            pass\n        with self._main_lock:\n            if idx is None:\n                for sidecar_status in self._sidecar_status:\n                    if sidecar_status.embedded:\n                        return copy.deepcopy(sidecar_status)\n                if len(self._sidecar_status) > 0:\n                    return copy.deepcopy(self._sidecar_status[0])\n            elif idx < len(self._sidecar_status):\n                return copy.deepcopy(self._sidecar_status[idx])\n            return None", "hash": "7ece67c81542", "chunk_type": "method", "node_type": "function_definition", "signature": "GetSidecarStatus(self,\n                         idx: Optional[int] = None,\n                         synchronous_update: bool = False,\n                         timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 885, "original_size_bytes": 1247, "start_byte": 122383, "end_byte": 123630}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:61d3ce761881", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetPowerSupplyInputs", "qualified_name": "_Robot.GetPowerSupplyInputs", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2708, 2717], "text": "def GetPowerSupplyInputs(self, synchronous_update: bool = False, timeout: float = None) -> RobotPowerSupplyInputs:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetStatusRobot', None, self._robot_events.on_status_updated, timeout)\n        with self._main_lock:\n            return copy.deepcopy(self._robot_psu_inputs)", "hash": "61d3ce761881", "chunk_type": "method", "node_type": "function_definition", "signature": "GetPowerSupplyInputs(self, synchronous_update: bool = False, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 477, "original_size_bytes": 537, "start_byte": 123636, "end_byte": 124173}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a5784108fa78", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetCollisionStatus", "qualified_name": "_Robot.GetCollisionStatus", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2719, 2726], "text": "def GetCollisionStatus(self, timeout: float = None) -> CollisionStatus:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        with self._main_lock:\n            return copy.deepcopy(self._robot_collision_status)", "hash": "a5784108fa78", "chunk_type": "method", "node_type": "function_definition", "signature": "GetCollisionStatus(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 302, "original_size_bytes": 362, "start_byte": 124179, "end_byte": 124541}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:465e83e57f09", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetGripperRange", "qualified_name": "_Robot.GetGripperRange", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2728, 2741], "text": "def GetGripperRange(self, timeout: float = None) -> Tuple[float, float]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        response = self._send_custom_command('GetGripperRange',\n                                             expected_responses=[MxRobotStatusCode.MX_ST_GET_GRIPPER_RANGE],\n                                             timeout=self.default_timeout)\n        if isinstance(response, Message):\n            positions = string_to_numbers(response.data)\n            assert len(positions) == 2\n            return positions[0], positions[1]\n        return 0, 0", "hash": "465e83e57f09", "chunk_type": "method", "node_type": "function_definition", "signature": "GetGripperRange(self, timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 662, "original_size_bytes": 722, "start_byte": 124547, "end_byte": 125269}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c4591aebf186", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "LogTrace", "qualified_name": "_Robot.LogTrace", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2743, 2745], "text": "def LogTrace(self, trace: str, level: Optional[int] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        self._log_trace_common(trace, level)", "hash": "c4591aebf186", "chunk_type": "method", "node_type": "function_definition", "signature": "LogTrace(self, trace: str, level: Optional[int] = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 172, "original_size_bytes": 172, "start_byte": 125275, "end_byte": 125447}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b3b5fb947136", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_log_trace_common", "qualified_name": "_Robot._log_trace_common", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2747, 2768], "text": "def _log_trace_common(self,\n                          trace: str,\n                          level: Optional[int] = None,\n                          trace_id=MxUserTrace.MX_USER_TRACE_USER_LOG_TRACE):\n        \"\"\" Common to LogTrace and other similar functions \"\"\"\n        trace = trace.replace('\"', \"\")\n        if level is not None:\n            self.logger.log(level, f'{trace}\\033[39m')\n        if self.IsConnected():\n            if self._robot_info.version.is_at_least(9, 2):\n                if trace_id == MxUserTrace.MX_USER_TRACE_USER_LOG_TRACE:\n                    self._send_custom_command(f'-LogTrace(\"{trace}\")')\n                else:\n                    log_args = {MX_JSON_KEY_USER_LOG_TRACE_STR: trace, MX_JSON_KEY_USER_LOG_TRACE_ID: trace_id}\n                    if level == logging.ERROR:\n                        log_args[MX_JSON_KEY_USER_LOG_TRACE_LVL] = -2\n                    self._send_json_command('-LogTrace', log_args)\n            else:\n                self._send_custom_command(f'LogTrace(\"{trace}\")')", "hash": "b3b5fb947136", "chunk_type": "method", "node_type": "function_definition", "signature": "_log_trace_common(self,\n                          trace: str,\n                          level: Optional[int] = None,\n                          trace_id=MxUserTrace.MX_USER_TRACE_USER_LOG_TRACE)", "docstring": "Common to LogTrace and other similar functions", "chunk_size_bytes": 1021, "original_size_bytes": 1143, "start_byte": 125453, "end_byte": 126596}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:75ff23af2e86", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "StartLogging", "qualified_name": "_Robot.StartLogging", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2770, 2806], "text": "def StartLogging(self,\n                     monitoringInterval: float,\n                     file_name: str = None,\n                     file_path: str = None,\n                     fields: list = None,\n                     record_time: bool = True):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._file_logger is not None:\n            raise InvalidStateError('Another file logging operation is in progress.')\n        self._set_monitoring_interval_internal(monitoringInterval)\n        if self._robot_info.rt_message_capable:\n            if fields is None:\n                self.SetRealTimeMonitoring('all')\n            else:\n                self.SetRealTimeMonitoring(*fields)\n            self._send_custom_command('GetRealTimeMonitoring',\n                                      expected_responses=[MxRobotStatusCode.MX_ST_GET_REAL_TIME_MONITORING],\n                                      timeout=self.default_timeout,\n                                      skip_internal_check=True)\n            if not self._robot_info.rt_on_ctrl_port_capable:\n                self.WaitEndOfCycle()\n                time.sleep(0.01)\n                self.WaitEndOfCycle()\n        self._file_logger = mx_traj._RobotTrajectoryLogger(self._robot_info,\n                                                           self._robot_rt_data,\n                                                           fields,\n                                                           file_name=file_name,\n                                                           file_path=file_path,\n                                                           record_time=record_time,\n                                                           monitoring_interval=monitoringInterval)", "hash": "75ff23af2e86", "chunk_type": "method", "node_type": "function_definition", "signature": "StartLogging(self,\n                     monitoringInterval: float,\n                     file_name: str = None,\n                     file_path: str = None,\n                     fields: list = None,\n                     record_time: bool = True)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 1750, "original_size_bytes": 2086, "start_byte": 126602, "end_byte": 128688}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d65c33d74d98", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "EndLogging", "qualified_name": "_Robot.EndLogging", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2808, 2833], "text": "def EndLogging(self, keep_captured_trajectory: bool = False) -> str:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._file_logger is None:\n            raise InvalidStateError('No existing logger to stop.')\n        self._file_logger.stop_logging_commands()\n        if self._robot_info.rt_message_capable:\n            if self._monitoring_interval_to_restore != self._monitoring_interval:\n                self._set_monitoring_interval_internal(self._monitoring_interval_to_restore)\n            self._send_custom_command('GetRealTimeMonitoring',\n                                      expected_responses=[MxRobotStatusCode.MX_ST_GET_REAL_TIME_MONITORING],\n                                      timeout=self.default_timeout,\n                                      skip_internal_check=True)\n        if keep_captured_trajectory:\n            self._captured_trajectory = self._file_logger.robot_trajectories\n        file_name = self._file_logger.end_log()\n        self._file_logger = None\n        return file_name", "hash": "d65c33d74d98", "chunk_type": "method", "node_type": "function_definition", "signature": "EndLogging(self, keep_captured_trajectory: bool = False)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 1037, "original_size_bytes": 1286, "start_byte": 128694, "end_byte": 129980}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c72689def716", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetCapturedTrajectory", "qualified_name": "_Robot.GetCapturedTrajectory", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2835, 2837], "text": "def GetCapturedTrajectory(self) -> RobotTrajectories:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        return self._captured_trajectory", "hash": "c72689def716", "chunk_type": "method", "node_type": "function_definition", "signature": "GetCapturedTrajectory(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 161, "original_size_bytes": 161, "start_byte": 129986, "end_byte": 130147}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:6df5c53613f2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "UpdateRobot", "qualified_name": "_Robot.UpdateRobot", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2839, 2848], "text": "def UpdateRobot(self, firmware: Union[str, pathlib.Path], timeout: float = _UPDATE_TIMEOUT):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not self.IsConnected():\n            raise InvalidStateError('Not connected to the robot. Please call \"Connect\" before calling \"UpdateRobot\".')\n        try:\n            self._update_robot(firmware, timeout)\n        except Exception as e:\n            raise e\n        finally:\n            self._reset_fw_update_status()", "hash": "6df5c53613f2", "chunk_type": "method", "node_type": "function_definition", "signature": "UpdateRobot(self, firmware: Union[str, pathlib.Path], timeout: float = _UPDATE_TIMEOUT)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 487, "original_size_bytes": 487, "start_byte": 130153, "end_byte": 130640}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:af738ef51ed5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "CreateVariable", "qualified_name": "_Robot.CreateVariable", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2850, 2877], "text": "def CreateVariable(self,\n                       name: str,\n                       value: any,\n                       cyclic_id: Optional[int] = None,\n                       override: bool = False,\n                       timeout: float = None) -> bool:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode and timeout is None:\n            timeout = self.default_timeout\n        expected_responses: list[MxRobotStatusCode] = None\n        if timeout is not None:\n            expected_responses = [MxRobotStatusCode.MX_ST_CREATE_VARIABLE, MxRobotStatusCode.MX_ST_CREATE_VARIABLE_ERR]\n        json_data: dict = {\n            MX_JSON_KEY_VAR_NAME: name,\n            MX_JSON_KEY_VAR_VAL: value,\n            MX_JSON_KEY_VAR_CYCLIC_ID: cyclic_id,\n            MX_JSON_KEY_VAR_OVERRIDE: override\n        }\n        response = self._send_json_command(command='CreateVariable',\n                                           json_data=json_data,\n                                           expected_responses=expected_responses,\n                                           timeout=timeout)\n        if expected_responses is not None:\n            if response.id == MxRobotStatusCode.MX_ST_CREATE_VARIABLE_ERR:\n                raise ArgErrorException(f'Robot refused CreateVariable: {response.data}')", "hash": "af738ef51ed5", "chunk_type": "method", "node_type": "function_definition", "signature": "CreateVariable(self,\n                       name: str,\n                       value: any,\n                       cyclic_id: Optional[int] = None,\n                       override: bool = False,\n                       timeout: float = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 1332, "original_size_bytes": 1377, "start_byte": 130646, "end_byte": 132023}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:07d61a20548a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "DeleteVariable", "qualified_name": "_Robot.DeleteVariable", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2879, 2896], "text": "def DeleteVariable(self, name: str, timeout: Optional[float] = None) -> Optional[rsc.RegisteredVariable]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode and timeout is None:\n            timeout = self.default_timeout\n        expected_responses: list[MxRobotStatusCode] = None\n        if timeout is not None:\n            expected_responses = [MxRobotStatusCode.MX_ST_DELETE_VARIABLE, MxRobotStatusCode.MX_ST_DELETE_VARIABLE_ERR]\n        json_data: dict = {MX_JSON_KEY_VAR_NAME: name}\n        response = self._send_json_command(command='DeleteVariable',\n                                           json_data=json_data,\n                                           expected_responses=expected_responses,\n                                           timeout=timeout)\n        if expected_responses is not None:\n            if response.id == MxRobotStatusCode.MX_ST_DELETE_VARIABLE_ERR:\n                raise ArgErrorException(f'Robot refused DeleteVariable: {response.data}')", "hash": "07d61a20548a", "chunk_type": "method", "node_type": "function_definition", "signature": "DeleteVariable(self, name: str, timeout: Optional[float] = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 1026, "original_size_bytes": 1071, "start_byte": 132029, "end_byte": 133100}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a6f5928540bb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "SetVariable", "qualified_name": "_Robot.SetVariable", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2898, 2922], "text": "def SetVariable(self, name: str, value: any, timeout: Optional[float] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if isinstance(value, rsc.RegisteredVariable):\n            value = value.get_value()\n        if self._enable_synchronous_mode and timeout is None:\n            timeout = self.default_timeout\n        expected_responses: list[MxRobotStatusCode] = None\n        if timeout is not None:\n            expected_responses = [MxRobotStatusCode.MX_ST_SET_VARIABLE, MxRobotStatusCode.MX_ST_SET_VARIABLE_ERR]\n        json_data: dict = {\n            MX_JSON_KEY_VAR_NAME: name,\n            MX_JSON_KEY_VAR_VAL: value,\n        }\n        response = self._send_json_command('SetVariable',\n                                           json_data,\n                                           expected_responses=expected_responses,\n                                           timeout=timeout)\n        if expected_responses is not None:\n            if response.id == mx_st.MX_ST_SET_VARIABLE_ERR:\n                raise ArgErrorException(response.data)", "hash": "a6f5928540bb", "chunk_type": "method", "node_type": "function_definition", "signature": "SetVariable(self, name: str, value: any, timeout: Optional[float] = None)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 1077, "original_size_bytes": 1201, "start_byte": 133106, "end_byte": 134307}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8529fe6319b2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetVariable", "qualified_name": "_Robot.GetVariable", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2924, 2926], "text": "def GetVariable(self, name: str) -> Optional[rsc.RegisteredVariable]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        return self.vars.get(name)", "hash": "8529fe6319b2", "chunk_type": "method", "node_type": "function_definition", "signature": "GetVariable(self, name: str)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 171, "original_size_bytes": 171, "start_byte": 134313, "end_byte": 134484}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:da7233934d05", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetVariableByCyclicId", "qualified_name": "_Robot.GetVariableByCyclicId", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2928, 2933], "text": "def GetVariableByCyclicId(self, cyclic_id: int) -> Optional[rsc.RegisteredVariable]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        fct_or_var = self._registered_cyclic_id.get(cyclic_id, None)\n        if isinstance(fct_or_var, rsc.RegisteredVariable):\n            return fct_or_var\n        return None", "hash": "da7233934d05", "chunk_type": "method", "node_type": "function_definition", "signature": "GetVariableByCyclicId(self, cyclic_id: int)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 329, "original_size_bytes": 329, "start_byte": 134490, "end_byte": 134819}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:adbb0df3e979", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ListVariables", "qualified_name": "_Robot.ListVariables", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2935, 2937], "text": "def ListVariables(self) -> list[str]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        return list(self._registered_vars_by_name.keys())", "hash": "adbb0df3e979", "chunk_type": "method", "node_type": "function_definition", "signature": "ListVariables(self)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 162, "original_size_bytes": 162, "start_byte": 134825, "end_byte": 134987}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:28e4c1daabad", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_update_robot", "qualified_name": "_Robot._update_robot", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [2943, 3107], "text": "def _update_robot(self, firmware: Union[str, pathlib.Path], timeout: float = _UPDATE_TIMEOUT):\n        \"\"\"See documentation of UpdateRobot in robot.py\"\"\"\n        if isinstance(firmware, pathlib.Path):\n            firmware_file: pathlib.Path = firmware\n        elif isinstance(firmware, str):\n            firmware_file = pathlib.Path(firmware)\n        else:\n            raise ArgumentError(None,\n                                f'Unsupported firmware type. received: {type(firmware)}, expecting pathlib or str')\n        firmware_file_version = RobotVersion(firmware_file.name)\n        address = self._address\n        address_port = f'{address}:{self._port}'\n        if not self.IsConnected():\n            self._Connect(address=address)\n        elif self._monitor_mode:\n            self.logger.info(f'Connected to robot in monitoring mode only, attempting connection in command mode'\n                             'to deactivate robot')\n            self._Connect(address=address)\n        if robot_model_is_meca500(\n                self.GetRobotInfo().robot_model) and self.GetSafetyStatus(synchronous_update=True).estop_state:\n            raise MecademicException(\n                f'Firmware update failed: Robot is in ESTOP. Please clear the ESTOP condition before updating.')\n        use_legacy_update = not self.GetRobotInfo().version.is_at_least(9, 3, 0)\n        if self.GetStatusRobot().activation_state:\n            self.logger.info(f'Robot is activated, will attempt to deactivate before updating firmware')\n            self.DeactivateRobot()\n            self.WaitDeactivated()\n        if self._enable_synchronous_mode is None:\n            current_synchronous_mode = False\n        else:\n            current_synchronous_mode = self._enable_synchronous_mode\n        initial_disconnect_on_exception = self._disconnect_on_exception\n        self.Disconnect()\n        if not use_legacy_update:\n            self._Connect(address=f'{address}:{MX_ROBOT_TCP_PORT_CONTROL_JSON}')\n        self.logger.info(f\"Installing firmware: {firmware_file.resolve()}\")\n        with open(str(firmware_file), 'rb') as firmware_stream:\n            firmware_data = firmware_stream.read()\n            firmware_data_size = str(len(firmware_data))\n        headers = {\n            'Connection': 'keep-alive',\n            'Content-type': 'application/x-gzip',\n            'Content-Length': firmware_data_size\n        }\n        if use_legacy_update:\n            self.logger.info(f\"Uploading firmware (legacy mode)...\")\n            robot_url = f\"http://{address}/\"\n        else:\n            self.logger.info(f\"Uploading firmware...\")\n            robot_url = f\"http://{address}/fw-update/{firmware_file.name}\"\n        request_post = requests.post(robot_url, data=firmware_data, headers=headers, timeout=60.0)\n        try:\n            request_post.raise_for_status()\n        except Exception as e:\n            self.logger.error(f\"Upgrade post request error: {e}\")\n            raise\n        if not request_post.ok:\n            error_message = f\"Firmware upload request failed\"\n            raise RuntimeError(error_message)\n        self.logger.info(f\"Starting the firmware update...\")\n        if not use_legacy_update:\n            self._fw_update_status.in_progress = True  # Set once here, but the will be updated from robot update status\n            self._send_custom_command(f'StartFwUpdate({firmware_file.name})')\n        self._reset_fw_update_status()\n        start_time = time.monotonic()\n        while True:\n            if use_legacy_update:\n                self._check_update_progress_legacy(robot_url)\n            else:\n                self._check_update_progress(address)\n            if self._fw_update_status.error:\n                raise MecademicException(f'Firmware update failed: {self._fw_update_status.error_msg}')\n            if self._fw_update_status.complete:\n                self.logger.info(f\"Firmware update done\")\n                break\n            if time.monotonic() > start_time + timeout:\n                error_message = f\"Timeout while waiting for update done response, after {timeout} seconds\"\n                raise TimeoutError(error_message)\n        if use_legacy_update:\n            time.sleep(15)\n            ping_robot(address)\n            self._Connect(address_port,\n                          timeout=60,\n                          enable_synchronous_mode=current_synchronous_mode,\n                          disconnect_on_exception=initial_disconnect_on_exception)\n        else:\n            end_time = time.monotonic() + 30\n            while True:\n                if time.monotonic() > end_time:\n                    raise TimeoutError('Timeout while attempting to reconnect in control mode')\n                try:\n                    self.Disconnect()\n                    if self._fw_update_status.complete and not self._fw_update_reboot_done:\n                        self.logger.info(f\"Waiting before reconnecting to robot...\")\n                        time.sleep(11)\n                    self._Connect(address_port,\n                                  timeout=10,\n                                  enable_synchronous_mode=current_synchronous_mode,\n                                  disconnect_on_exception=initial_disconnect_on_exception)\n                    break\n                except Exception as e:\n                    error_message = str(e)\n                    if 'id=3002,' in error_message:\n                        time.sleep(1)\n                        continue\n                    raise\n        if self.GetRobotInfo().version.is_at_least(8.0):\n            current_version = self.GetRobotInfo().version.get_str(build=True, extra=False)\n            expected_version = firmware_file_version.full_version\n        else:\n            current_version = self.GetRobotInfo().version\n            expected_version = firmware_file_version.short_version\n        if str(current_version) not in expected_version:\n            error_msg = (f\"Fail to install robot properly. current version {current_version}, \"\n                         f\"expecting: {expected_version}\")\n            self.logger.error(error_msg)\n            raise AssertionError(error_msg)\n        robot_status = self.GetStatusRobot(synchronous_update=True)\n        if robot_status.error_status:\n            error_msg = f\"Robot is in error on version {current_version}\"\n            self.logger.error(error_msg)\n            raise InvalidStateError(error_msg)\n        self.logger.info(f\"Installation of {current_version} successfully completed\")", "hash": "28e4c1daabad", "chunk_type": "method", "node_type": "function_definition", "signature": "_update_robot(self, firmware: Union[str, pathlib.Path], timeout: float = _UPDATE_TIMEOUT)", "docstring": "See documentation of UpdateRobot in robot.py", "chunk_size_bytes": 6494, "original_size_bytes": 7600, "start_byte": 135197, "end_byte": 142797}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:cb363cb85fb7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_normalize_cart_cmd_args", "qualified_name": "_Robot._normalize_cart_cmd_args", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3109, 3129], "text": "def _normalize_cart_cmd_args(self, alpha: float = None, beta: float = None, gamma: float = None) -> list[float]:\n        \"\"\"Normalize alpha, beta and gamma arguments for Cartesian commands which accept alpha/beta\n        arguments to be omitted\"\"\"\n        if self.GetRobotInfo().num_joints == 6:\n            if alpha is None or beta is None or gamma is None:\n                raise ValueError('Missing argument (on this robot Cartesian positions require 6 values)')\n            else:\n                return [alpha, beta, gamma]\n        else:\n            if alpha is not None and beta is not None and gamma is not None:\n                return [alpha, beta, gamma]\n            elif alpha is not None and beta is None and gamma is None:\n                return [0, 0, alpha]\n            elif alpha is None and beta is None and gamma is not None:\n                return [0, 0, gamma]\n            raise ValueError('Wrong number of argument (on this robot Cartesian positions require 4 values)')", "hash": "cb363cb85fb7", "chunk_type": "method", "node_type": "function_definition", "signature": "_normalize_cart_cmd_args(self, alpha: float = None, beta: float = None, gamma: float = None)", "docstring": "Normalize alpha, beta and gamma arguments for Cartesian commands which accept alpha/beta\n        arguments to be omitted", "chunk_size_bytes": 987, "original_size_bytes": 1307, "start_byte": 142803, "end_byte": 144110}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:27abc2f57214", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_normalize_conf_cmd_args", "qualified_name": "_Robot._normalize_conf_cmd_args", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3131, 3151], "text": "def _normalize_conf_cmd_args(self, shoulder: int = None, elbow: int = None, wrist: int = None) -> list[int]:\n        \"\"\"Normalize shoulder, elbow and wrist \"conf\" arguments for commands which accept to omit shoulder and\n           wrist (for 4 axes robots which only have elbow conf)\"\"\"\n        if self.GetRobotInfo().num_joints == 6:\n            if shoulder is None or elbow is None or wrist is None:\n                raise ValueError('Missing argument (on this robot configuration requires 3 values)')\n            else:\n                return [shoulder, elbow, wrist]\n        else:\n            if shoulder is not None and elbow is not None and wrist is not None:\n                return [shoulder, elbow, wrist]\n            elif shoulder is not None and elbow is None and wrist is None:\n                return [0, shoulder, 0]\n            elif shoulder is None and elbow is not None and wrist is None:\n                return [0, elbow, 0]\n            raise ValueError('Wrong number of arguments (on this robot configuration require 1 value)')", "hash": "27abc2f57214", "chunk_type": "method", "node_type": "function_definition", "signature": "_normalize_conf_cmd_args(self, shoulder: int = None, elbow: int = None, wrist: int = None)", "docstring": "Normalize shoulder, elbow and wrist \"conf\" arguments for commands which accept to omit shoulder and\n           wrist (for 4 axes robots which only have elbow conf)", "chunk_size_bytes": 1042, "original_size_bytes": 1365, "start_byte": 144116, "end_byte": 145481}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:949e2d8a4486", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_get_reboot_duration", "qualified_name": "_Robot._get_reboot_duration", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3153, 3162], "text": "def _get_reboot_duration(self):\n        \"\"\" Get the average expected reboot duration for current robot model \"\"\"\n        if self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCS500_R1:\n            return MX_FW_UPDATE_REBOOT_DURATION_SEC_MCS500\n        elif self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCA250_R1:\n            return MX_FW_UPDATE_REBOOT_DURATION_SEC_MCA250\n        elif self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCA1000_R1:\n            return MX_FW_UPDATE_REBOOT_DURATION_SEC_MCA1000\n        else:\n            return MX_FW_UPDATE_REBOOT_DURATION_SEC_MECA500", "hash": "949e2d8a4486", "chunk_type": "method", "node_type": "function_definition", "signature": "_get_reboot_duration(self)", "docstring": "Get the average expected reboot duration for current robot model", "chunk_size_bytes": 624, "original_size_bytes": 624, "start_byte": 145487, "end_byte": 146111}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:1864a497225f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_get_fw_update_duration", "qualified_name": "_Robot._get_fw_update_duration", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3164, 3173], "text": "def _get_fw_update_duration(self):\n        \"\"\" Get the average expected firmware update duration for current robot model \"\"\"\n        if self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCS500_R1:\n            return MX_FW_UPDATE_AVG_DURATION_SEC_MCS500\n        elif self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCA250_R1:\n            return MX_FW_UPDATE_AVG_DURATION_SEC_MCA250\n        elif self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCA1000_R1:\n            return MX_FW_UPDATE_AVG_DURATION_SEC_MCA1000\n        else:\n            return MX_FW_UPDATE_AVG_DURATION_SEC_MECA500", "hash": "1864a497225f", "chunk_type": "method", "node_type": "function_definition", "signature": "_get_fw_update_duration(self)", "docstring": "Get the average expected firmware update duration for current robot model", "chunk_size_bytes": 624, "original_size_bytes": 624, "start_byte": 146117, "end_byte": 146741}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c87e27ea86cf", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_check_update_progress", "qualified_name": "_Robot._check_update_progress", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3175, 3225], "text": "def _check_update_progress(self, address: str):\n        \"\"\"\n        Check progress of firmware update (new implementation using JSON API).\n        Parameters\n        ----------\n        address: string\n            Robot IP address/port\n        \"\"\"\n        time.sleep(0.1)\n        if not self.IsConnected():\n            try:\n                if self._monitor_mode and self._fw_update_status.in_progress and self._fw_update_reboot_timestamp == 0:\n                    self._fw_update_reboot_timestamp = time.monotonic()\n                self._Connect(address=f'{address}:{MX_ROBOT_TCP_PORT_FEED_JSON}', monitor_mode=True, timeout=1.0)\n                self._fw_update_started = True\n            except Exception:\n                try:\n                    self._Connect(address=f'{address}', monitor_mode=True, timeout=0.1)\n                    if self.GetRobotInfo().version.is_at_least(9, 3):\n                        self.Disconnect()\n                    else:\n                        self._fw_update_status.complete = True\n                except Exception:\n                    if self._fw_update_reboot_timestamp == 0:\n                        reboot_pct = 0\n                    else:\n                        reboot_elapsed_ms = 1000 * (time.monotonic() - self._fw_update_reboot_timestamp)\n                        reboot_pct = 100 * (reboot_elapsed_ms / (1000 * self._get_reboot_duration()))\n                        if reboot_pct > 100:\n                            reboot_pct = 100\n                    if time.monotonic() - self._fw_update_status._last_print_timestamp > 5.0:\n                        self._print_fw_update_status(int(reboot_pct))", "hash": "c87e27ea86cf", "chunk_type": "method", "node_type": "function_definition", "signature": "_check_update_progress(self, address: str)", "docstring": "Check progress of firmware update (new implementation using JSON API).\n\n        Parameters\n        ----------\n        address: string\n            Robot IP address/port", "chunk_size_bytes": 1637, "original_size_bytes": 3055, "start_byte": 146747, "end_byte": 149802}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a773057fea74", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_check_update_progress_legacy", "qualified_name": "_Robot._check_update_progress_legacy", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3227, 3291], "text": "def _check_update_progress_legacy(self, robot_url: str):\n        \"\"\"\n        Check progress of firmware update (legacy version with old web portal).\n        Parameters\n        ----------\n        robot_url: string\n            Robot URL\n        \"\"\"\n        time.sleep(2)\n        self._fw_update_status.complete = False\n        request_get = requests.get(robot_url, 'update', timeout=10)\n        try:\n            request_get.raise_for_status()\n        except Exception as e:\n            self.logger.error(f'Upgrade get request error: {e}')\n            raise e\n        if request_get.status_code == 200:\n            request_response = request_get.text\n        else:\n            request_response = None\n        if request_response is None or request_response == '0':\n            return\n        try:\n            request_answer = json.loads(request_response)\n        except Exception as e:\n            self.logger.info(f'Error retrieving json from request_response: {e}')\n            return\n        if not request_answer:\n            self.logger.info(f'Answer is empty')\n            return\n        status_code = -1\n        status_msg = \"\"\n        if request_answer['STATUS']:\n            status_code = int(request_answer['STATUS']['Code'])\n            status_msg = request_answer['STATUS']['MSG']\n        if status_code in [0, 1]:\n            keys = sorted(request_answer['LOG'].keys())\n            if keys:\n                previous_progress = self._fw_update_status.progress_str\n                self._fw_update_status.progress_str = request_answer['LOG'][keys[-1]]\n                new_progress = self._fw_update_status.progress_str.replace(previous_progress, '')\n                if ':' in new_progress:\n                    self.logger.info(new_progress)\n                elif '100%' in new_progress:\n                    self.logger.info(new_progress)\n                else:\n                    self.logger.debug(new_progress)\n            if status_code == 0:\n                self.logger.info(f'status_msg {status_msg}')\n                self._fw_update_status.complete = True\n                return\n        else:\n            error_message = f'error while updating: {status_msg}'\n            self.logger.error(error_message)\n            raise RuntimeError(error_message)", "hash": "a773057fea74", "chunk_type": "method", "node_type": "function_definition", "signature": "_check_update_progress_legacy(self, robot_url: str)", "docstring": "Check progress of firmware update (legacy version with old web portal).\n\n        Parameters\n        ----------\n        robot_url: string\n            Robot URL", "chunk_size_bytes": 2260, "original_size_bytes": 2440, "start_byte": 149808, "end_byte": 152248}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:824e49223aa6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_check_monitor_threads", "qualified_name": "_Robot._check_monitor_threads", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3293, 3310], "text": "def _check_monitor_threads(self):\n        \"\"\"Check that the threads which handle robot monitor messages are alive.\n        Attempt to disconnect from the robot if not.\n        \"\"\"\n        if self._robot_info.rt_on_ctrl_port_capable:\n            return\n        if not (self._monitor_rx_handler_thread and self._monitor_rx_handler_thread.is_alive()):\n            raise InvalidStateError('Monitor response handler thread has unexpectedly terminated.')\n        if self._offline_mode:  # Do not check rx threads in offline mode.\n            return\n        if not (self._monitor_rx_thread and self._monitor_rx_thread.is_alive()):\n            raise InvalidStateError('Monitor rx thread has unexpectedly terminated.')", "hash": "824e49223aa6", "chunk_type": "method", "node_type": "function_definition", "signature": "_check_monitor_threads(self)", "docstring": "Check that the threads which handle robot monitor messages are alive.\n\n        Attempt to disconnect from the robot if not.", "chunk_size_bytes": 709, "original_size_bytes": 784, "start_byte": 152254, "end_byte": 153038}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:cde9116d46f2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_check_command_threads", "qualified_name": "_Robot._check_command_threads", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3312, 3329], "text": "def _check_command_threads(self):\n        \"\"\"Check that the threads which handle robot command messages are alive.\n        Attempt to disconnect from the robot if not.\n        \"\"\"\n        if not (self._rx_handler_thread and self._rx_handler_thread.is_alive()):\n            raise DisconnectError('Socket was closed')\n        if self._offline_mode:  # Do not check rx threads in offline mode.\n            return\n        if not (self._rx_thread and self._rx_thread.is_alive()):\n            raise DisconnectError('Socket was closed')\n        if not (self._tx_thread and self._tx_thread.is_alive()):\n            raise DisconnectError('Socket was closed')", "hash": "cde9116d46f2", "chunk_type": "method", "node_type": "function_definition", "signature": "_check_command_threads(self)", "docstring": "Check that the threads which handle robot command messages are alive.\n\n        Attempt to disconnect from the robot if not.", "chunk_size_bytes": 649, "original_size_bytes": 655, "start_byte": 153044, "end_byte": 153699}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d96f73ffd082", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_check_internal_states", "qualified_name": "_Robot._check_internal_states", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3331, 3364], "text": "def _check_internal_states(self, refresh_monitoring_mode=False):\n        \"\"\"Check that the threads which handle robot messages are alive.\n        Attempt to disconnect from the robot if not.\n        Parameters\n        ----------\n        refresh_monitoring_mode : boolean\n            Refresh internal states even in monitoring mode when True, raise an exception otherwise.\n        \"\"\"\n        try:\n            if self._monitor_mode:\n                if not refresh_monitoring_mode:\n                    raise InvalidStateError('Cannot send command while in monitoring mode.')\n            else:\n                thread_ident = threading.get_ident()\n                rx_thread_ident = self._rx_thread.ident if self._rx_thread is not None else None\n                cmd_thread_ident = (self._rx_handler_thread.ident if self._rx_handler_thread is not None else None)\n                if (thread_ident != rx_thread_ident and thread_ident != cmd_thread_ident):\n                    self._check_command_threads()\n            self._check_monitor_threads()\n            if self._monitor_timeout_used and self._rx_timestamp != 0:\n                elapsedMs = 1000 * (time.monotonic() - self._rx_timestamp)\n                if elapsedMs > _MONITORING_TIMEOUT_MS:\n                    raise TimeoutError(f'Timeout: No message received from the robot in the last {elapsedMs}ms. '\n                                       f'Assuming we are disconnected from the robot.')\n        except Exception:\n            self._disconnect()\n            raise", "hash": "d96f73ffd082", "chunk_type": "method", "node_type": "function_definition", "signature": "_check_internal_states(self, refresh_monitoring_mode=False)", "docstring": "Check that the threads which handle robot messages are alive.\n\n        Attempt to disconnect from the robot if not.\n\n        Parameters\n        ----------\n        refresh_monitoring_mode : boolean\n            Refresh internal states even in monitoring mode when True, raise an exception otherwise.", "chunk_size_bytes": 1517, "original_size_bytes": 1799, "start_byte": 153705, "end_byte": 155504}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:41ee4190bc3a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_split_command_args", "qualified_name": "_Robot._split_command_args", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3366, 3409], "text": "def _split_command_args(self, command: str, args: Union[str, list, tuple] = None) -> list[str, Optional[list[str]]]:\n        \"\"\"In the case the arguments are passed in the command argument, this function will split the command name\n           and arguments.\n        Parameters\n        ----------\n        command : str\n            String that contains the command name and possibly the arguments too\n        args : Union[str, list, tuple], optional\n            Arguments for the command, as a string, a list or a tuple, by default None\n        Returns\n        -------\n        list[str, Optional[list[str]]]\n            Command name (without arguments), arguments (normalized as list of strings)\n        \"\"\"\n        if args is None:\n            split_result = command.split('(', 1)\n            if len(split_result) == 2:\n                command = split_result[0]\n                args = split_result[1].rstrip(\")\")\n        args_string: Optional[list[str]] = None\n        if args is not None:\n            if isinstance(args, tuple):\n                args = list(args)\n            elif isinstance(args, list):\n                pass\n            else:\n                args = [args]\n            args_string: list[str] = []\n            for arg in args:\n                if isinstance(arg, IntEnum):\n                    args_string.append(str(arg.value))\n                else:\n                    args_string.append(str(arg))\n        command = command.strip()\n        return [command, args_string]", "hash": "41ee4190bc3a", "chunk_type": "method", "node_type": "function_definition", "signature": "_split_command_args(self, command: str, args: Union[str, list, tuple] = None)", "docstring": "In the case the arguments are passed in the command argument, this function will split the command name\n           and arguments.\n\n        Parameters\n        ----------\n        command : str\n            String that contains the command name and possibly the arguments too\n        args : Union[str, list, tuple], optional\n            Arguments for the command, as a string, a list or a tuple, by default None\n\n        Returns\n        -------\n        list[str, Optional[list[str]]]\n            Command name (without arguments), arguments (normalized as list of strings)", "chunk_size_bytes": 1484, "original_size_bytes": 1827, "start_byte": 155510, "end_byte": 157337}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:3d8f8ae19932", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_send_json_command", "qualified_name": "_Robot._send_json_command", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3411, 3458], "text": "def _send_json_command(self,\n                           command: str,\n                           json_data: dict,\n                           meta_data: Optional[dict] = None,\n                           expected_responses: list[MxRobotStatusCode] = None,\n                           timeout: Optional[float] = None) -> Optional[Message]:\n        \"\"\"Send a JSON command to the robot\n        Args:\n            command (str): Command name\n            json_data (dict): JSON data for this command (as a dict, will be formatted as JSON string by this function)\n            meta_data (Optional[dict], optional): Meta-data dictionary for this command. Defaults to None.\n            expected_responses (list[MxRobotStatusCode], optional):\n                Optional list of responses to wait for.\n                This function will block until one of the responses in this list is received, or until timeout.\n                If None, the function is non-blocking\n                Defaults to None.\n            timeout (Optional[float]):\n                Timeout for waiting for response among expected_responses.\n                If None, a default timeout will be used (that may not be suitable for all type of commands).\n                Defaults to None.\n                Ignored if expected_responses is None.\n        Raises\n        ------\n        TimeoutException\n            If response was not received before timeout\n        Returns\n        -------\n        Optional[Message]\n            The response received from the robot (or None if expected_responses is None)\n        \"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        with self._main_lock:\n            if expected_responses:\n                event_with_data = InterruptableEvent(data=expected_responses)\n                self._custom_response_events.append(weakref.ref(event_with_data))\n            msg_dict = {MX_JSON_KEY_DATA: json_data, MX_JSON_KEY_META_DATA: meta_data}\n            self._send_command(command, f'{json.dumps(msg_dict)}')\n        if expected_responses:\n            response = event_with_data.wait(timeout)\n            return response\n        return None", "hash": "3d8f8ae19932", "chunk_type": "method", "node_type": "function_definition", "signature": "_send_json_command(self,\n                           command: str,\n                           json_data: dict,\n                           meta_data: Optional[dict] = None,\n                           expected_responses: list[MxRobotStatusCode] = None,\n                           timeout: Optional[float] = None)", "docstring": "Send a JSON command to the robot\n\n        Args:\n            command (str): Command name\n            json_data (dict): JSON data for this command (as a dict, will be formatted as JSON string by this function)\n            meta_data (Optional[dict], optional): Meta-data dictionary for this command. Defaults to None.\n            expected_responses (list[MxRobotStatusCode], optional):\n                Optional list of responses to wait for.\n                This function will block until one of the responses in this list is received, or until timeout.\n                If None, the function is non-blocking\n                Defaults to None.\n            timeout (Optional[float]):\n                Timeout for waiting for response among expected_responses.\n                If None, a default timeout will be used (that may not be suitable for all type of commands).\n                Defaults to None.\n                Ignored if expected_responses is None.\n        Raises\n        ------\n        TimeoutException\n            If response was not received before timeout\n        Returns\n        -------\n        Optional[Message]\n            The response received from the robot (or None if expected_responses is None)", "chunk_size_bytes": 2148, "original_size_bytes": 2331, "start_byte": 157343, "end_byte": 159674}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:025af89af56f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_send_command", "qualified_name": "_Robot._send_command", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3460, 3487], "text": "def _send_command(self, command: str, args: Union[str, list, tuple] = None):\n        \"\"\"Assembles and sends the command string to the Mecademic robot.\n        Parameters\n        ----------\n        command : string\n            Command name to send to the Mecademic robot.\n        args : list or str\n            List of arguments the command requires.\n        \"\"\"\n        command, args = self._split_command_args(command, args)\n        command_trimmed = command.replace('-', '').lower()\n        if command_trimmed in self._send_cmd_handlers:\n            self._send_cmd_handlers[command_trimmed](args)\n        if args:\n            command += f'({args_to_string(args)})'\n        self._command_tx_queue.put(command)\n        if self._file_logger and self._file_logger.logging_commands:\n            self._file_logger.command_queue.put(command)", "hash": "025af89af56f", "chunk_type": "method", "node_type": "function_definition", "signature": "_send_command(self, command: str, args: Union[str, list, tuple] = None)", "docstring": "Assembles and sends the command string to the Mecademic robot.\n\n        Parameters\n        ----------\n        command : string\n            Command name to send to the Mecademic robot.\n        args : list or str\n            List of arguments the command requires.", "chunk_size_bytes": 836, "original_size_bytes": 1066, "start_byte": 159680, "end_byte": 160746}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f6a6b4ebe057", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_send_sync_command", "qualified_name": "_Robot._send_sync_command", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3489, 3535], "text": "def _send_sync_command(self,\n                           command: Optional[str],\n                           args: Optional[Union[str, list, tuple]] = None,\n                           event: Optional[InterruptableEvent] = None,\n                           timeout: Optional[float] = None):\n        \"\"\"Send a command and wait for corresponding response\n           (this function handles well-known commands which have their corresponding 'wait' event in this class,\n            use _send_custom_command to perform synchronous operations on other commands)\n        Parameters\n        ----------\n        command : string\n            Name of the command to send (example: GetStatusGripper)\n        args : list or str\n            List of arguments the command requires.\n        event : InterruptableEvent\n            Event that will be set (unblocked) once the corresponding response is received\n        timeout : float\n            Maximum time to wait for the event to be set (i.e. response received)\n        Raises\n        ------\n        TimeoutException\n            If response was not received before timeout\n        \"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        with self._main_lock:\n            self._check_internal_states()\n            if self._robot_info.rt_on_ctrl_port_capable:\n                self._tx_sync += 1\n                self._tx_sync_pending = self._tx_sync\n                self._is_sync.clear()\n                self._send_command('SyncCmdQueue', f'{self._tx_sync}')\n            if event is not None and event.is_set():\n                event.clear()\n            if command is not None:\n                self._send_command(command, args)\n        if event is not None:\n            event.wait(timeout=timeout)\n        else:\n            self._is_sync.wait(timeout=timeout)", "hash": "f6a6b4ebe057", "chunk_type": "method", "node_type": "function_definition", "signature": "_send_sync_command(self,\n                           command: Optional[str],\n                           args: Optional[Union[str, list, tuple]] = None,\n                           event: Optional[InterruptableEvent] = None,\n                           timeout: Optional[float] = None)", "docstring": "Send a command and wait for corresponding response\n           (this function handles well-known commands which have their corresponding 'wait' event in this class,\n            use _send_custom_command to perform synchronous operations on other commands)\n\n        Parameters\n        ----------\n        command : string\n            Name of the command to send (example: GetStatusGripper)\n        args : list or str\n            List of arguments the command requires.\n        event : InterruptableEvent\n            Event that will be set (unblocked) once the corresponding response is received\n        timeout : float\n            Maximum time to wait for the event to be set (i.e. response received)\n\n\n        Raises\n        ------\n        TimeoutException\n            If response was not received before timeout", "chunk_size_bytes": 1815, "original_size_bytes": 2106, "start_byte": 160752, "end_byte": 162858}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b327c31e5088", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_send_custom_command", "qualified_name": "_Robot._send_custom_command", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3537, 3563], "text": "def _send_custom_command(self,\n                             command: str,\n                             expected_responses: list[MxRobotStatusCode] = None,\n                             timeout: float = None,\n                             skip_internal_check: bool = False) -> InterruptableEvent | Message:\n        \"\"\"Internal version of SendCustomCommand with option to skip internal state check (so it can be used\n           during connection)\n        \"\"\"\n        with self._main_lock:\n            if not skip_internal_check:\n                self._check_internal_states()\n            if expected_responses:\n                event_with_data = InterruptableEvent(data=expected_responses)\n                self._custom_response_events.append(weakref.ref(event_with_data))\n            self._send_command(command)\n        if expected_responses:\n            if timeout is None:\n                return event_with_data\n            else:\n                response = event_with_data.wait(timeout)\n                return response\n        default_event = InterruptableEvent(None, None)\n        default_event.set()\n        return default_event", "hash": "b327c31e5088", "chunk_type": "method", "node_type": "function_definition", "signature": "_send_custom_command(self,\n                             command: str,\n                             expected_responses: list[MxRobotStatusCode] = None,\n                             timeout: float = None,\n                             skip_internal_check: bool = False)", "docstring": "Internal version of SendCustomCommand with option to skip internal state check (so it can be used\n           during connection)", "chunk_size_bytes": 1126, "original_size_bytes": 1129, "start_byte": 162864, "end_byte": 163993}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b447b7a2ee7f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "GetInterruptableEvent", "qualified_name": "_Robot.GetInterruptableEvent", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3565, 3583], "text": "def GetInterruptableEvent(self,\n                              codes: list[Union[MxRobotStatusCode, Message]],\n                              abort_on_error=False,\n                              abort_on_clear_motion=False) -> InterruptableEvent:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            event_with_data = InterruptableEvent(data=codes,\n                                                 abort_on_error=abort_on_error,\n                                                 abort_on_clear_motion=abort_on_clear_motion)\n            self._custom_response_events.append(weakref.ref(event_with_data))\n            if abort_on_error and self._robot_status.error_status:\n                event_with_data.abort('Robot is in error')\n            if abort_on_clear_motion:\n                if not self._robot_status.activation_state:\n                    event_with_data.abort('Robot was deactivated')\n                if self._robot_safety_status.pstop2_state != MxStopState.MX_STOP_STATE_RESET:\n                    event_with_data.abort('Robot is in PSTOP2 condition')\n            return event_with_data", "hash": "b447b7a2ee7f", "chunk_type": "method", "node_type": "function_definition", "signature": "GetInterruptableEvent(self,\n                              codes: list[Union[MxRobotStatusCode, Message]],\n                              abort_on_error=False,\n                              abort_on_clear_motion=False)", "docstring": "See documentation in equivalent function in robot.py", "chunk_size_bytes": 1147, "original_size_bytes": 1208, "start_byte": 163999, "end_byte": 165207}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:305e74a81c24", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_launch_thread", "qualified_name": "_Robot._launch_thread", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3585, 3604], "text": "def _launch_thread(self, *, target, args) -> threading.Thread:\n        \"\"\"Establish the threads responsible for reading/sending messages using the sockets.\n        Parameters\n        ----------\n        func : function handle\n            Function to run using new thread.\n        args : argument list\n            Arguments to be passed to func.\n        Return\n        ------\n        thread handle\n            Handle for newly-launched thread.\n        \"\"\"\n        thread = threading.Thread(target=target, args=args)\n        thread.daemon = True  # Make sure thread does not prevent application from quitting\n        thread.start()\n        return thread", "hash": "305e74a81c24", "chunk_type": "method", "node_type": "function_definition", "signature": "_launch_thread(self, *, target, args)", "docstring": "Establish the threads responsible for reading/sending messages using the sockets.\n\n        Parameters\n        ----------\n        func : function handle\n            Function to run using new thread.\n        args : argument list\n            Arguments to be passed to func.\n\n        Return\n        ------\n        thread handle\n            Handle for newly-launched thread.", "chunk_size_bytes": 650, "original_size_bytes": 653, "start_byte": 165213, "end_byte": 165866}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:17d1d4059991", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_initialize_command_socket", "qualified_name": "_Robot._initialize_command_socket", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3606, 3639], "text": "def _initialize_command_socket(self, timeout=1.0):\n        \"\"\"Establish the command socket and the associated thread.\n        \"\"\"\n        if self._offline_mode:\n            return\n        if self._command_socket is not None:\n            raise InvalidStateError('Cannot connect since existing command socket exists.')\n        self._command_socket = self._connect_socket(self.logger, self._address, self._port, timeout)\n        self.logger.debug(f'Connected to {self._address}:{self._port} (control mode)')\n        if self._sidecar_mode:\n            self._command_socket.sendall((f'{MX_ROBOT_SIDECAR_MODE_STRING}\\0').encode('ascii'))\n            pass\n        else:\n            self._command_socket.sendall(('\\0').encode('ascii'))\n        if self._command_socket is None:\n            raise CommunicationError('Command socket could not be created. Is the IP address correct?')\n        self._rx_thread = self._launch_thread(target=self._rx_thread_fct,\n                                              args=(\n                                                  self._command_socket,\n                                                  self._command_rx_queue,\n                                              ))\n        self._tx_thread = self._launch_thread(target=self._tx_thread_fct,\n                                              args=(self._command_socket, self._command_tx_queue))", "hash": "17d1d4059991", "chunk_type": "method", "node_type": "function_definition", "signature": "_initialize_command_socket(self, timeout=1.0)", "docstring": "Establish the command socket and the associated thread.", "chunk_size_bytes": 1367, "original_size_bytes": 1687, "start_byte": 165872, "end_byte": 167559}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:3ba21e0eafba", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_initialize_monitoring_socket", "qualified_name": "_Robot._initialize_monitoring_socket", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3641, 3664], "text": "def _initialize_monitoring_socket(self, timeout):\n        \"\"\"Establish the monitoring socket and the associated thread.\n        \"\"\"\n        if self._offline_mode:\n            return\n        if self._monitor_socket is not None:\n            raise InvalidStateError('Cannot connect since existing monitor socket exists.')\n        port = self._port if self._monitor_mode else MX_ROBOT_TCP_PORT_FEED\n        self._monitor_socket = self._connect_socket(self.logger, self._address, port, timeout)\n        self.logger.debug(f'Connected to {self._address}:{port} (monitoring mode)')\n        self._monitor_socket.sendall(('\\0').encode('ascii'))\n        if self._monitor_socket is None:\n            raise CommunicationError('Monitor socket could not be created. Is the IP address correct?')\n        self._monitor_rx_thread = self._launch_thread(target=self._rx_thread_fct,\n                                                      args=(self._monitor_socket, self._monitor_rx_queue))", "hash": "3ba21e0eafba", "chunk_type": "method", "node_type": "function_definition", "signature": "_initialize_monitoring_socket(self, timeout)", "docstring": "Establish the monitoring socket and the associated thread.", "chunk_size_bytes": 968, "original_size_bytes": 1218, "start_byte": 167565, "end_byte": 168783}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:57be8156fe7f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_receive_welcome_message", "qualified_name": "_Robot._receive_welcome_message", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3666, 3709], "text": "def _receive_welcome_message(self, message_queue: queue.Queue, from_command_port: bool):\n        \"\"\"Receive and parse a welcome message in order to set _robot_info and _robot_rt_data.\n        Parameters\n        ----------\n        message_queue : queue\n            The welcome message will be fetched from this queue.\n        \"\"\"\n        start = time.monotonic()\n        while True:\n            try:\n                response: Message = message_queue.get(block=True, timeout=self.default_timeout)\n            except queue.Empty as e:\n                self.logger.error('No response received within timeout interval.')\n                raise CommunicationError('No response received within timeout interval.') from e\n            except BaseException as e:\n                raise e\n            if response.id == mx_st.MX_ST_CONNECTED or response.id == mx_st.MX_ST_GET_STATUS_ROBOT:\n                break\n            if from_command_port:\n                break\n            if (time.monotonic() - start) > self.default_timeout:\n                self.logger.error('No connect message received within timeout interval.')\n                break\n        if response.id == mx_st.MX_ST_CONNECTED:\n            self._robot_info = self._parse_welcome_message(response.data)\n        elif response.id == mx_st.MX_ST_GET_STATUS_ROBOT:\n            self._robot_info = RobotInfo(model='Meca500', revision=3, version='8.0.0.0-unknown-version')\n        else:\n            raise CommunicationError(f'Connection error: {response}')\n        self._robot_rt_data = RobotRtData(self._robot_info.num_joints)\n        self._robot_rt_data_stable = RobotRtData(self._robot_info.num_joints)", "hash": "57be8156fe7f", "chunk_type": "method", "node_type": "function_definition", "signature": "_receive_welcome_message(self, message_queue: queue.Queue, from_command_port: bool)", "docstring": "Receive and parse a welcome message in order to set _robot_info and _robot_rt_data.\n\n        Parameters\n        ----------\n        message_queue : queue\n            The welcome message will be fetched from this queue.", "chunk_size_bytes": 1649, "original_size_bytes": 2137, "start_byte": 168789, "end_byte": 170926}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d70f0af14022", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_parse_welcome_message", "qualified_name": "_Robot._parse_welcome_message", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3711, 3725], "text": "def _parse_welcome_message(self, message: str) -> RobotInfo:\n        \"\"\"Parse the robot's connection 'welcome' message and build RobotInfo from it\n           (identify robot model, version, etc.)\n        Parameters\n        ----------\n        message : str\n            Welcome string received from the robot\n        Returns\n        -------\n        RobotInfo\n            Robot information class built from the received welcome message\n        \"\"\"\n        return RobotInfo.from_command_response_string(message)", "hash": "d70f0af14022", "chunk_type": "method", "node_type": "function_definition", "signature": "_parse_welcome_message(self, message: str)", "docstring": "Parse the robot's connection 'welcome' message and build RobotInfo from it\n           (identify robot model, version, etc.)\n\n        Parameters\n        ----------\n        message : str\n            Welcome string received from the robot\n\n        Returns\n        -------\n        RobotInfo\n            Robot information class built from the received welcome message", "chunk_size_bytes": 507, "original_size_bytes": 509, "start_byte": 170932, "end_byte": 171441}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:88177e0e9348", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_initialize_command_connection", "qualified_name": "_Robot._initialize_command_connection", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3727, 3733], "text": "def _initialize_command_connection(self):\n        \"\"\"Attempt to connect to the command port of the Mecademic Robot.\n        \"\"\"\n        self._receive_welcome_message(self._command_rx_queue, True)\n        self._rx_handler_thread = self._launch_thread(target=self._rx_handler_fct, args=())", "hash": "88177e0e9348", "chunk_type": "method", "node_type": "function_definition", "signature": "_initialize_command_connection(self)", "docstring": "Attempt to connect to the command port of the Mecademic Robot.", "chunk_size_bytes": 287, "original_size_bytes": 289, "start_byte": 171447, "end_byte": 171736}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:7468d5d9cc3e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_initialize_monitoring_connection", "qualified_name": "_Robot._initialize_monitoring_connection", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3735, 3743], "text": "def _initialize_monitoring_connection(self):\n        \"\"\"Attempt to connect to the monitor port of the Mecademic Robot.\"\"\"\n        if self._monitor_mode:\n            self._receive_welcome_message(self._monitor_rx_queue, False)\n        self._monitor_rx_handler_thread = self._launch_thread(target=self._monitor_rx_handler, args=())\n        return", "hash": "7468d5d9cc3e", "chunk_type": "method", "node_type": "function_definition", "signature": "_initialize_monitoring_connection(self)", "docstring": "Attempt to connect to the monitor port of the Mecademic Robot.", "chunk_size_bytes": 344, "original_size_bytes": 347, "start_byte": 171742, "end_byte": 172089}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:92ff46e501c5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_shut_down_queue_threads", "qualified_name": "_Robot._shut_down_queue_threads", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3745, 3776], "text": "def _shut_down_queue_threads(self):\n        \"\"\"Attempt to gracefully shut down threads which read from queues.\n        \"\"\"\n        if self._tx_thread is not None:\n            try:\n                self._command_tx_queue.put(_TERMINATE)\n            except Exception as e:\n                self.logger.error(f'Error shutting down tx thread: {e}')\n            self._tx_thread.join(timeout=self.default_timeout)\n            self._tx_thread = None\n        if self._rx_handler_thread is not None and self._rx_handler_thread != threading.current_thread():\n            try:\n                self._command_rx_queue.put(_TERMINATE)\n            except Exception as e:\n                self.logger.error(f'Error shutting down command response handler thread: {e}')\n            self._rx_handler_thread.join(timeout=self.default_timeout)\n            self._rx_handler_thread = None\n        if self._monitor_rx_handler_thread is not None and self._rx_handler_thread != threading.current_thread():\n            try:\n                self._monitor_rx_queue.put(_TERMINATE)\n            except Exception as e:\n                self.logger.error(f'Error shutting down monitor handler thread: {e}')\n            self._monitor_rx_handler_thread.join(timeout=self.default_timeout)\n            self._monitor_rx_handler_thread = None", "hash": "92ff46e501c5", "chunk_type": "method", "node_type": "function_definition", "signature": "_shut_down_queue_threads(self)", "docstring": "Attempt to gracefully shut down threads which read from queues.", "chunk_size_bytes": 1299, "original_size_bytes": 1637, "start_byte": 172095, "end_byte": 173732}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:bb82e6a97177", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_shut_down_socket_threads", "qualified_name": "_Robot._shut_down_socket_threads", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3778, 3809], "text": "def _shut_down_socket_threads(self):\n        \"\"\"Attempt to gracefully shut down threads which read from sockets.\n        \"\"\"\n        with self._main_lock:\n            if self._command_socket is not None:\n                try:\n                    self._command_socket.shutdown(socket.SHUT_RDWR)\n                    self._command_socket.close()  # This will unblock the call to read()\n                except Exception:\n                    pass\n            if self._monitor_socket is not None:\n                try:\n                    self._monitor_socket.shutdown(socket.SHUT_RDWR)\n                    self._monitor_socket.close()  # This will unblock the call to read()\n                except Exception:\n                    pass\n            if self._rx_thread is not None:\n                self._rx_thread.join(timeout=self.default_timeout)\n                self._rx_thread = None\n            if self._monitor_rx_thread is not None:\n                self._monitor_rx_thread.join(timeout=self.default_timeout)\n                self._monitor_rx_thread = None", "hash": "bb82e6a97177", "chunk_type": "method", "node_type": "function_definition", "signature": "_shut_down_socket_threads(self)", "docstring": "Attempt to gracefully shut down threads which read from sockets.", "chunk_size_bytes": 1050, "original_size_bytes": 1445, "start_byte": 173738, "end_byte": 175183}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:9f9aeff25e46", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_checkpoint_internal", "qualified_name": "_Robot._set_checkpoint_internal", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3811, 3828], "text": "def _set_checkpoint_internal(self) -> InterruptableEvent:\n        \"\"\"Set a checkpoint for internal use using the next available internal id.\n        Return\n        ------\n        Checkpoint object\n            Object to use to wait for the checkpoint.\n        \"\"\"\n        with self._main_lock:\n            checkpoint_id = self._internal_checkpoint_counter\n            self._internal_checkpoint_counter += 1\n            if self._internal_checkpoint_counter > _CHECKPOINT_ID_MAX_PRIVATE:\n                self._internal_checkpoint_counter = MX_CHECKPOINT_ID_MAX + 1\n            return self._set_checkpoint_impl(checkpoint_id)", "hash": "9f9aeff25e46", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_checkpoint_internal(self)", "docstring": "Set a checkpoint for internal use using the next available internal id.\n\n        Return\n        ------\n        Checkpoint object\n            Object to use to wait for the checkpoint.", "chunk_size_bytes": 621, "original_size_bytes": 678, "start_byte": 175189, "end_byte": 175867}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f0913629182f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_checkpoint_impl", "qualified_name": "_Robot._set_checkpoint_impl", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3830, 3875], "text": "def _set_checkpoint_impl(self, n, send_to_robot=True) -> InterruptableEvent:\n        \"\"\"Create a checkpoint object which can be used to wait for the checkpoint id to be received from the robot.\n        Checkpoints are implemented as a dictionary of lists, to support repeated checkpoints (which are discouraged),\n        and also to support expecting external checkpoints. Particularly so that ExpectExternalCheckpoints could be\n        called in any arbitrary order.\n        Returning an event object for the user to wait on also prevents activated checkpoints from being 'missed' by the\n        API, and prevents issues around waiting for checkpoints which may never arrive.\n        Parameters\n        ----------\n        n : int\n            Id of checkpoint.\n        send_to_robot : bool\n            If true, send the SetCheckpoint command to the robot.\n        Return\n        ------\n        Checkpoint object\n            Object to use to wait for the checkpoint.\n        \"\"\"\n        with self._main_lock:\n            if not isinstance(n, int):\n                raise TypeError('Please provide an integer checkpoint id.')\n            if MX_CHECKPOINT_ID_MIN <= n <= MX_CHECKPOINT_ID_MAX:\n                checkpoints_dict = self._user_checkpoints\n            elif MX_CHECKPOINT_ID_MAX < n <= _CHECKPOINT_ID_MAX_PRIVATE:\n                checkpoints_dict = self._internal_checkpoints\n            else:\n                raise ValueError\n            self.logger.debug(f'Setting checkpoint {n}')\n            if n not in checkpoints_dict:\n                checkpoints_dict[n] = list()\n            event = InterruptableEvent(n)\n            checkpoints_dict[n].append(event)\n            if send_to_robot:\n                self._send_command('SetCheckpoint', [n])\n            return event", "hash": "f0913629182f", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_checkpoint_impl(self, n, send_to_robot=True)", "docstring": "Create a checkpoint object which can be used to wait for the checkpoint id to be received from the robot.\n\n        Checkpoints are implemented as a dictionary of lists, to support repeated checkpoints (which are discouraged),\n        and also to support expecting external checkpoints. Particularly so that ExpectExternalCheckpoints could be\n        called in any arbitrary order.\n\n        Returning an event object for the user to wait on also prevents activated checkpoints from being 'missed' by the\n        API, and prevents issues around waiting for checkpoints which may never arrive.\n\n        Parameters\n        ----------\n        n : int\n            Id of checkpoint.\n        send_to_robot : bool\n            If true, send the SetCheckpoint command to the robot.\n\n        Return\n        ------\n        Checkpoint object\n            Object to use to wait for the checkpoint.", "chunk_size_bytes": 1776, "original_size_bytes": 1849, "start_byte": 175873, "end_byte": 177722}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:733090ea0fd8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_invalidate_checkpoints", "qualified_name": "_Robot._invalidate_checkpoints", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3877, 3895], "text": "def _invalidate_checkpoints(self, message, forced: bool):\n        \"\"\"Unblock all waiting checkpoints and have them throw InterruptException\n        Args:\n            message (str): Message for the user that describes why the checkpoint was discarded.\n            forced (bool): True  -> Force discarding checkpoints\n                           False -> Discard only if robot has older version not supporting MX_ST_CHECKPOINT_DISCARDED\n        \"\"\"\n        if not forced and self._robot_info.supports_checkpoint_discarded:\n            return\n        for checkpoints_dict in [self._internal_checkpoints, self._user_checkpoints]:\n            for checkpoints_list in checkpoints_dict.values():\n                for event in checkpoints_list:\n                    event.abort(message)\n            checkpoints_dict.clear()\n        self._internal_checkpoint_counter = MX_CHECKPOINT_ID_MAX + 1", "hash": "733090ea0fd8", "chunk_type": "method", "node_type": "function_definition", "signature": "_invalidate_checkpoints(self, message, forced: bool)", "docstring": "Unblock all waiting checkpoints and have them throw InterruptException\n\n        Args:\n            message (str): Message for the user that describes why the checkpoint was discarded.\n            forced (bool): True  -> Force discarding checkpoints\n                           False -> Discard only if robot has older version not supporting MX_ST_CHECKPOINT_DISCARDED", "chunk_size_bytes": 881, "original_size_bytes": 993, "start_byte": 177728, "end_byte": 178721}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:23dc54e12ab0", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_send_motion_command", "qualified_name": "_Robot._send_motion_command", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3897, 3915], "text": "def _send_motion_command(self, command: str, args: Union[str, list, tuple] = None):\n        \"\"\"Send generic motion command with support for synchronous mode and locking.\n        Parameters\n        ----------\n        command : string\n            The command to send.\n        args : list\n            List of arguments to be sent.\n        \"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command(command, args)\n            if self._enable_synchronous_mode:\n                checkpoint = self._set_checkpoint_internal()\n        if self._enable_synchronous_mode:\n            checkpoint.wait()", "hash": "23dc54e12ab0", "chunk_type": "method", "node_type": "function_definition", "signature": "_send_motion_command(self, command: str, args: Union[str, list, tuple] = None)", "docstring": "Send generic motion command with support for synchronous mode and locking.\n\n        Parameters\n        ----------\n        command : string\n            The command to send.\n        args : list\n            List of arguments to be sent.", "chunk_size_bytes": 636, "original_size_bytes": 639, "start_byte": 178727, "end_byte": 179366}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:383ad7fba124", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_send_immediate_command", "qualified_name": "_Robot._send_immediate_command", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3917, 3933], "text": "def _send_immediate_command(self, command: str, args: Optional[Union[str, list, tuple]],\n                                event: Optional[InterruptableEvent]):\n        \"\"\"Send generic 'immediate' command with support for synchronous mode and locking.\n        Parameters\n        ----------\n        command : string\n            The command to send.\n        args : list\n            List of arguments to be sent.\n        \"\"\"\n        if self._enable_synchronous_mode:\n            self._send_sync_command(command, args, event, timeout=self.default_timeout)\n        else:\n            with self._main_lock:\n                self._send_command(command, args)", "hash": "383ad7fba124", "chunk_type": "method", "node_type": "function_definition", "signature": "_send_immediate_command(self, command: str, args: Optional[Union[str, list, tuple]],\n                                event: Optional[InterruptableEvent])", "docstring": "Send generic 'immediate' command with support for synchronous mode and locking.\n\n        Parameters\n        ----------\n        command : string\n            The command to send.\n        args : list\n            List of arguments to be sent.", "chunk_size_bytes": 647, "original_size_bytes": 649, "start_byte": 179372, "end_byte": 180021}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:df41afb7ce57", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_monitor_rx_handler", "qualified_name": "_Robot._monitor_rx_handler", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3935, 3970], "text": "def _monitor_rx_handler(self):\n        \"\"\"Handle messages from the monitoring port of the robot.\n        \"\"\"\n        while True:\n            response: Message = self._monitor_rx_queue.get(block=True)\n            if response == _TERMINATE:\n                break\n            self._callback_queue.put('on_monitor_message', response)\n            queue_size = self._monitor_rx_queue.qsize()\n            if queue_size > self._robot_rt_data.max_queue_size:\n                self._robot_rt_data.max_queue_size = queue_size\n            with self._main_lock:\n                self._handle_common_messages(message=response)\n                if not self._robot_info.rt_message_capable and response.id == mx_st.MX_ST_GET_POSE:\n                    self._robot_events.on_end_of_cycle.set()\n                    self._callback_queue.put('on_end_of_cycle')\n                    if self._file_logger:\n                        self._file_logger.write_fields(time.time_ns() / 1000, self._robot_rt_data)\n                    self._make_stable_rt_data()\n            self._invalidate_interruptable_events(message=\"Monitoring socket disconnected\")", "hash": "df41afb7ce57", "chunk_type": "method", "node_type": "function_definition", "signature": "_monitor_rx_handler(self)", "docstring": "Handle messages from the monitoring port of the robot.", "chunk_size_bytes": 1116, "original_size_bytes": 1635, "start_byte": 180027, "end_byte": 181662}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:44d2b62ca5de", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_make_stable_rt_data", "qualified_name": "_Robot._make_stable_rt_data", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3972, 3984], "text": "def _make_stable_rt_data(self):\n        \"\"\"We have to create stable copy of rt_data, with consistent timestamp values for all attributes.\n        This consistent copy is used by GetRobotRtData()\n        \"\"\"\n        self._robot_rt_data_stable = copy.deepcopy(self._robot_rt_data)\n        self._robot_rt_data_stable.clear_if_outdated()\n        self._robot_rt_data_stable.clear_if_disabled()", "hash": "44d2b62ca5de", "chunk_type": "method", "node_type": "function_definition", "signature": "_make_stable_rt_data(self)", "docstring": "We have to create stable copy of rt_data, with consistent timestamp values for all attributes.\n        This consistent copy is used by GetRobotRtData()", "chunk_size_bytes": 388, "original_size_bytes": 578, "start_byte": 181668, "end_byte": 182246}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:4be6c7d97ea8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_cleanup_custom_response_events", "qualified_name": "_Robot._cleanup_custom_response_events", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3986, 3997], "text": "def _cleanup_custom_response_events(self):\n        \"\"\"Remove from custom response event list any event that is no more referenced by anyone\n           (this is a list of weakref so they get destroyed automatically when no external code is holding a ref to\n           that interruptable event, so as cleanup here we simply remove the weakref object from the list)\"\"\"\n        events_to_delete = []\n        for event_weakref in self._custom_response_events:\n            if event_weakref() is None:\n                events_to_delete.append(event_weakref)\n        for event_weakref in events_to_delete:\n            self._custom_response_events.remove(event_weakref)", "hash": "4be6c7d97ea8", "chunk_type": "method", "node_type": "function_definition", "signature": "_cleanup_custom_response_events(self)", "docstring": "Remove from custom response event list any event that is no more referenced by anyone\n           (this is a list of weakref so they get destroyed automatically when no external code is holding a ref to\n           that interruptable event, so as cleanup here we simply remove the weakref object from the list)", "chunk_size_bytes": 659, "original_size_bytes": 833, "start_byte": 182252, "end_byte": 183085}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:eb14594adc21", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_awake_custom_response_events", "qualified_name": "_Robot._awake_custom_response_events", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [3999, 4014], "text": "def _awake_custom_response_events(self, response: Message):\n        \"\"\" Awake waitable events created by _send_custom_command calls that match a received response \"\"\"\n        matched_events = []\n        for event_weakref in self._custom_response_events:\n            for to_match in event_weakref().data:\n                if isinstance(to_match, Message):\n                    if response.id == to_match.id and response.data == to_match.data:\n                        matched_events.append(event_weakref)\n                else:\n                    if response.id == to_match:\n                        matched_events.append(event_weakref)\n        for event_weakref in matched_events:\n            event_weakref().set(data=response)\n            self._custom_response_events.remove(event_weakref)", "hash": "eb14594adc21", "chunk_type": "method", "node_type": "function_definition", "signature": "_awake_custom_response_events(self, response: Message)", "docstring": "Awake waitable events created by _send_custom_command calls that match a received response", "chunk_size_bytes": 786, "original_size_bytes": 967, "start_byte": 183091, "end_byte": 184058}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:7124afe5f20a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_invalidate_interruptable_events", "qualified_name": "_Robot._invalidate_interruptable_events", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4016, 4021], "text": "def _invalidate_interruptable_events(self, message=\"\"):\n        \"\"\" Unblock all appropriate interruptable events and have them throw InterruptException.\"\"\"\n        for event_weakref in self._custom_response_events:\n            event: InterruptableEvent = event_weakref()\n            if event:\n                event.abort(message)", "hash": "7124afe5f20a", "chunk_type": "method", "node_type": "function_definition", "signature": "_invalidate_interruptable_events(self, message=\"\")", "docstring": "Unblock all appropriate interruptable events and have them throw InterruptException.", "chunk_size_bytes": 329, "original_size_bytes": 329, "start_byte": 184064, "end_byte": 184393}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:bd53735a904c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_invalidate_interruptable_events_on_error", "qualified_name": "_Robot._invalidate_interruptable_events_on_error", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4023, 4030], "text": "def _invalidate_interruptable_events_on_error(self, message=\"\"):\n        \"\"\"Following robot entering error state, unblock all appropriate interruptable events and have them\n        throw InterruptException.\"\"\"\n        for event_weakref in self._custom_response_events:\n            event: InterruptableEvent = event_weakref()\n            if event and event._abort_on_error:\n                event.abort(message)", "hash": "bd53735a904c", "chunk_type": "method", "node_type": "function_definition", "signature": "_invalidate_interruptable_events_on_error(self, message=\"\")", "docstring": "Following robot entering error state, unblock all appropriate interruptable events and have them\n        throw InterruptException.", "chunk_size_bytes": 409, "original_size_bytes": 455, "start_byte": 184399, "end_byte": 184854}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:bb362221e426", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_invalidate_interruptable_events_on_clear_motion", "qualified_name": "_Robot._invalidate_interruptable_events_on_clear_motion", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4032, 4039], "text": "def _invalidate_interruptable_events_on_clear_motion(self, message=\"\"):\n        \"\"\"Following robot motion cleared, unblock all appropriate interruptable events and have them\n        throw InterruptException.\"\"\"\n        for event_weakref in self._custom_response_events:\n            event: InterruptableEvent = event_weakref()\n            if event and event._abort_on_clear_motion:\n                event.abort(message)", "hash": "bb362221e426", "chunk_type": "method", "node_type": "function_definition", "signature": "_invalidate_interruptable_events_on_clear_motion(self, message=\"\")", "docstring": "Following robot motion cleared, unblock all appropriate interruptable events and have them\n        throw InterruptException.", "chunk_size_bytes": 417, "original_size_bytes": 463, "start_byte": 184860, "end_byte": 185323}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:5a16fff9de43", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_rx_handler_fct", "qualified_name": "_Robot._rx_handler_fct", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4041, 4063], "text": "def _rx_handler_fct(self):\n        \"\"\"Handle received messages on the command socket.\n        \"\"\"\n        while True:\n            response = self._command_rx_queue.get(block=True)\n            if response == _TERMINATE:\n                break\n            self._callback_queue.put('on_command_message', response)\n            with self._main_lock:\n                self._cleanup_custom_response_events()\n                self._awake_custom_response_events(response)\n                self._handle_common_messages(response)\n        message = \"Control socket disconnected\"\n        self._invalidate_checkpoints(message, forced=True)\n        self._invalidate_interruptable_events(message)", "hash": "5a16fff9de43", "chunk_type": "method", "node_type": "function_definition", "signature": "_rx_handler_fct(self)", "docstring": "Handle received messages on the command socket.", "chunk_size_bytes": 676, "original_size_bytes": 793, "start_byte": 185329, "end_byte": 186122}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:9d61ae598687", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_common_messages", "qualified_name": "_Robot._handle_common_messages", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4065, 4092], "text": "def _handle_common_messages(self, message: Message):\n        \"\"\"Handle messages which are received on the command and monitor port, and are processed the same way.\n        Parameters\n        ----------\n        message : Message object\n        \"\"\"\n        self._rx_timestamp = time.monotonic()\n        if message.id in robot_status_code_info:\n            code_info = robot_status_code_info[message.id]\n            if code_info.is_error:\n                self.logger.error(f'Received robot error {code_info.code} ({code_info.name}): {message.data}')\n        else:\n            self.logger.debug(f'Received unknown robot status code {message.id}')\n        callback = self._messages_handlers.get(message.id)\n        if callback:\n            callback(message)\n        else:\n            pass", "hash": "9d61ae598687", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_common_messages(self, message: Message)", "docstring": "Handle messages which are received on the command and monitor port, and are processed the same way.\n\n        Parameters\n        ----------\n        message : Message object", "chunk_size_bytes": 783, "original_size_bytes": 1077, "start_byte": 186128, "end_byte": 187205}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d4179ad3f3af", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_parse_response_bool", "qualified_name": "_Robot._parse_response_bool", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4094, 4100], "text": "def _parse_response_bool(self, response: Message) -> list[bool]:\n        \"\"\" Parse standard robot response, returns array of boolean values\n        \"\"\"\n        if response.data.strip() == '':\n            return []\n        else:\n            return [bool(int(x)) for x in response.data.split(',')]", "hash": "d4179ad3f3af", "chunk_type": "method", "node_type": "function_definition", "signature": "_parse_response_bool(self, response: Message)", "docstring": "Parse standard robot response, returns array of boolean values", "chunk_size_bytes": 295, "original_size_bytes": 295, "start_byte": 187211, "end_byte": 187506}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:14f593ab58a3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_parse_response_int", "qualified_name": "_Robot._parse_response_int", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4102, 4108], "text": "def _parse_response_int(self, response: Message) -> list[int]:\n        \"\"\" Parse standard robot response, returns array of integer values\n        \"\"\"\n        if response.data.strip() == '':\n            return []\n        else:\n            return [int(x) for x in response.data.split(',')]", "hash": "14f593ab58a3", "chunk_type": "method", "node_type": "function_definition", "signature": "_parse_response_int(self, response: Message)", "docstring": "Parse standard robot response, returns array of integer values", "chunk_size_bytes": 287, "original_size_bytes": 287, "start_byte": 187512, "end_byte": 187799}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b3b225df7fb6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_activated", "qualified_name": "_Robot._set_activated", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4110, 4142], "text": "def _set_activated(self, activated: bool):\n        \"\"\"Update the \"activated\" state of the robot\n        Parameters\n        ----------\n        activated : bool\n            Robot is activated or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.activation_state != activated:\n            if activated:\n                if self._first_robot_status_received and self._robot_status.activation_state != activated:\n                    self.logger.info(f'Robot is activated.')\n                self._robot_events.on_deactivated.clear()\n                self._robot_events.on_activated.set()\n                self._set_brakes_engaged(False)\n                self._callback_queue.put('on_activated')\n                if self._robot_info.version.is_at_least(10, 0):\n                    pass  # In this version, we rely on robot status to determine paused state\n                else:\n                    self._set_paused(False)\n            else:\n                if self._first_robot_status_received and self._robot_status.activation_state != activated:\n                    self.logger.info(f'Robot is deactivated.')\n                self._robot_events.on_activated.clear()\n                self._robot_events.on_deactivated.set()\n                self._set_brakes_engaged(True)\n                self._callback_queue.put('on_deactivated')\n                message = 'Robot was deactivated'\n                self._invalidate_checkpoints(message, forced=False)\n                self._invalidate_interruptable_events_on_clear_motion(message)\n            self._robot_status.activation_state = activated", "hash": "b3b225df7fb6", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_activated(self, activated: bool)", "docstring": "Update the \"activated\" state of the robot\n\n        Parameters\n        ----------\n        activated : bool\n            Robot is activated or not", "chunk_size_bytes": 1609, "original_size_bytes": 1689, "start_byte": 187805, "end_byte": 189494}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ca97e0940fcc", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_homed", "qualified_name": "_Robot._set_homed", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4144, 4158], "text": "def _set_homed(self, homed: bool):\n        \"\"\"Update the \"homed\" state of the robot\n        Parameters\n        ----------\n        homed : bool\n            Robot is homed or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.homing_state != homed:\n            if homed:\n                self._robot_events.on_homed.set()\n                self._callback_queue.put('on_homed')\n            else:\n                self._robot_events.on_homed.clear()\n            self._robot_status.homing_state = homed", "hash": "ca97e0940fcc", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_homed(self, homed: bool)", "docstring": "Update the \"homed\" state of the robot\n\n        Parameters\n        ----------\n        homed : bool\n            Robot is homed or not", "chunk_size_bytes": 529, "original_size_bytes": 530, "start_byte": 189500, "end_byte": 190030}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8a43081a8980", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_sim_mode", "qualified_name": "_Robot._set_sim_mode", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4160, 4181], "text": "def _set_sim_mode(self, sim_mode: MxRobotSimulationMode):\n        \"\"\"Update the \"sim_mode\" state of the robot\n        Parameters\n        ----------\n        sim_mode : MxRobotSimulationMode\n            Robot simulation mode\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.simulation_mode != sim_mode:\n            if sim_mode == MxRobotSimulationMode.MX_SIM_MODE_DISABLED:\n                self._robot_events.on_activate_sim.clear()\n                self._robot_events.on_deactivate_sim.set()\n                self._callback_queue.put('on_deactivate_sim')\n            else:\n                self._robot_events.on_deactivate_sim.clear()\n                self._robot_events.on_activate_sim.set()\n                self._callback_queue.put('on_activate_sim')\n            self._robot_status.simulation_mode = sim_mode\n            if (self._robot_events.on_activate_ext_tool_sim.is_set()\n                    and self._robot_status.simulation_mode == MxRobotSimulationMode.MX_SIM_MODE_DISABLED):\n                self._handle_ext_tool_sim_status(self._external_tool_status.sim_tool_type)", "hash": "8a43081a8980", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_sim_mode(self, sim_mode: MxRobotSimulationMode)", "docstring": "Update the \"sim_mode\" state of the robot\n\n        Parameters\n        ----------\n        sim_mode : MxRobotSimulationMode\n            Robot simulation mode", "chunk_size_bytes": 1106, "original_size_bytes": 1202, "start_byte": 190036, "end_byte": 191238}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:65069cfdec06", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_recovery_mode", "qualified_name": "_Robot._set_recovery_mode", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4183, 4200], "text": "def _set_recovery_mode(self, recovery_mode: bool):\n        \"\"\"Update the \"recovery_mode\" state of the robot\n        Parameters\n        ----------\n        recovery_mode : bool\n            Robot is in recovery mode or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.recovery_mode != recovery_mode:\n            if recovery_mode:\n                self._robot_events.on_deactivate_recovery_mode.clear()\n                self._robot_events.on_activate_recovery_mode.set()\n                self._callback_queue.put('on_activate_recovery_mode')\n            else:\n                self._robot_events.on_activate_recovery_mode.clear()\n                self._robot_events.on_deactivate_recovery_mode.set()\n                self._callback_queue.put('on_deactivate_recovery_mode')\n            self._robot_status.recovery_mode = recovery_mode", "hash": "65069cfdec06", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_recovery_mode(self, recovery_mode: bool)", "docstring": "Update the \"recovery_mode\" state of the robot\n\n        Parameters\n        ----------\n        recovery_mode : bool\n            Robot is in recovery mode or not", "chunk_size_bytes": 861, "original_size_bytes": 862, "start_byte": 191244, "end_byte": 192106}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:e65e4c3d39e7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_error_status", "qualified_name": "_Robot._set_error_status", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4202, 4228], "text": "def _set_error_status(self, error_status: bool, error_code: Optional[int] = None):\n        \"\"\"Update the \"error\" state of the robot\n        Parameters\n        ----------\n        error_status : bool\n            Robot is in error or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.error_status != error_status:\n            if error_status:\n                message = \"robot is in error\"\n                self._invalidate_checkpoints(message, forced=False)\n                self._invalidate_interruptable_events_on_error(message)\n                self._robot_events.on_error.set()\n                self._robot_events.abort_all_on_error(message)\n                self._robot_events.on_error_reset.clear()\n                self._callback_queue.put('on_error')\n                self._set_paused(True)\n            else:\n                self._robot_events.clear_abort_all()\n                self._robot_events.on_error.clear()\n                self._robot_events.on_error_reset.set()\n                self._callback_queue.put('on_error_reset')\n            self._robot_status.error_status = error_status\n        self._robot_status.error_code = error_code", "hash": "e65e4c3d39e7", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_error_status(self, error_status: bool, error_code: Optional[int] = None)", "docstring": "Update the \"error\" state of the robot\n\n        Parameters\n        ----------\n        error_status : bool\n            Robot is in error or not", "chunk_size_bytes": 1173, "original_size_bytes": 1252, "start_byte": 192112, "end_byte": 193364}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:1f1dba6fe4c7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_paused", "qualified_name": "_Robot._set_paused", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4230, 4248], "text": "def _set_paused(self, paused: bool):\n        \"\"\"Update the \"paused\" state of the robot\n        Parameters\n        ----------\n        paused : bool\n            Robot is paused or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.pause_motion_status != paused:\n            if paused:\n                self._robot_events.on_motion_resumed.clear()\n                self._robot_events.on_motion_paused.set()\n                self._callback_queue.put('on_motion_paused')\n            else:\n                self._robot_events.on_motion_paused.clear()\n                self._robot_events.on_motion_resumed.set()\n                self._callback_queue.put('on_motion_resumed')\n            self._robot_status.pause_motion_status = paused\n        self._check_motion_clear_done()", "hash": "1f1dba6fe4c7", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_paused(self, paused: bool)", "docstring": "Update the \"paused\" state of the robot\n\n        Parameters\n        ----------\n        paused : bool\n            Robot is paused or not", "chunk_size_bytes": 797, "original_size_bytes": 798, "start_byte": 193370, "end_byte": 194168}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:6d84aa0206f5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_eob", "qualified_name": "_Robot._set_eob", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4250, 4264], "text": "def _set_eob(self, eob: bool):\n        \"\"\"Update the \"eob\" state of the robot\n        Parameters\n        ----------\n        eob : bool\n            Robot is end-of-block or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.end_of_block_status != eob:\n            if eob:\n                self._robot_events.on_end_of_block.set()\n            else:\n                self._robot_events.on_end_of_block.clear()\n            self._robot_status.end_of_block_status = eob\n        self._check_motion_clear_done()", "hash": "6d84aa0206f5", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_eob(self, eob: bool)", "docstring": "Update the \"eob\" state of the robot\n\n        Parameters\n        ----------\n        eob : bool\n            Robot is end-of-block or not", "chunk_size_bytes": 537, "original_size_bytes": 538, "start_byte": 194174, "end_byte": 194712}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8be3e55f05b8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_brakes_engaged", "qualified_name": "_Robot._set_brakes_engaged", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4266, 4280], "text": "def _set_brakes_engaged(self, brakes_engaged: bool):\n        \"\"\"Update the \"brakes_engaged\" state of the robot\n        Parameters\n        ----------\n        brakes_engaged : bool\n            Robot brakes are engaged or not\n        \"\"\"\n        self._robot_status.brakes_engaged = brakes_engaged\n        if brakes_engaged:\n            self._robot_events.on_brakes_deactivated.clear()\n            self._robot_events.on_brakes_activated.set()\n        else:\n            self._robot_events.on_brakes_activated.clear()\n            self._robot_events.on_brakes_deactivated.set()", "hash": "8be3e55f05b8", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_brakes_engaged(self, brakes_engaged: bool)", "docstring": "Update the \"brakes_engaged\" state of the robot\n\n        Parameters\n        ----------\n        brakes_engaged : bool\n            Robot brakes are engaged or not", "chunk_size_bytes": 570, "original_size_bytes": 571, "start_byte": 194718, "end_byte": 195289}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:0c9e816a09af", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_connection_watchdog_enabled", "qualified_name": "_Robot._set_connection_watchdog_enabled", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4282, 4283], "text": "def _set_connection_watchdog_enabled(self, enabled: bool):\n        self._robot_status.connection_watchdog_enabled = enabled", "hash": "0c9e816a09af", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_connection_watchdog_enabled(self, enabled: bool)", "docstring": null, "chunk_size_bytes": 123, "original_size_bytes": 123, "start_byte": 195295, "end_byte": 195418}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:49cfbdebe60d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_robot_operation_mode", "qualified_name": "_Robot._set_robot_operation_mode", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4285, 4295], "text": "def _set_robot_operation_mode(self, robot_operation_mode: MxRobotOperationMode):\n        \"\"\"Update the \"robot_operation_mode\" from robot safety status\n        Parameters\n        ----------\n        robot_operation_mode : MxRobotOperationMode\n            New robot operation mode to set in robot state\n        \"\"\"\n        self._robot_safety_status.robot_operation_mode = robot_operation_mode\n        self._callback_queue.put('on_safety_stop_state_change')", "hash": "49cfbdebe60d", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_robot_operation_mode(self, robot_operation_mode: MxRobotOperationMode)", "docstring": "Update the \"robot_operation_mode\" from robot safety status\n\n        Parameters\n        ----------\n        robot_operation_mode : MxRobotOperationMode\n            New robot operation mode to set in robot state", "chunk_size_bytes": 453, "original_size_bytes": 518, "start_byte": 195424, "end_byte": 195942}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:5d5e5dbe2dec", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_reset_ready", "qualified_name": "_Robot._set_reset_ready", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4297, 4307], "text": "def _set_reset_ready(self, reset_ready: bool):\n        \"\"\"Update the \"reset_ready\" from robot safety status\n        Parameters\n        ----------\n        reset_ready : bool\n            New flag to set in robot state\n        \"\"\"\n        self._robot_safety_status.reset_ready = reset_ready\n        self._callback_queue.put('on_safety_stop_state_change')", "hash": "5d5e5dbe2dec", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_reset_ready(self, reset_ready: bool)", "docstring": "Update the \"reset_ready\" from robot safety status\n\n        Parameters\n        ----------\n        reset_ready : bool\n            New flag to set in robot state", "chunk_size_bytes": 351, "original_size_bytes": 416, "start_byte": 195948, "end_byte": 196364}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:486a3f49d086", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_check_motion_clear_done", "qualified_name": "_Robot._check_motion_clear_done", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4309, 4317], "text": "def _check_motion_clear_done(self):\n        \"\"\"This function will set (unblock) on_motion_cleared once motion clear is confirmed, i.e. once no more\n           ClearMotion response is pending and once EOB is confirmed.\"\"\"\n        wait_for_eob = self.GetRobotInfo().version.is_at_least(9, 3, 0)\n        if not self._robot_events.on_motion_cleared.is_set():\n            if self._clear_motion_requests == 0:\n                if not wait_for_eob or (self._robot_status.end_of_block_status\n                                        and self._robot_status.pause_motion_status):\n                    self._robot_events.on_motion_cleared.set()", "hash": "486a3f49d086", "chunk_type": "method", "node_type": "function_definition", "signature": "_check_motion_clear_done(self)", "docstring": "This function will set (unblock) on_motion_cleared once motion clear is confirmed, i.e. once no more\n           ClearMotion response is pending and once EOB is confirmed.", "chunk_size_bytes": 630, "original_size_bytes": 630, "start_byte": 196370, "end_byte": 197000}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c1003db0c1f3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_get_joints_legacy", "qualified_name": "_Robot._handle_get_joints_legacy", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4319, 4328], "text": "def _handle_get_joints_legacy(self, response: Message):\n        if self._robot_info.rt_message_capable:\n            self._tmp_rt_joint_pos = string_to_numbers(response.data)\n        else:  # not self._robot_info.rt_message_capable\n            self._robot_rt_data.rt_target_joint_pos.data = string_to_numbers(response.data)\n            self._robot_rt_data.rt_target_joint_pos.enabled = True\n            if self._is_in_sync():\n                self._robot_events.on_joints_updated.set()", "hash": "c1003db0c1f3", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_get_joints_legacy(self, response: Message)", "docstring": null, "chunk_size_bytes": 483, "original_size_bytes": 672, "start_byte": 197006, "end_byte": 197678}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a87ed5cb44f4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_get_pose_legacy", "qualified_name": "_Robot._handle_get_pose_legacy", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4330, 4339], "text": "def _handle_get_pose_legacy(self, response: Message):\n        if self._robot_info.rt_message_capable:\n            self._tmp_rt_cart_pos = string_to_numbers(response.data)\n        else:  # not self._robot_info.rt_message_capable\n            self._robot_rt_data.rt_target_cart_pos.data = string_to_numbers(response.data)\n            self._robot_rt_data.rt_target_cart_pos.enabled = True\n            if self._is_in_sync():\n                self._robot_events.on_pose_updated.set()", "hash": "a87ed5cb44f4", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_get_pose_legacy(self, response: Message)", "docstring": null, "chunk_size_bytes": 476, "original_size_bytes": 664, "start_byte": 197684, "end_byte": 198348}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b59f6319d661", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_get_conf_legacy", "qualified_name": "_Robot._handle_get_conf_legacy", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4341, 4345], "text": "def _handle_get_conf_legacy(self, response: Message):\n        if not self._robot_info.rt_message_capable:\n            self._robot_rt_data.rt_target_conf.data = string_to_numbers(response.data)\n            self._robot_rt_data.rt_target_conf.enabled = True", "hash": "b59f6319d661", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_get_conf_legacy(self, response: Message)", "docstring": null, "chunk_size_bytes": 254, "original_size_bytes": 350, "start_byte": 198354, "end_byte": 198704}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:1efb70bf93f6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_get_conf_turn_legacy", "qualified_name": "_Robot._handle_get_conf_turn_legacy", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4347, 4351], "text": "def _handle_get_conf_turn_legacy(self, response: Message):\n        if not self._robot_info.rt_message_capable:\n            self._robot_rt_data.rt_target_conf_turn.data = string_to_numbers(response.data)\n            self._robot_rt_data.rt_target_conf_turn.enabled = True", "hash": "1efb70bf93f6", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_get_conf_turn_legacy(self, response: Message)", "docstring": null, "chunk_size_bytes": 269, "original_size_bytes": 370, "start_byte": 198710, "end_byte": 199080}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:0b8cde395e40", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_cycle_end", "qualified_name": "_Robot._handle_cycle_end", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4353, 4376], "text": "def _handle_cycle_end(self, response: Message):\n        \"\"\"Handle a robot message of type mx_st.MX_ST_RT_CYCLE_END\"\"\"\n        self._robot_rt_data.cycle_count += 1\n        if not self._robot_info.rt_message_capable:\n            self._robot_info.rt_message_capable = True\n        timestamp = int(response.data)\n        self._robot_events.on_end_of_cycle.set()\n        self._callback_queue.put('on_end_of_cycle')\n        if self._tmp_rt_joint_pos:\n            self._robot_rt_data.rt_target_joint_pos.update_from_data(timestamp, self._tmp_rt_joint_pos)\n            self._tmp_rt_joint_pos = None\n        if self._tmp_rt_cart_pos:\n            self._robot_rt_data.rt_target_cart_pos.update_from_data(timestamp, self._tmp_rt_cart_pos)\n            self._tmp_rt_cart_pos = None\n        if self._file_logger:\n            self._file_logger.write_fields(timestamp, self._robot_rt_data)\n        self._make_stable_rt_data()\n        self._refresh_auto_connection_watchdog()", "hash": "0b8cde395e40", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_cycle_end(self, response: Message)", "docstring": "Handle a robot message of type mx_st.MX_ST_RT_CYCLE_END", "chunk_size_bytes": 957, "original_size_bytes": 1220, "start_byte": 199086, "end_byte": 200306}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:961dc57cd564", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_refresh_auto_connection_watchdog", "qualified_name": "_Robot._refresh_auto_connection_watchdog", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4378, 4395], "text": "def _refresh_auto_connection_watchdog(self, force=False):\n        \"\"\"Send a connection watchdog refresh to the robot using appropriate timeout\n        Args:\n            force (bool, optional): Force sending refresh now even if minimum elapsed time is not yet elapsed.\n        \"\"\"\n        if not self._auto_connection_watchdog:\n            return\n        now = time.monotonic()\n        if force or now - self._auto_connection_watchdog_last > 0.01:\n            self._auto_connection_watchdog_last = now\n            timeout = self._monitoring_interval * 4\n            if timeout < 0.25:\n                timeout = 0.25\n            self.ConnectionWatchdog(timeout)", "hash": "961dc57cd564", "chunk_type": "method", "node_type": "function_definition", "signature": "_refresh_auto_connection_watchdog(self, force=False)", "docstring": "Send a connection watchdog refresh to the robot using appropriate timeout\n\n        Args:\n            force (bool, optional): Force sending refresh now even if minimum elapsed time is not yet elapsed.", "chunk_size_bytes": 659, "original_size_bytes": 839, "start_byte": 200312, "end_byte": 201151}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ffd6a98974b4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_robot_status_response", "qualified_name": "_Robot._handle_robot_status_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4397, 4474], "text": "def _handle_robot_status_response(self, response: Message):\n        \"\"\"Parse robot status response and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_STATUS_ROBOT\n        if response.json_data:\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n            json_robot_status: Optional[dict] = None\n            json_motion_status: Optional[dict] = None\n            json_safety_status: Optional[dict] = None\n            if MX_JSON_KEY_ROBOT_STATUS in json_data and isinstance(json_data[MX_JSON_KEY_ROBOT_STATUS], dict):\n                json_robot_status = json_data[MX_JSON_KEY_ROBOT_STATUS]\n            if MX_JSON_KEY_MOTION_STATUS in json_data and isinstance(json_data[MX_JSON_KEY_MOTION_STATUS], dict):\n                json_motion_status = json_data[MX_JSON_KEY_MOTION_STATUS]\n            if MX_JSON_KEY_SAFETY_STATUS in json_data and isinstance(json_data[MX_JSON_KEY_SAFETY_STATUS], dict):\n                json_safety_status = json_data[MX_JSON_KEY_SAFETY_STATUS]\n            if json_robot_status is None:\n                json_robot_status = json_data\n            if json_robot_status is not None:\n                self._set_activated(\n                    json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_STATE, 0) >= MxRobotState.MX_ROBOT_STATE_ACTIVATED)\n                self._set_homed(\n                    json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_STATE, 0) == MxRobotState.MX_ROBOT_STATE_RUN)\n                self._set_sim_mode(MxRobotSimulationMode(json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_SIM, 0)))\n                self._set_recovery_mode(bool(json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_RECOVERY, False)))\n                error_code = int(json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_ERR, 0))\n                self._set_error_status(error_status=error_code != 0, error_code=error_code)\n                self._set_brakes_engaged(bool(json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_BRAKES, False)))\n            if json_motion_status is not None:\n                self._set_paused(bool(json_motion_status.get(MX_JSON_KEY_MOTION_STATUS_HOLD, False)))\n                self._set_eob(bool(json_motion_status.get(MX_JSON_KEY_MOTION_STATUS_EOB, False)))\n            if json_safety_status is not None:\n                self._set_reset_ready(bool(json_safety_status.get(MX_JSON_KEY_SAFETY_STATUS_RESET_READY, False)))\n                if (MX_JSON_KEY_SAFETY_STOP in json_safety_status\n                        and isinstance(json_safety_status[MX_JSON_KEY_SAFETY_STOP], dict)):\n                    json_safety_stop: dict = json_safety_status[MX_JSON_KEY_SAFETY_STOP]\n                    self._robot_psu_inputs.set_psu_input_mask(\n                        int(json_safety_stop.get(MX_JSON_KEY_SAFETY_PSU_INPUTS_MASK, 0)))\n                if (MX_JSON_KEY_SAFETY_STOP_STATIC_MASKS in json_safety_status\n                        and isinstance(json_safety_status[MX_JSON_KEY_SAFETY_STOP_STATIC_MASKS], dict)):\n                    json_stop_masks: dict = json_safety_status[MX_JSON_KEY_SAFETY_STOP_STATIC_MASKS]\n                    self._robot_safety_status.static_masks.clearedByPsu = int(\n                        json_stop_masks.get(MX_JSON_KEY_MASK_CLEARED_BY_PSU, 0))\n                    self._robot_safety_status.static_masks.withVmOff = int(\n                        json_stop_masks.get(MX_JSON_KEY_MASK_WITH_VM_OFF, 0))\n                    if MX_JSON_KEY_MASK_MANUAL_MODE in json_stop_masks:\n                        self._robot_safety_status.static_masks.maskedInManualMode = int(\n                            json_stop_masks.get(MX_JSON_KEY_MASK_MANUAL_MODE, 0))\n                    else:\n                        self._robot_safety_status.static_masks.maskedInManualMode = int(\n                            MxSafeStopCategory.MX_SAFE_STOP_PSTOP1) | int(MxSafeStopCategory.MX_SAFE_STOP_PSTOP2)\n        else:\n            status_flags = self._parse_response_bool(response)\n            self._set_activated(status_flags[0])\n            self._set_homed(status_flags[1])\n            self._set_sim_mode(MxRobotSimulationMode(status_flags[2]))\n            self._set_error_status(status_flags[3])\n            self._set_paused(status_flags[4])\n            self._set_eob(status_flags[5])\n        self._first_robot_status_received = True\n        if self._is_in_sync():\n            self._robot_events.on_status_updated.set()\n        self._callback_queue.put('on_status_updated')", "hash": "ffd6a98974b4", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_robot_status_response(self, response: Message)", "docstring": "Parse robot status response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 4508, "original_size_bytes": 4860, "start_byte": 201157, "end_byte": 206017}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:9fdf367ca88a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_collision_status_response", "qualified_name": "_Robot._handle_collision_status_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4476, 4487], "text": "def _handle_collision_status_response(self, response: Message):\n        \"\"\"Parse robot collision status response and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_COLLISION_STATUS\n        parsed_response = self._parse_response_int(response)\n        status = self._robot_collision_status.self_collision_status\n        status.set_from_response(parsed_response)", "hash": "9fdf367ca88a", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_collision_status_response(self, response: Message)", "docstring": "Parse robot collision status response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 475, "original_size_bytes": 477, "start_byte": 206023, "end_byte": 206500}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:2b2e11f0dae5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_work_zone_status_response", "qualified_name": "_Robot._handle_work_zone_status_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4489, 4500], "text": "def _handle_work_zone_status_response(self, response: Message):\n        \"\"\"Parse robot work zone status response and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_WORK_ZONE_STATUS\n        parsed_response = self._parse_response_int(response)\n        status = self._robot_collision_status.work_zone_status\n        status.set_from_response(parsed_response)", "hash": "2b2e11f0dae5", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_work_zone_status_response(self, response: Message)", "docstring": "Parse robot work zone status response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 470, "original_size_bytes": 472, "start_byte": 206506, "end_byte": 206978}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:294d03f3a8e8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_robot_get_robot_serial_response", "qualified_name": "_Robot._handle_robot_get_robot_serial_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4502, 4513], "text": "def _handle_robot_get_robot_serial_response(self, response: Message):\n        \"\"\"Parse get robot serial response and robot info.\n        Parameters\n        ----------\n        response : Message object\n            GetRobotSerial response to parse and save.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_ROBOT_SERIAL\n        self._robot_info.serial = response.data", "hash": "294d03f3a8e8", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_robot_get_robot_serial_response(self, response: Message)", "docstring": "Parse get robot serial response and robot info.\n\n        Parameters\n        ----------\n        response : Message object\n            GetRobotSerial response to parse and save.", "chunk_size_bytes": 374, "original_size_bytes": 377, "start_byte": 206984, "end_byte": 207361}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:98fc1b9c791d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_gripper_status_response", "qualified_name": "_Robot._handle_gripper_status_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4515, 4536], "text": "def _handle_gripper_status_response(self, response: Message):\n        \"\"\"Parse gripper status response and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n            Gripper status response to parse and handle.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_STATUS_GRIPPER\n        status_flags = self._parse_response_bool(response)\n        self._gripper_status.present = status_flags[0]\n        self._gripper_status.homing_state = status_flags[1]\n        self._gripper_status.holding_part = status_flags[2]\n        self._gripper_status.target_pos_reached = status_flags[3]\n        self._gripper_status.error_status = status_flags[4]\n        self._gripper_status.overload_error = status_flags[5]\n        if self._is_in_sync():\n            self._robot_events.on_status_gripper_updated.set()\n            self._callback_queue.put('on_status_gripper_updated')", "hash": "98fc1b9c791d", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_gripper_status_response(self, response: Message)", "docstring": "Parse gripper status response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Gripper status response to parse and handle.", "chunk_size_bytes": 923, "original_size_bytes": 927, "start_byte": 207367, "end_byte": 208294}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:76874de835a2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_ext_tool_sim_status", "qualified_name": "_Robot._handle_ext_tool_sim_status", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4538, 4555], "text": "def _handle_ext_tool_sim_status(self, tool_type: int):\n        \"\"\"Handle gripper sim mode status change event.\n        Parameters\n        ----------\n        tool_type : int\n            New simulated external tool type. `MxExtToolType.MX_EXT_TOOL_NONE` when simulation is off.\n        \"\"\"\n        if tool_type != MxExtToolType.MX_EXT_TOOL_NONE:\n            self._robot_events.on_deactivate_ext_tool_sim.clear()\n            self._robot_events.on_activate_ext_tool_sim.set()\n            self._callback_queue.put('on_activate_ext_tool_sim')\n        else:\n            self._robot_events.on_activate_ext_tool_sim.clear()\n            self._robot_events.on_deactivate_ext_tool_sim.set()\n            self._callback_queue.put('on_deactivate_ext_tool_sim')", "hash": "76874de835a2", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_ext_tool_sim_status(self, tool_type: int)", "docstring": "Handle gripper sim mode status change event.\n\n        Parameters\n        ----------\n        tool_type : int\n            New simulated external tool type. `MxExtToolType.MX_EXT_TOOL_NONE` when simulation is off.", "chunk_size_bytes": 745, "original_size_bytes": 748, "start_byte": 208300, "end_byte": 209048}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:be3f88cfe7b3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_recovery_mode_status", "qualified_name": "_Robot._handle_recovery_mode_status", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4557, 4566], "text": "def _handle_recovery_mode_status(self, enabled: bool):\n        \"\"\"Handle recovery mode status change event.\n        Parameters\n        ----------\n        enabled : bool\n            Recovery mode enabled or not.\n        \"\"\"\n        self._set_recovery_mode(enabled)", "hash": "be3f88cfe7b3", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_recovery_mode_status(self, enabled: bool)", "docstring": "Handle recovery mode status change event.\n\n        Parameters\n        ----------\n        enabled : bool\n            Recovery mode enabled or not.", "chunk_size_bytes": 263, "original_size_bytes": 265, "start_byte": 209054, "end_byte": 209319}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:7e2f1154da4a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_safety_stop_common", "qualified_name": "_Robot._handle_safety_stop_common", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4568, 4594], "text": "def _handle_safety_stop_common(self):\n        \"\"\"Code called after state of any safety stop signal has changed\"\"\"\n        active_safety_stops = self._robot_safety_status.stop_mask & ~self._robot_safety_status.stop_resettable_mask\n        if active_safety_stops != 0:\n            if self._robot_events.on_safety_stop_reset.is_set():\n                self._callback_queue.put('on_safety_stop')\n            self._robot_events.on_safety_stop_reset.clear()\n            self._robot_events.on_safety_stop_resettable.clear()\n        elif self._robot_safety_status.stop_resettable_mask != 0 and active_safety_stops == 0:\n            self._robot_events.on_safety_stop_reset.clear()\n            self._robot_events.on_safety_stop_resettable.set()\n            self._callback_queue.put('on_safety_stop_resettable')\n        elif active_safety_stops == 0:\n            self._robot_events.on_safety_stop_reset.set()\n            self._robot_events.on_safety_stop_resettable.set()\n            self._callback_queue.put('on_safety_stop_reset')\n        self._robot_events.on_safety_stop_state_change.set()\n        self._callback_queue.put('on_safety_stop_state_change')", "hash": "7e2f1154da4a", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_safety_stop_common(self)", "docstring": "Code called after state of any safety stop signal has changed", "chunk_size_bytes": 1145, "original_size_bytes": 1544, "start_byte": 209325, "end_byte": 210869}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:e010e1a5713a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_estop_state", "qualified_name": "_Robot._handle_estop_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4596, 4625], "text": "def _handle_estop_state(self, response: Message):\n        \"\"\"Handle EStop state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_estop_state(self._parse_response_int(response)[0])\n        self._robot_status.estopState = self._robot_safety_status.estop_state\n        if self._robot_safety_status.estop_state == MxStopState.MX_STOP_STATE_ACTIVE:\n            self._robot_events.on_estop.set()\n            self._robot_events.on_estop_reset.clear()\n            self._robot_events.on_estop_resettable.clear()\n            self._callback_queue.put('on_estop')\n        elif self._robot_safety_status.estop_state == MxStopState.MX_STOP_STATE_RESETTABLE:\n            self._robot_events.on_estop.set()\n            self._robot_events.on_estop_reset.clear()\n            self._robot_events.on_estop_resettable.set()\n            self._callback_queue.put('on_estop_resettable')\n        else:\n            self._robot_events.on_estop.clear()\n            self._robot_events.on_estop_reset.set()\n            self._robot_events.on_estop_resettable.set()\n            self._callback_queue.put('on_estop_reset')\n        self._handle_safety_stop_common()", "hash": "e010e1a5713a", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_estop_state(self, response: Message)", "docstring": "Handle EStop state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 1209, "original_size_bytes": 1288, "start_byte": 210875, "end_byte": 212163}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a47fdaedeeeb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_pstop1_state", "qualified_name": "_Robot._handle_pstop1_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4627, 4636], "text": "def _handle_pstop1_state(self, response: Message):\n        \"\"\"Handle PStop1 state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_pstop1_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()", "hash": "a47fdaedeeeb", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_pstop1_state(self, response: Message)", "docstring": "Handle PStop1 state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 305, "original_size_bytes": 307, "start_byte": 212169, "end_byte": 212476}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:3001870c0cd4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_pstop2_state", "qualified_name": "_Robot._handle_pstop2_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4638, 4673], "text": "def _handle_pstop2_state(self, response: Message):\n        \"\"\"Handle PStop2 state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_pstop2_state(self._parse_response_int(response)[0])\n        self._robot_status.pstop2State = self._robot_safety_status.pstop2_state\n        if self._robot_safety_status.pstop2_state == MxStopState.MX_STOP_STATE_ACTIVE:\n            message = 'Robot is in PSTOP2 condition'\n            self._invalidate_checkpoints(message, forced=False)\n            self._invalidate_interruptable_events_on_clear_motion(message)\n        if self._robot_safety_status.pstop2_state == MxStopState.MX_STOP_STATE_ACTIVE:\n            self._robot_events.on_pstop2.set()\n            self._robot_events.on_pstop2_reset.clear()\n            self._robot_events.on_pstop2_resettable.clear()\n            self._callback_queue.put('on_pstop2')\n        elif self._robot_safety_status.pstop2_state == MxStopState.MX_STOP_STATE_RESETTABLE:\n            self._robot_events.on_pstop2.set()\n            self._robot_events.on_pstop2_reset.clear()\n            self._robot_events.on_pstop2_resettable.set()\n            self._callback_queue.put('on_pstop2_resettable')\n        else:\n            self._robot_events.on_pstop2.clear()\n            self._robot_events.on_pstop2_reset.set()\n            self._robot_events.on_pstop2_resettable.set()\n            self._callback_queue.put('on_pstop2_reset')\n        self._handle_safety_stop_common()", "hash": "3001870c0cd4", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_pstop2_state(self, response: Message)", "docstring": "Handle PStop2 state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 1507, "original_size_bytes": 1661, "start_byte": 212482, "end_byte": 214143}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:60c529ec38d5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_operation_mode_stop_state", "qualified_name": "_Robot._handle_operation_mode_stop_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4675, 4684], "text": "def _handle_operation_mode_stop_state(self, response: Message):\n        \"\"\"Handle an operation mode safety stop state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_operation_mode_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()", "hash": "60c529ec38d5", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_operation_mode_stop_state(self, response: Message)", "docstring": "Handle an operation mode safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 354, "original_size_bytes": 356, "start_byte": 214149, "end_byte": 214505}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d353f26e6ce4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_enabling_device_released_stop_state", "qualified_name": "_Robot._handle_enabling_device_released_stop_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4686, 4695], "text": "def _handle_enabling_device_released_stop_state(self, response: Message):\n        \"\"\"Handle an enabling device released safety stop state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_enabling_device_released_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()", "hash": "d353f26e6ce4", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_enabling_device_released_stop_state(self, response: Message)", "docstring": "Handle an enabling device released safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 384, "original_size_bytes": 386, "start_byte": 214511, "end_byte": 214897}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f2216139ec8d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_voltage_fluctuation_stop_state", "qualified_name": "_Robot._handle_voltage_fluctuation_stop_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4697, 4706], "text": "def _handle_voltage_fluctuation_stop_state(self, response: Message):\n        \"\"\"Handle an voltage fluctuation safety stop state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_voltage_fluctuation_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()", "hash": "f2216139ec8d", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_voltage_fluctuation_stop_state(self, response: Message)", "docstring": "Handle an voltage fluctuation safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 369, "original_size_bytes": 371, "start_byte": 214903, "end_byte": 215274}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:2634c53c43a4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_reboot_stop_state", "qualified_name": "_Robot._handle_reboot_stop_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4708, 4717], "text": "def _handle_reboot_stop_state(self, response: Message):\n        \"\"\"Handle a \"robot just rebooted\" safety stop state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_reboot_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()", "hash": "2634c53c43a4", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_reboot_stop_state(self, response: Message)", "docstring": "Handle a \"robot just rebooted\" safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 344, "original_size_bytes": 346, "start_byte": 215280, "end_byte": 215626}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:685ca133d584", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_redundancy_fault_stop_state", "qualified_name": "_Robot._handle_redundancy_fault_stop_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4719, 4728], "text": "def _handle_redundancy_fault_stop_state(self, response: Message):\n        \"\"\"Handle a \"redundancy fault\" safety stop state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_redundancy_fault_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()", "hash": "685ca133d584", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_redundancy_fault_stop_state(self, response: Message)", "docstring": "Handle a \"redundancy fault\" safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 361, "original_size_bytes": 363, "start_byte": 215632, "end_byte": 215995}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:33db5c6cebb4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_standstill_fault_stop_state", "qualified_name": "_Robot._handle_standstill_fault_stop_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4730, 4739], "text": "def _handle_standstill_fault_stop_state(self, response: Message):\n        \"\"\"Handle a \"standstill fault\" safety stop state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_standstill_fault_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()", "hash": "33db5c6cebb4", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_standstill_fault_stop_state(self, response: Message)", "docstring": "Handle a \"standstill fault\" safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 361, "original_size_bytes": 363, "start_byte": 216001, "end_byte": 216364}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:da1e1c9d2fdb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_connection_dropped_stop_state", "qualified_name": "_Robot._handle_connection_dropped_stop_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4741, 4750], "text": "def _handle_connection_dropped_stop_state(self, response: Message):\n        \"\"\"Handle a \"connection dropped\" safety stop state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_connection_dropped_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()", "hash": "da1e1c9d2fdb", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_connection_dropped_stop_state(self, response: Message)", "docstring": "Handle a \"connection dropped\" safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 367, "original_size_bytes": 369, "start_byte": 216370, "end_byte": 216739}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:19662eafd4ec", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_minor_error_stop_state", "qualified_name": "_Robot._handle_minor_error_stop_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4752, 4761], "text": "def _handle_minor_error_stop_state(self, response: Message):\n        \"\"\"Handle a \"minor error\" safety stop state change.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        self._robot_safety_status.set_minor_error_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()", "hash": "19662eafd4ec", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_minor_error_stop_state(self, response: Message)", "docstring": "Handle a \"minor error\" safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 346, "original_size_bytes": 348, "start_byte": 216745, "end_byte": 217093}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a5a8babf59d6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_get_time_scaling_response", "qualified_name": "_Robot._handle_get_time_scaling_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4763, 4771], "text": "def _handle_get_time_scaling_response(self, response: Message):\n        \"\"\"Handle a time scaling changes.\n        Parameters\n        ----------\n        response : Message object\n                    \"\"\"\n        assert response.id == mx_st.MX_ST_TIME_SCALING\n        self._robot_events.on_time_scaling_changed.set()", "hash": "a5a8babf59d6", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_get_time_scaling_response(self, response: Message)", "docstring": "Handle a time scaling changes.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 313, "original_size_bytes": 314, "start_byte": 217099, "end_byte": 217413}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ff312fd4972a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_effective_time_scaling_data", "qualified_name": "_Robot._handle_effective_time_scaling_data", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4773, 4781], "text": "def _handle_effective_time_scaling_data(self, response: Message):\n        \"\"\"Handle an effective time scaling rt data.\n        Parameters\n        ----------\n        response : Message object\n                    \"\"\"\n        assert response.id == mx_st.MX_ST_RT_EFFECTIVE_TIME_SCALING\n        self._robot_rt_data.rt_effective_time_scaling.update_from_csv(response.data)", "hash": "ff312fd4972a", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_effective_time_scaling_data(self, response: Message)", "docstring": "Handle an effective time scaling rt data.\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 367, "original_size_bytes": 368, "start_byte": 217419, "end_byte": 217787}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:411e9a40c196", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_rt_vm", "qualified_name": "_Robot._handle_rt_vm", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4783, 4790], "text": "def _handle_rt_vm(self, response: Message):\n        \"\"\"Handle an real-time motor voltage data\n        Parameters\n        ----------\n        response : Message object\n                    \"\"\"\n        assert response.id == mx_st.MX_ST_RT_VM\n        self._robot_rt_data.rt_vm.update_from_csv(response.data)", "hash": "411e9a40c196", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_rt_vm(self, response: Message)", "docstring": "Handle an real-time motor voltage data\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 302, "original_size_bytes": 302, "start_byte": 217793, "end_byte": 218095}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:381e793ee8d6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_rt_current", "qualified_name": "_Robot._handle_rt_current", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4792, 4799], "text": "def _handle_rt_current(self, response: Message):\n        \"\"\"Handle an real-time motor current data\n        Parameters\n        ----------\n        response : Message object\n                    \"\"\"\n        assert response.id == mx_st.MX_ST_RT_CURRENT\n        self._robot_rt_data.rt_current.update_from_csv(response.data)", "hash": "381e793ee8d6", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_rt_current(self, response: Message)", "docstring": "Handle an real-time motor current data\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 317, "original_size_bytes": 317, "start_byte": 218101, "end_byte": 218418}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d4c0fbccc91c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_ext_tool_fw_version", "qualified_name": "_Robot._handle_ext_tool_fw_version", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4801, 4803], "text": "def _handle_ext_tool_fw_version(self, response: Message):\n        \"\"\"Parse external tool firmware version\"\"\"\n        self._robot_info.ext_tool_version.update_version(response.data)", "hash": "d4c0fbccc91c", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_ext_tool_fw_version(self, response: Message)", "docstring": "Parse external tool firmware version", "chunk_size_bytes": 180, "original_size_bytes": 180, "start_byte": 218424, "end_byte": 218604}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c62d246e5fe4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_external_tool_status_response", "qualified_name": "_Robot._handle_external_tool_status_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4805, 4851], "text": "def _handle_external_tool_status_response(self, response: Message):\n        \"\"\"Parse external tool status response and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n            External tool status response to parse and handle.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_EXTTOOL_STATUS\n        if response.json_data:\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n            self._robot_rt_data.rt_external_tool_status.timestamp = int(\n                response.json_data.get(MX_JSON_KEY_TIMESTAMP_US, 0))\n            status_flags = self._robot_rt_data.rt_external_tool_status.data\n            status_flags[0] = int(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_SIM_TYPE, 0))\n            status_flags[1] = int(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_PHYSICAL_TYPE, 0))\n            status_flags[2] = int(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_HOMED, 0))\n            status_flags[3] = int(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_ERROR, 0))\n            status_flags[4] = int(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_OVERHEAT, 0))\n            self._external_tool_status.comm_err_warning = bool(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_COMM_ERR,\n                                                                             False))\n        else:\n            self._robot_rt_data.rt_external_tool_status.update_from_csv(response.data)\n            status_flags = self._robot_rt_data.rt_external_tool_status.data\n        try:\n            self._external_tool_status.sim_tool_type = MxExtToolType(status_flags[0])\n        except ValueError:\n            self._external_tool_status.sim_tool_type = status_flags[0]\n        try:\n            self._external_tool_status.physical_tool_type = MxExtToolType(status_flags[1])\n        except ValueError:\n            self._external_tool_status.physical_tool_type = status_flags[1]\n        self._external_tool_status.homing_state = status_flags[2] != 0\n        self._external_tool_status.error_status = status_flags[3] != 0\n        self._external_tool_status.overload_error = status_flags[4] != 0\n        if self._is_in_sync():\n            self._robot_events.on_external_tool_status_updated.set()\n            self._callback_queue.put('on_external_tool_status_updated')", "hash": "c62d246e5fe4", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_external_tool_status_response(self, response: Message)", "docstring": "Parse external tool status response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            External tool status response to parse and handle.", "chunk_size_bytes": 2293, "original_size_bytes": 2447, "start_byte": 218610, "end_byte": 221057}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:68a3f03bb8d6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_get_network_cfg_response", "qualified_name": "_Robot._handle_get_network_cfg_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4853, 4870], "text": "def _handle_get_network_cfg_response(self, response: Message):\n        \"\"\" Handle robot response to GetNetworkCfg command \"\"\"\n        assert response.id == mx_st.MX_ST_GET_NETWORK_CFG\n        if response.json_data:\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n            self._network_config.dhcp = bool(json_data.get(MX_JSON_KEY_NETWORK_CFG_DHCP, False))\n            self._network_config.ip = str(json_data.get(MX_JSON_KEY_NETWORK_CFG_IP, \"\"))\n            self._network_config.mask = str(json_data.get(MX_JSON_KEY_NETWORK_CFG_MASK, \"\"))\n            self._network_config.gateway = str(json_data.get(MX_JSON_KEY_NETWORK_CFG_GATEWAY, \"\"))\n            self._network_config.mac = str(json_data.get(MX_JSON_KEY_NETWORK_CFG_MAC, \"\"))\n            self._network_config.name = str(json_data.get(MX_JSON_KEY_NETWORK_CFG_ROBOT_NAME, \"\"))\n        if self._is_in_sync():\n            self._robot_events.on_network_config_updated.set()", "hash": "68a3f03bb8d6", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_get_network_cfg_response(self, response: Message)", "docstring": "Handle robot response to GetNetworkCfg command", "chunk_size_bytes": 951, "original_size_bytes": 982, "start_byte": 221063, "end_byte": 222045}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f0e0345b9b96", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_gripper_state_response", "qualified_name": "_Robot._handle_gripper_state_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4872, 4899], "text": "def _handle_gripper_state_response(self, response: Message):\n        \"\"\"Parse gripper state response and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n            Gripper state response to parse and handle.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_GRIPPER_STATE\n        self._robot_rt_data.rt_gripper_state.update_from_csv(response.data)\n        status_flags = self._robot_rt_data.rt_gripper_state.data\n        self._gripper_state.holding_part = bool(status_flags[0])\n        self._gripper_state.target_pos_reached = bool(status_flags[1])\n        if len(status_flags) > 2:\n            self._gripper_state.closed = bool(status_flags[2])\n            self._gripper_state.opened = bool(status_flags[3])\n        if self._is_in_sync():\n            self._robot_events.on_gripper_state_updated.set()\n            self._callback_queue.put('on_gripper_state_updated')\n            if self._gripper_state.holding_part:\n                self._robot_events.on_holding_part.set()\n                self._robot_events.on_released_part.clear()\n            else:\n                self._robot_events.on_holding_part.clear()\n                self._robot_events.on_released_part.set()", "hash": "f0e0345b9b96", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_gripper_state_response(self, response: Message)", "docstring": "Parse gripper state response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Gripper state response to parse and handle.", "chunk_size_bytes": 1232, "original_size_bytes": 1236, "start_byte": 222051, "end_byte": 223287}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:48ea3a3c95f4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_gripper_force_response", "qualified_name": "_Robot._handle_gripper_force_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4901, 4902], "text": "def _handle_gripper_force_response(self, response: Message):\n        self._robot_rt_data.rt_gripper_force.update_from_csv(response.data)", "hash": "48ea3a3c95f4", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_gripper_force_response(self, response: Message)", "docstring": null, "chunk_size_bytes": 136, "original_size_bytes": 136, "start_byte": 223293, "end_byte": 223429}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:1f9ecc4ee001", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_gripper_pos_response", "qualified_name": "_Robot._handle_gripper_pos_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4904, 4905], "text": "def _handle_gripper_pos_response(self, response: Message):\n        self._robot_rt_data.rt_gripper_pos.update_from_csv(response.data)", "hash": "1f9ecc4ee001", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_gripper_pos_response(self, response: Message)", "docstring": null, "chunk_size_bytes": 132, "original_size_bytes": 132, "start_byte": 223435, "end_byte": 223567}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:cce9f1101159", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_valve_state_response", "qualified_name": "_Robot._handle_valve_state_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4907, 4923], "text": "def _handle_valve_state_response(self, response: Message):\n        \"\"\"Parse pneumatic valve state response and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n            Pneumatic valve state response to parse and handle.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_VALVE_STATE\n        self._robot_rt_data.rt_valve_state.update_from_csv(response.data)\n        self._valve_state.valve_opened = self._robot_rt_data.rt_valve_state.data\n        if self._is_in_sync():\n            self._robot_events.on_valve_state_updated.set()\n            self._callback_queue.put('on_valve_state_updated')", "hash": "cce9f1101159", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_valve_state_response(self, response: Message)", "docstring": "Parse pneumatic valve state response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Pneumatic valve state response to parse and handle.", "chunk_size_bytes": 657, "original_size_bytes": 661, "start_byte": 223573, "end_byte": 224234}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:dd174d17e469", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_io_status", "qualified_name": "_Robot._handle_io_status", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [4925, 5004], "text": "def _handle_io_status(self, response: Message):\n        \"\"\"Parse IO status and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n            Io state to parse and handle.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_IO_STATUS\n        bank_id = MxIoBankId.MX_IO_BANK_ID_UNDEFINED\n        values = []\n        if response.json_data:\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n            bank_id = MxIoBankId(json_data.get(MX_JSON_KEY_IO_STATUS_BANK_ID, 0))\n        else:\n            values = tools.string_to_numbers(response.data)\n            bank_id = values[1]\n        new_io_status = IoStatus()\n        new_io_status_ts = TimestampedData.zeros(4, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n        if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n            new_io_status = self._io_module_status\n        elif bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n            new_io_status = self._sig_gen_status\n        else:\n            return\n        new_io_status.bank_id = bank_id\n        prev_sim_mode = new_io_status.sim_mode\n        if response.json_data:\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n            new_io_status.present = bool(json_data.get(MX_JSON_KEY_IO_STATUS_PRESENT, False))\n            new_io_status.nb_inputs = int(json_data.get(MX_JSON_KEY_IO_STATUS_NB_INPUTS, 0))\n            new_io_status.nb_outputs = int(json_data.get(MX_JSON_KEY_IO_STATUS_NB_OUTPUTS, 0))\n            new_io_status.sim_mode = bool(json_data.get(MX_JSON_KEY_IO_STATUS_SIM_MODE, False))\n            new_io_status.error = int(json_data.get(MX_JSON_KEY_IO_STATUS_ERROR, 0))\n            new_io_status.timestamp = int(response.json_data.get(MX_JSON_KEY_TIMESTAMP_US, 0))\n            new_io_status_ts.timestamp = new_io_status.timestamp\n            new_io_status_ts.data[0] = new_io_status.bank_id\n            new_io_status_ts.data[1] = 1 if new_io_status.present else 0\n            new_io_status_ts.data[2] = 1 if new_io_status.sim_mode else 0\n            new_io_status_ts.data[3] = new_io_status.error\n        else:\n            new_io_status_ts.update_from_csv(response.data)\n            new_io_status.timestamp = values[0]\n            new_io_status.present = True if values[2] != 0 else False\n            new_io_status.sim_mode = True if values[3] != 0 else False\n            new_io_status.error = values[4]\n        if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n            self._io_module_status = new_io_status\n            self._robot_rt_data.rt_io_module_status = new_io_status_ts\n        elif bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n            self._sig_gen_status = new_io_status\n            self._robot_rt_data.rt_sig_gen_status = new_io_status_ts\n        if not self._first_robot_status_received or prev_sim_mode != new_io_status.sim_mode:\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                if new_io_status.sim_mode:\n                    self._robot_events.on_io_sim_enabled.set()\n                    self._robot_events.on_io_sim_disabled.clear()\n                    self._callback_queue.put('on_io_sim_enabled')\n                else:\n                    self._robot_events.on_io_sim_enabled.clear()\n                    self._robot_events.on_io_sim_disabled.set()\n                    self._callback_queue.put('on_io_sim_disabled')\n        if self._is_in_sync():\n            self._robot_events.on_io_status_updated.set()", "hash": "dd174d17e469", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_io_status(self, response: Message)", "docstring": "Parse IO status and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Io state to parse and handle.", "chunk_size_bytes": 3494, "original_size_bytes": 3898, "start_byte": 224240, "end_byte": 228138}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:54bfdb4d3188", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_output_state", "qualified_name": "_Robot._handle_output_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5006, 5032], "text": "def _handle_output_state(self, response: Message):\n        \"\"\"Parse digital output state and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n            Digital output state to parse and handle.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_OUTPUT_STATE\n        values = tools.string_to_numbers(response.data)\n        changed = False\n        if len(values) > 1:\n            timestamp = values[0]\n            bank_id = values[1]\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                changed = True\n                self._robot_rt_data.rt_io_module_outputs.update_from_data(timestamp, values[2:])\n                self._io_module_status.nb_outputs = len(self._robot_rt_data.rt_io_module_outputs.data)\n            elif bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                changed = True\n                self._robot_rt_data.rt_sig_gen_outputs.update_from_data(timestamp, values[2:])\n                self._sig_gen_status.nb_outputs = len(self._robot_rt_data.rt_sig_gen_outputs.data)\n        if changed and self._is_in_sync():\n            self._robot_events.on_output_state_updated.set()\n            self._callback_queue.put('on_output_state_updated')", "hash": "54bfdb4d3188", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_output_state(self, response: Message)", "docstring": "Parse digital output state and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Digital output state to parse and handle.", "chunk_size_bytes": 1243, "original_size_bytes": 1246, "start_byte": 228144, "end_byte": 229390}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:55dfc55fe12e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_input_state", "qualified_name": "_Robot._handle_input_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5034, 5060], "text": "def _handle_input_state(self, response: Message):\n        \"\"\"Parse digital input state and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n            Digital input state to parse and handle.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_INPUT_STATE\n        values = tools.string_to_numbers(response.data)\n        changed = False\n        if len(values) > 1:\n            timestamp = values[0]\n            bank_id = values[1]\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                changed = True\n                self._robot_rt_data.rt_io_module_inputs.update_from_data(timestamp, values[2:])\n                self._io_module_status.nb_inputs = len(self._robot_rt_data.rt_io_module_inputs.data)\n            elif bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                changed = True\n                self._robot_rt_data.rt_sig_gen_inputs.update_from_data(timestamp, values[2:])\n                self._sig_gen_status.nb_inputs = len(self._robot_rt_data.rt_sig_gen_inputs.data)\n        if changed and self._is_in_sync():\n            self._robot_events.on_input_state_updated.set()\n            self._callback_queue.put('on_input_state_updated')", "hash": "55dfc55fe12e", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_input_state(self, response: Message)", "docstring": "Parse digital input state and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Digital input state to parse and handle.", "chunk_size_bytes": 1231, "original_size_bytes": 1234, "start_byte": 229396, "end_byte": 230630}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ed2c78ec86a7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_vacuum_state", "qualified_name": "_Robot._handle_vacuum_state", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5062, 5092], "text": "def _handle_vacuum_state(self, response: Message):\n        \"\"\"Parse vacuum state and update status fields and events.\n        Parameters\n        ----------\n        response : Message object\n            Vacuum grip state to parse and handle.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_VACUUM_STATE\n        self._robot_rt_data.rt_vacuum_state.update_from_csv(response.data)\n        self._vacuum_state.bank_id = MxIoBankId.MX_IO_BANK_ID_IO_MODULE  #todo, this member doesn't exist\n        self._vacuum_state.timestamp = self._robot_rt_data.rt_vacuum_state.timestamp\n        self._vacuum_state.vacuum_on = bool(self._robot_rt_data.rt_vacuum_state.data[0])\n        self._vacuum_state.purge_on = bool(self._robot_rt_data.rt_vacuum_state.data[1])\n        self._vacuum_state.holding_part = bool(self._robot_rt_data.rt_vacuum_state.data[2])\n        if self._is_in_sync():\n            self._robot_events.on_vacuum_state_updated.set()\n            self._callback_queue.put('on_vacuum_state_updated')\n            if self._vacuum_state.holding_part:\n                self._robot_events.on_holding_part.set()\n                self._robot_events.on_released_part.clear()\n            elif not self._vacuum_state.purge_on:\n                self._robot_events.on_holding_part.clear()\n                self._robot_events.on_released_part.set()\n            if self._vacuum_state.purge_on:\n                self._robot_events.on_vacuum_purge_done.clear()\n            else:\n                self._robot_events.on_vacuum_purge_done.set()", "hash": "ed2c78ec86a7", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_vacuum_state(self, response: Message)", "docstring": "Parse vacuum state and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Vacuum grip state to parse and handle.", "chunk_size_bytes": 1521, "original_size_bytes": 1525, "start_byte": 230636, "end_byte": 232161}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a85f0048a253", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_vacuum_pressure", "qualified_name": "_Robot._handle_vacuum_pressure", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5094, 5104], "text": "def _handle_vacuum_pressure(self, response: Message):\n        \"\"\"Parse vacuum pressure and update fields and events.\n        Parameters\n        ----------\n        response : Message object\n            Vacuum pressure to parse and handle.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_VACUUM_PRESSURE\n        self._robot_rt_data.rt_vacuum_pressure.update_from_csv(response.data)", "hash": "a85f0048a253", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_vacuum_pressure(self, response: Message)", "docstring": "Parse vacuum pressure and update fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Vacuum pressure to parse and handle.", "chunk_size_bytes": 388, "original_size_bytes": 390, "start_byte": 232167, "end_byte": 232557}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d01806f0b9aa", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_ext_tool_sim_status_legacy", "qualified_name": "_Robot._handle_ext_tool_sim_status_legacy", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5106, 5110], "text": "def _handle_ext_tool_sim_status_legacy(self, response: Message):\n        if not str(response.data).isdigit():\n            self._handle_ext_tool_sim_status(MxExtToolType.MX_EXT_TOOL_MEGP25_SHORT)\n        else:\n            self._handle_ext_tool_sim_status(int(response.data))", "hash": "d01806f0b9aa", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_ext_tool_sim_status_legacy(self, response: Message)", "docstring": null, "chunk_size_bytes": 273, "original_size_bytes": 273, "start_byte": 232563, "end_byte": 232836}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:263d9499a47e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_ext_tool_sim_status_off", "qualified_name": "_Robot._handle_ext_tool_sim_status_off", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5112, 5113], "text": "def _handle_ext_tool_sim_status_off(self, response: Message):\n        self._handle_ext_tool_sim_status(MxExtToolType.MX_EXT_TOOL_NONE)", "hash": "263d9499a47e", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_ext_tool_sim_status_off(self, response: Message)", "docstring": null, "chunk_size_bytes": 134, "original_size_bytes": 134, "start_byte": 232842, "end_byte": 232976}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:08dda4004803", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_get_operation_mode", "qualified_name": "_Robot._handle_get_operation_mode", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5115, 5117], "text": "def _handle_get_operation_mode(self, response: Message):\n        robot_operation_mode = self._parse_response_int(response)[0]\n        self._set_robot_operation_mode(robot_operation_mode)", "hash": "08dda4004803", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_get_operation_mode(self, response: Message)", "docstring": null, "chunk_size_bytes": 186, "original_size_bytes": 186, "start_byte": 232982, "end_byte": 233168}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:457c3c9b248e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_torque_limit_status", "qualified_name": "_Robot._handle_torque_limit_status", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5119, 5123], "text": "def _handle_torque_limit_status(self, response: Message):\n        torque_exceeded = self._parse_response_int(response)[0]\n        if torque_exceeded:\n            self.logger.info(\n                f'Torque limit exceeded. Current torque: {args_to_string(self._robot_rt_data.rt_joint_torq.data)}')", "hash": "457c3c9b248e", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_torque_limit_status(self, response: Message)", "docstring": null, "chunk_size_bytes": 295, "original_size_bytes": 295, "start_byte": 233174, "end_byte": 233469}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:84eae8ec5bab", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_target_joint_pos", "qualified_name": "_Robot._handle_target_joint_pos", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5125, 5128], "text": "def _handle_target_joint_pos(self, response: Message):\n        self._robot_rt_data.rt_target_joint_pos.update_from_csv(response.data)\n        if self._is_in_sync():\n            self._robot_events.on_joints_updated.set()", "hash": "84eae8ec5bab", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_target_joint_pos(self, response: Message)", "docstring": null, "chunk_size_bytes": 219, "original_size_bytes": 219, "start_byte": 233475, "end_byte": 233694}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ff6683b6ddc2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_target_cart_pos", "qualified_name": "_Robot._handle_target_cart_pos", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5130, 5133], "text": "def _handle_target_cart_pos(self, response: Message):\n        self._robot_rt_data.rt_target_cart_pos.update_from_csv(response.data, allowed_nb_val=[4, 6])\n        if self._is_in_sync():\n            self._robot_events.on_pose_updated.set()", "hash": "ff6683b6ddc2", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_target_cart_pos(self, response: Message)", "docstring": null, "chunk_size_bytes": 238, "original_size_bytes": 238, "start_byte": 233700, "end_byte": 233938}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b8a3d77c2dd0", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_target_joint_vel", "qualified_name": "_Robot._handle_target_joint_vel", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5135, 5136], "text": "def _handle_target_joint_vel(self, response: Message):\n        self._robot_rt_data.rt_target_joint_vel.update_from_csv(response.data)", "hash": "b8a3d77c2dd0", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_target_joint_vel(self, response: Message)", "docstring": null, "chunk_size_bytes": 133, "original_size_bytes": 133, "start_byte": 233944, "end_byte": 234077}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:10d3a88d2cf8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_target_cart_vel", "qualified_name": "_Robot._handle_target_cart_vel", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5138, 5139], "text": "def _handle_target_cart_vel(self, response: Message):\n        self._robot_rt_data.rt_target_cart_vel.update_from_csv(response.data, allowed_nb_val=[4, 6])", "hash": "10d3a88d2cf8", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_target_cart_vel(self, response: Message)", "docstring": null, "chunk_size_bytes": 154, "original_size_bytes": 154, "start_byte": 234083, "end_byte": 234237}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:583b769a7513", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_target_joint_torq", "qualified_name": "_Robot._handle_target_joint_torq", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5141, 5142], "text": "def _handle_target_joint_torq(self, response: Message):\n        self._robot_rt_data.rt_target_joint_torq.update_from_csv(response.data)", "hash": "583b769a7513", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_target_joint_torq(self, response: Message)", "docstring": null, "chunk_size_bytes": 135, "original_size_bytes": 135, "start_byte": 234243, "end_byte": 234378}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:64b73b7bfae5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_target_conf", "qualified_name": "_Robot._handle_target_conf", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5144, 5145], "text": "def _handle_target_conf(self, response: Message):\n        self._robot_rt_data.rt_target_conf.update_from_csv(response.data)", "hash": "64b73b7bfae5", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_target_conf(self, response: Message)", "docstring": null, "chunk_size_bytes": 123, "original_size_bytes": 123, "start_byte": 234384, "end_byte": 234507}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:33cf9df7f849", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_target_conf_turn", "qualified_name": "_Robot._handle_target_conf_turn", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5147, 5148], "text": "def _handle_target_conf_turn(self, response: Message):\n        self._robot_rt_data.rt_target_conf_turn.update_from_csv(response.data)", "hash": "33cf9df7f849", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_target_conf_turn(self, response: Message)", "docstring": null, "chunk_size_bytes": 133, "original_size_bytes": 133, "start_byte": 234513, "end_byte": 234646}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:d1d12d96789b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_joint_pos", "qualified_name": "_Robot._handle_joint_pos", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5150, 5151], "text": "def _handle_joint_pos(self, response: Message):\n        self._robot_rt_data.rt_joint_pos.update_from_csv(response.data)", "hash": "d1d12d96789b", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_joint_pos(self, response: Message)", "docstring": null, "chunk_size_bytes": 119, "original_size_bytes": 119, "start_byte": 234652, "end_byte": 234771}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:59618dce3092", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_cart_pos", "qualified_name": "_Robot._handle_cart_pos", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5153, 5154], "text": "def _handle_cart_pos(self, response: Message):\n        self._robot_rt_data.rt_cart_pos.update_from_csv(response.data, allowed_nb_val=[4, 6])", "hash": "59618dce3092", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_cart_pos(self, response: Message)", "docstring": null, "chunk_size_bytes": 140, "original_size_bytes": 140, "start_byte": 234777, "end_byte": 234917}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:610c0c5520d3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_joint_vel", "qualified_name": "_Robot._handle_joint_vel", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5156, 5157], "text": "def _handle_joint_vel(self, response: Message):\n        self._robot_rt_data.rt_joint_vel.update_from_csv(response.data)", "hash": "610c0c5520d3", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_joint_vel(self, response: Message)", "docstring": null, "chunk_size_bytes": 119, "original_size_bytes": 119, "start_byte": 234923, "end_byte": 235042}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c9e9cae58536", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_joint_torq", "qualified_name": "_Robot._handle_joint_torq", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5159, 5160], "text": "def _handle_joint_torq(self, response: Message):\n        self._robot_rt_data.rt_joint_torq.update_from_csv(response.data)", "hash": "c9e9cae58536", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_joint_torq(self, response: Message)", "docstring": null, "chunk_size_bytes": 121, "original_size_bytes": 121, "start_byte": 235048, "end_byte": 235169}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b2a8f6b2fea5", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_cart_vel", "qualified_name": "_Robot._handle_cart_vel", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5162, 5163], "text": "def _handle_cart_vel(self, response: Message):\n        self._robot_rt_data.rt_cart_vel.update_from_csv(response.data, allowed_nb_val=[4, 6])", "hash": "b2a8f6b2fea5", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_cart_vel(self, response: Message)", "docstring": null, "chunk_size_bytes": 140, "original_size_bytes": 140, "start_byte": 235175, "end_byte": 235315}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f5762c0d5f68", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_conf", "qualified_name": "_Robot._handle_conf", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5165, 5166], "text": "def _handle_conf(self, response: Message):\n        self._robot_rt_data.rt_conf.update_from_csv(response.data)", "hash": "f5762c0d5f68", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_conf(self, response: Message)", "docstring": null, "chunk_size_bytes": 109, "original_size_bytes": 109, "start_byte": 235321, "end_byte": 235430}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:1e6aa7e09fa8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_conf_turn", "qualified_name": "_Robot._handle_conf_turn", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5168, 5169], "text": "def _handle_conf_turn(self, response: Message):\n        self._robot_rt_data.rt_conf_turn.update_from_csv(response.data)", "hash": "1e6aa7e09fa8", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_conf_turn(self, response: Message)", "docstring": null, "chunk_size_bytes": 119, "original_size_bytes": 119, "start_byte": 235436, "end_byte": 235555}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:1f004ab6aa02", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_accelerometer", "qualified_name": "_Robot._handle_accelerometer", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5171, 5179], "text": "def _handle_accelerometer(self, response: Message):\n        timestamp, index, *measurements = string_to_numbers(response.data)\n        if index not in self._robot_rt_data.rt_accelerometer:\n            self._robot_rt_data.rt_accelerometer[index] = TimestampedData(\n                timestamp, measurements, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)\n            self._robot_rt_data.rt_accelerometer[index].enabled = True\n        if timestamp > self._robot_rt_data.rt_accelerometer[index].timestamp:\n            self._robot_rt_data.rt_accelerometer[index].timestamp = timestamp\n            self._robot_rt_data.rt_accelerometer[index].data = measurements", "hash": "1f004ab6aa02", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_accelerometer(self, response: Message)", "docstring": null, "chunk_size_bytes": 666, "original_size_bytes": 666, "start_byte": 235561, "end_byte": 236227}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a8e4ff1e1ca0", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_abs_joint_pos", "qualified_name": "_Robot._handle_abs_joint_pos", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5181, 5182], "text": "def _handle_abs_joint_pos(self, response: Message):\n        self._robot_rt_data.rt_abs_joint_pos.update_from_csv(response.data)", "hash": "a8e4ff1e1ca0", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_abs_joint_pos(self, response: Message)", "docstring": null, "chunk_size_bytes": 127, "original_size_bytes": 127, "start_byte": 236233, "end_byte": 236360}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:390026cb110f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_wrf", "qualified_name": "_Robot._handle_wrf", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5184, 5185], "text": "def _handle_wrf(self, response: Message):\n        self._robot_rt_data.rt_wrf.update_from_csv(response.data, allowed_nb_val=[4, 6])", "hash": "390026cb110f", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_wrf(self, response: Message)", "docstring": null, "chunk_size_bytes": 130, "original_size_bytes": 130, "start_byte": 236366, "end_byte": 236496}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c196e868b64c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_trf", "qualified_name": "_Robot._handle_trf", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5187, 5188], "text": "def _handle_trf(self, response: Message):\n        self._robot_rt_data.rt_trf.update_from_csv(response.data, allowed_nb_val=[4, 6])", "hash": "c196e868b64c", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_trf(self, response: Message)", "docstring": null, "chunk_size_bytes": 130, "original_size_bytes": 130, "start_byte": 236502, "end_byte": 236632}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:48a7613e1917", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_rt_checkpoint", "qualified_name": "_Robot._handle_rt_checkpoint", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5190, 5191], "text": "def _handle_rt_checkpoint(self, response: Message):\n        self._robot_rt_data.rt_checkpoint.update_from_csv(response.data)", "hash": "48a7613e1917", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_rt_checkpoint(self, response: Message)", "docstring": null, "chunk_size_bytes": 124, "original_size_bytes": 124, "start_byte": 236638, "end_byte": 236762}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b4cc4d9dab72", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_impossible_reset_err", "qualified_name": "_Robot._handle_impossible_reset_err", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5193, 5194], "text": "def _handle_impossible_reset_err(self, response: Message):\n        self.logger.error(response.data)", "hash": "b4cc4d9dab72", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_impossible_reset_err(self, response: Message)", "docstring": null, "chunk_size_bytes": 99, "original_size_bytes": 99, "start_byte": 236768, "end_byte": 236867}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:33a3cb860b85", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_activation_err", "qualified_name": "_Robot._handle_activation_err", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5196, 5198], "text": "def _handle_activation_err(self, response: Message):\n        self._robot_events.on_activated.abort('Activation error')\n        self._robot_events.on_homed.abort('Activation error')", "hash": "33a3cb860b85", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_activation_err(self, response: Message)", "docstring": null, "chunk_size_bytes": 180, "original_size_bytes": 180, "start_byte": 236873, "end_byte": 237053}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b968a2c81dd4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_homing_err", "qualified_name": "_Robot._handle_homing_err", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5200, 5201], "text": "def _handle_homing_err(self, response: Message):\n        self._robot_events.on_homed.abort('Homing error')", "hash": "b968a2c81dd4", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_homing_err(self, response: Message)", "docstring": null, "chunk_size_bytes": 106, "original_size_bytes": 106, "start_byte": 237059, "end_byte": 237165}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f68e6599422e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_pause_motion", "qualified_name": "_Robot._handle_pause_motion", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5204, 5208], "text": "def _handle_pause_motion(self, response: Message):\n        if self._robot_info.version.is_at_least(10, 0):\n            pass  # In this version, we rely on robot status to determine paused state\n        else:\n            self._set_paused(True)", "hash": "f68e6599422e", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_pause_motion(self, response: Message)", "docstring": null, "chunk_size_bytes": 242, "original_size_bytes": 242, "start_byte": 237214, "end_byte": 237456}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:7d78582051dc", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_resume_motion", "qualified_name": "_Robot._handle_resume_motion", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5210, 5214], "text": "def _handle_resume_motion(self, response: Message):\n        if self._robot_info.version.is_at_least(10, 0):\n            pass  # In this version, we rely on robot status to determine paused state\n        else:\n            self._set_paused(False)", "hash": "7d78582051dc", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_resume_motion(self, response: Message)", "docstring": null, "chunk_size_bytes": 244, "original_size_bytes": 244, "start_byte": 237462, "end_byte": 237706}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:9cf4b1b6bdee", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_clear_motion", "qualified_name": "_Robot._handle_clear_motion", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5216, 5227], "text": "def _handle_clear_motion(self, response: Message):\n        if self._clear_motion_requests <= 1:\n            self._clear_motion_requests = 0\n            self._callback_queue.put('on_motion_cleared')\n            if self._robot_info.version.is_at_least(10, 0):\n                pass  # In this version, we rely on robot status to determine paused state\n            else:\n                self._set_paused(True)\n        else:\n            self._clear_motion_requests -= 1\n        self._check_motion_clear_done()", "hash": "9cf4b1b6bdee", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_clear_motion(self, response: Message)", "docstring": null, "chunk_size_bytes": 504, "original_size_bytes": 505, "start_byte": 237712, "end_byte": 238217}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:5414ab77583a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_eob", "qualified_name": "_Robot._handle_eob", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5229, 5233], "text": "def _handle_eob(self, response: Message):\n        if self._robot_info.version.is_at_least(10, 0):\n            pass  # In this version, we rely on robot status to determine paused state\n        else:\n            self._set_eob(True)", "hash": "5414ab77583a", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_eob(self, response: Message)", "docstring": null, "chunk_size_bytes": 230, "original_size_bytes": 230, "start_byte": 238223, "end_byte": 238453}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:f5c25cd04b5c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_offline_start", "qualified_name": "_Robot._handle_offline_start", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5235, 5237], "text": "def _handle_offline_start(self, response: Message):\n        self._robot_events.on_offline_program_started.set()\n        self._callback_queue.put('on_offline_program_state')", "hash": "f5c25cd04b5c", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_offline_start(self, response: Message)", "docstring": null, "chunk_size_bytes": 172, "original_size_bytes": 172, "start_byte": 238459, "end_byte": 238631}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:b1c2eb51c95e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_offline_program_error", "qualified_name": "_Robot._handle_offline_program_error", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5239, 5240], "text": "def _handle_offline_program_error(self, response: Message):\n        self._robot_events.on_offline_program_started.abort(f\"Failed to start program: {response.data}\")", "hash": "b1c2eb51c95e", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_offline_program_error(self, response: Message)", "docstring": null, "chunk_size_bytes": 164, "original_size_bytes": 164, "start_byte": 238637, "end_byte": 238801}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:665dbee1456d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_file_op_done", "qualified_name": "_Robot._handle_file_op_done", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5242, 5243], "text": "def _handle_file_op_done(self, response: Message):\n        self._robot_events.on_file_op_done.set(response)", "hash": "665dbee1456d", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_file_op_done(self, response: Message)", "docstring": null, "chunk_size_bytes": 107, "original_size_bytes": 107, "start_byte": 238807, "end_byte": 238914}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:44f90df4e390", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_load_file_err", "qualified_name": "_Robot._handle_load_file_err", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5245, 5246], "text": "def _handle_load_file_err(self, response: Message):\n        self._robot_events.on_file_op_done.abort(f\"Failed to load file: {response.data}\")", "hash": "44f90df4e390", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_load_file_err(self, response: Message)", "docstring": null, "chunk_size_bytes": 141, "original_size_bytes": 141, "start_byte": 238920, "end_byte": 239061}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:e3be503792c4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_save_file_err", "qualified_name": "_Robot._handle_save_file_err", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5248, 5249], "text": "def _handle_save_file_err(self, response: Message):\n        self._robot_events.on_file_op_done.abort(f\"Failed to save file: {response.data}\")", "hash": "e3be503792c4", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_save_file_err(self, response: Message)", "docstring": null, "chunk_size_bytes": 141, "original_size_bytes": 141, "start_byte": 239067, "end_byte": 239208}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:e737a697c6bb", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_delete_file_err", "qualified_name": "_Robot._handle_delete_file_err", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5251, 5252], "text": "def _handle_delete_file_err(self, response: Message):\n        self._robot_events.on_file_op_done.abort(f\"Failed to delete file: {response.data}\")", "hash": "e737a697c6bb", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_delete_file_err(self, response: Message)", "docstring": null, "chunk_size_bytes": 145, "original_size_bytes": 145, "start_byte": 239214, "end_byte": 239359}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a21abc0d5700", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_checkpoint", "qualified_name": "_Robot._handle_checkpoint", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5254, 5306], "text": "def _handle_checkpoint(self, response: Message, discarded: bool):\n        \"\"\"Handle the checkpoint reached message from the robot, set the appropriate events, etc.\n        Parameters\n        ----------\n        response : Message object\n            Response message which includes the received checkpoint id.\n        discarded : bool\n            Tells if the checkpoint has been discarded or reached.\n        \"\"\"\n        assert (response.id == mx_st.MX_ST_CHECKPOINT_REACHED or response.id == mx_st.MX_ST_CHECKPOINT_DISCARDED)\n        checkpoint_id = int(response.data)\n        self.logger.debug(f'Checkpoint {checkpoint_id} {\"discarded\"if discarded else \"reached\"}')\n        abort_msg = 'Checkpoint discarded by the robot'\n        if checkpoint_id in self._user_checkpoints and self._user_checkpoints[checkpoint_id]:\n            if discarded:\n                self._user_checkpoints[checkpoint_id].pop(0).abort(abort_msg)\n            else:\n                self._user_checkpoints[checkpoint_id].pop(0).set()\n            if not self._user_checkpoints[checkpoint_id]:\n                self._user_checkpoints.pop(checkpoint_id)\n            if '*' in self._internal_checkpoints and self._internal_checkpoints['*']:\n                for event in self._internal_checkpoints.pop('*'):\n                    if discarded:\n                        event.abort(abort_msg)\n                    else:\n                        event.set()\n            if discarded:\n                self._callback_queue.put('on_checkpoint_discarded', checkpoint_id)\n            else:\n                self._callback_queue.put('on_checkpoint_reached', checkpoint_id)\n        elif checkpoint_id in self._internal_checkpoints and self._internal_checkpoints[checkpoint_id]:\n            if discarded:\n                self._internal_checkpoints[checkpoint_id].pop(0).abort(abort_msg)\n            else:\n                self._internal_checkpoints[checkpoint_id].pop(0).set()\n            if not self._internal_checkpoints[checkpoint_id]:\n                self._internal_checkpoints.pop(checkpoint_id)\n        elif not self._sidecar_mode:\n            self.logger.warning(\n                f'Received un-tracked checkpoint {checkpoint_id}. Please use ExpectExternalCheckpoint() to track.')", "hash": "a21abc0d5700", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_checkpoint(self, response: Message, discarded: bool)", "docstring": "Handle the checkpoint reached message from the robot, set the appropriate events, etc.\n\n        Parameters\n        ----------\n        response : Message object\n            Response message which includes the received checkpoint id.\n        discarded : bool\n            Tells if the checkpoint has been discarded or reached.", "chunk_size_bytes": 2235, "original_size_bytes": 2706, "start_byte": 239365, "end_byte": 242071}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ad4db9c83231", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_get_realtime_monitoring_response", "qualified_name": "_Robot._handle_get_realtime_monitoring_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5308, 5421], "text": "def _handle_get_realtime_monitoring_response(self, response: Message):\n        \"\"\"Parse robot response to \"get\" or \"set\" real-time monitoring.\n           This function identifies which real-time events are expected, and which are not enabled.\n        Parameters\n        ----------\n        response : Message object\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_REAL_TIME_MONITORING\n        self._robot_rt_data._reset_enabled()\n        self._robot_rt_data.rt_target_joint_pos.enabled = True\n        self._robot_rt_data.rt_target_cart_pos.enabled = True\n        if self._robot_info.version.is_at_least(9, 0):\n            self._robot_rt_data.rt_target_conf.enabled = True\n            self._robot_rt_data.rt_target_conf_turn.enabled = True\n            self._robot_rt_data.rt_wrf.enabled = True\n            self._robot_rt_data.rt_trf.enabled = True\n        if self._robot_info.version.is_at_least(9, 2):\n            self._robot_rt_data.rt_external_tool_status.enabled = True\n            self._robot_rt_data.rt_valve_state.enabled = True\n            self._robot_rt_data.rt_gripper_state.enabled = True\n        if self._robot_info.version.is_at_least(9, 4):\n            self._robot_rt_data.rt_io_module_status.enabled = True\n            self._robot_rt_data.rt_io_module_outputs.enabled = True\n            self._robot_rt_data.rt_io_module_inputs.enabled = True\n            self._robot_rt_data.rt_vacuum_state.enabled = True\n            self._robot_rt_data.rt_sig_gen_status.enabled = True\n            self._robot_rt_data.rt_sig_gen_outputs.enabled = True\n            self._robot_rt_data.rt_sig_gen_inputs.enabled = True\n        if self._robot_info.version.is_at_least(10, 1, 2):\n            self._robot_rt_data.rt_checkpoint.enabled = True\n        enabled_event_ids = self._parse_response_int(response)\n        for event_id in enabled_event_ids:\n            if event_id == mx_st.MX_ST_RT_TARGET_JOINT_POS:\n                self._robot_rt_data.rt_target_joint_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_CART_POS:\n                self._robot_rt_data.rt_target_cart_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_JOINT_VEL:\n                self._robot_rt_data.rt_target_joint_vel.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_CART_VEL:\n                self._robot_rt_data.rt_target_cart_vel.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_JOINT_TORQ:\n                self._robot_rt_data.rt_target_joint_torq.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_CONF:\n                self._robot_rt_data.rt_target_conf.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_CONF_TURN:\n                self._robot_rt_data.rt_target_conf_turn.enabled = True\n            if event_id == mx_st.MX_ST_RT_JOINT_POS:\n                self._robot_rt_data.rt_joint_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_CART_POS:\n                self._robot_rt_data.rt_cart_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_JOINT_VEL:\n                self._robot_rt_data.rt_joint_vel.enabled = True\n            if event_id == mx_st.MX_ST_RT_JOINT_TORQ:\n                self._robot_rt_data.rt_joint_torq.enabled = True\n            if event_id == mx_st.MX_ST_RT_CART_VEL:\n                self._robot_rt_data.rt_cart_vel.enabled = True\n            if event_id == mx_st.MX_ST_RT_CONF:\n                self._robot_rt_data.rt_conf.enabled = True\n            if event_id == mx_st.MX_ST_RT_CONF_TURN:\n                self._robot_rt_data.rt_conf_turn.enabled = True\n            if event_id == mx_st.MX_ST_RT_EFFECTIVE_TIME_SCALING:\n                self._robot_rt_data.rt_effective_time_scaling.enable = True\n            if event_id == mx_st.MX_ST_RT_VM:\n                self._robot_rt_data.rt_vm.enable = True\n            if event_id == mx_st.MX_ST_RT_CURRENT:\n                self._robot_rt_data.rt_current.enable = True\n            if event_id == mx_st.MX_ST_RT_WRF:\n                self._robot_rt_data.rt_wrf.enabled = True\n            if event_id == mx_st.MX_ST_RT_TRF:\n                self._robot_rt_data.rt_trf.enabled = True\n            if event_id == mx_st.MX_ST_RT_CHECKPOINT:\n                self._robot_rt_data.rt_checkpoint.enabled = True\n            if event_id == mx_st.MX_ST_RT_ACCELEROMETER:\n                for accelerometer in self._robot_rt_data.rt_accelerometer.values():\n                    accelerometer.enabled = True\n            if event_id == mx_st.MX_ST_RT_ABS_JOINT_POS:\n                self._robot_rt_data.rt_abs_joint_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_EXTTOOL_STATUS:\n                self._robot_rt_data.rt_external_tool_status.enabled = True\n            if event_id == mx_st.MX_ST_RT_VALVE_STATE:\n                self._robot_rt_data.rt_valve_state.enabled = True\n            if event_id == mx_st.MX_ST_RT_GRIPPER_FORCE:\n                self._robot_rt_data.rt_gripper_force.enabled = True\n            if event_id == mx_st.MX_ST_RT_GRIPPER_POS:\n                self._robot_rt_data.rt_gripper_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_IO_STATUS:\n                self._robot_rt_data.rt_io_module_status.enabled = True\n                self._robot_rt_data.rt_sig_gen_status.enabled = True\n            if event_id == mx_st.MX_ST_RT_OUTPUT_STATE:\n                self._robot_rt_data.rt_io_module_outputs.enabled = True\n                self._robot_rt_data.rt_sig_gen_outputs.enabled = True\n            if event_id == mx_st.MX_ST_RT_INPUT_STATE:\n                self._robot_rt_data.rt_io_module_inputs.enabled = True\n                self._robot_rt_data.rt_sig_gen_inputs.enabled = True\n            if event_id == mx_st.MX_ST_RT_VACUUM_STATE:\n                self._robot_rt_data.rt_vacuum_state.enabled = True\n            if event_id == mx_st.MX_ST_RT_VACUUM_PRESSURE:\n                self._robot_rt_data.rt_vacuum_pressure.enabled = True\n        self._robot_rt_data.clear_if_disabled()", "hash": "ad4db9c83231", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_get_realtime_monitoring_response(self, response: Message)", "docstring": "Parse robot response to \"get\" or \"set\" real-time monitoring.\n           This function identifies which real-time events are expected, and which are not enabled.\n\n\n        Parameters\n        ----------\n        response : Message object", "chunk_size_bytes": 5947, "original_size_bytes": 6501, "start_byte": 242077, "end_byte": 248578}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:595f3101dc86", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_print_fw_update_status", "qualified_name": "_Robot._print_fw_update_status", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5423, 5443], "text": "def _print_fw_update_status(self, reboot_pct: float = 0):\n        \"\"\" Print a trace that summarize current firmware update status (progression) \"\"\"\n        if (not self._fw_update_status.progress and not self._fw_update_status.complete\n                and not self._fw_update_status.error):\n            return\n        reboot_ratio = self._get_reboot_duration() / self._get_fw_update_duration()\n        total_pct = ((1 - reboot_ratio) * self._fw_update_status.progress) + (reboot_ratio * reboot_pct)\n        if self._fw_update_status.error:\n            self.logger.debug(f'Firmware update failed: {self._fw_update_status.error_msg}')\n        elif self._fw_update_status.complete:\n            self.logger.debug(f'Firmware update complete')\n        else:\n            self.logger.info(f'Firmware update progress: {int(total_pct)}% ({self._fw_update_status.step})')\n        self._fw_update_status._last_print_timestamp = time.monotonic()", "hash": "595f3101dc86", "chunk_type": "method", "node_type": "function_definition", "signature": "_print_fw_update_status(self, reboot_pct: float = 0)", "docstring": "Print a trace that summarize current firmware update status (progression)", "chunk_size_bytes": 932, "original_size_bytes": 1253, "start_byte": 248584, "end_byte": 249837}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:fa41d6d97503", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_fw_update_progress", "qualified_name": "_Robot._handle_fw_update_progress", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5445, 5490], "text": "def _handle_fw_update_progress(self, event: Message):\n        \"\"\"Parse robot firmware update progress message\n        Parameters\n        ----------\n        event : Message object\n            The event message to parse.\n        \"\"\"\n        assert event.id == mx_st.MX_ST_FW_UPDATE_PROGRESS\n        if event.json_data:\n            json_data: dict = event.json_data.get(MX_JSON_KEY_DATA, {})\n            new_updating = bool(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_UPDATING, False))\n            new_version = str(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_VERSION, \"\"))\n            new_error = bool(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_ERROR, False))\n            new_error_msg = str(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_ERROR_MSG, \"\"))\n            new_progress_pct = float(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_PCT, 0))\n            new_step = str(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_STEP, \"\"))\n            reboot_done = bool(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_REBOOT_DONE, False))\n            print_now = False\n            last_print_timestamp = self._fw_update_status._last_print_timestamp\n            if self._fw_update_reboot_timestamp != 0:\n                print_now = False  # In this case progress is printed by _check_update_progress\n            if new_step != self._fw_update_status.step:\n                print_now = True\n            elif time.monotonic() - last_print_timestamp > 5.0:\n                print_now = True\n            self._fw_update_status.in_progress = new_updating\n            self._fw_update_status.complete = self._fw_update_started and not new_updating\n            self._fw_update_status.version = new_version\n            self._fw_update_status.error = new_error\n            self._fw_update_status.error_msg = new_error_msg\n            self._fw_update_status.progress = new_progress_pct\n            self._fw_update_status.step = new_step\n            if reboot_done:\n                self._fw_update_reboot_done = True\n            if print_now:\n                reboot_pct = 100 if reboot_done else 0\n                self._print_fw_update_status(reboot_pct)", "hash": "fa41d6d97503", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_fw_update_progress(self, event: Message)", "docstring": "Parse robot firmware update progress message\n\n        Parameters\n        ----------\n        event : Message object\n            The event message to parse.", "chunk_size_bytes": 2126, "original_size_bytes": 2269, "start_byte": 249843, "end_byte": 252112}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:510878e3e804", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_sync_response", "qualified_name": "_Robot._handle_sync_response", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5492, 5509], "text": "def _handle_sync_response(self, response: Message):\n        \"\"\"Parse robot response to \"SyncCmdQueue\" request\n           This class uses the \"SyncCmdQueue\" request/response to ensure synchronous \"Get\" operations have received the\n           expected response from the robot (and not a response/event sent by the robot prior to our \"Get\" request).\n        Parameters\n        ----------\n        response : Message object\n            Sync response to parse and handle.\n        \"\"\"\n        assert response.id == mx_st.MX_ST_SYNC_CMD_QUEUE\n        if self._tx_sync_pending:\n            self._rx_sync = string_to_numbers(response.data)[0]\n            if self._is_in_sync():\n                self._tx_sync_pending = 0\n                self._is_sync.set()", "hash": "510878e3e804", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_sync_response(self, response: Message)", "docstring": "Parse robot response to \"SyncCmdQueue\" request\n           This class uses the \"SyncCmdQueue\" request/response to ensure synchronous \"Get\" operations have received the\n           expected response from the robot (and not a response/event sent by the robot prior to our \"Get\" request).\n\n        Parameters\n        ----------\n        response : Message object\n            Sync response to parse and handle.", "chunk_size_bytes": 745, "original_size_bytes": 748, "start_byte": 252118, "end_byte": 252866}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:647de02bd56f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_is_in_sync", "qualified_name": "_Robot._is_in_sync", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5511, 5520], "text": "def _is_in_sync(self) -> bool:\n        \"\"\"Tells if we're in sync with the latest \"get\" operation (i.e. we've received the response to the most recent\n           \"SyncCmdQueue\" request to the robot, meaning that the \"get\" response we just got is up-to-date)\n        Returns\n        -------\n        bool\n            True if \"in sync\" (\"get\" response we just received matches the \"get\" request we've just made)\n        \"\"\"\n        return self._rx_sync == self._tx_sync", "hash": "647de02bd56f", "chunk_type": "method", "node_type": "function_definition", "signature": "_is_in_sync(self)", "docstring": "Tells if we're in sync with the latest \"get\" operation (i.e. we've received the response to the most recent\n           \"SyncCmdQueue\" request to the robot, meaning that the \"get\" response we just got is up-to-date)\n\n        Returns\n        -------\n        bool\n            True if \"in sync\" (\"get\" response we just received matches the \"get\" request we've just made)", "chunk_size_bytes": 465, "original_size_bytes": 466, "start_byte": 252872, "end_byte": 253338}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:babf4366b49d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sidecar_get_registered_functions", "qualified_name": "_Robot._sidecar_get_registered_functions", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5522, 5537], "text": "def _sidecar_get_registered_functions(self, module_name: Optional[str] = None) -> list[Tuple[str, str]]:\n        \"\"\" Get a list of registered functions for the specified module, or all modules\n        Args:\n            module (Optional[str], optional):   Module to get registered functions too.\n                                                If none, will return registered functions in all modules.\n                                                Defaults to None.\n        Returns:\n            list[Tuple[str, str]]: List of tuple [module_name, function_name]\n        \"\"\"\n        registered_functions: list[Tuple[str, str]] = []\n        for function_name, function in self._sidecar_registered_functions.items():\n            if module_name is None or module_name == function.module_name:\n                registered_functions.append((function.module_name, function_name))\n        return registered_functions", "hash": "babf4366b49d", "chunk_type": "method", "node_type": "function_definition", "signature": "_sidecar_get_registered_functions(self, module_name: Optional[str] = None)", "docstring": "Get a list of registered functions for the specified module, or all modules\n\n        Args:\n            module (Optional[str], optional):   Module to get registered functions too.\n                                                If none, will return registered functions in all modules.\n                                                Defaults to None.\n\n        Returns:\n            list[Tuple[str, str]]: List of tuple [module_name, function_name]", "chunk_size_bytes": 907, "original_size_bytes": 909, "start_byte": 253344, "end_byte": 254253}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:e2047b3fca94", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sidecar_get_registered_function", "qualified_name": "_Robot._sidecar_get_registered_function", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5539, 5550], "text": "def _sidecar_get_registered_function(self, function_name: str) -> Optional[rsc.RegisteredFunction]:\n        \"\"\"Get the definition of a registered sidecar function\n        Args:\n            function_name (str): Name of the function to get\n        Returns:\n            Optional[rsc.RegisteredFunction]: Registered function (or None if not found)\n        \"\"\"\n        if function_name in self._sidecar_registered_functions:\n            return self._sidecar_registered_functions[function_name]\n        return None", "hash": "e2047b3fca94", "chunk_type": "method", "node_type": "function_definition", "signature": "_sidecar_get_registered_function(self, function_name: str)", "docstring": "Get the definition of a registered sidecar function\n\n        Args:\n            function_name (str): Name of the function to get\n\n        Returns:\n            Optional[rsc.RegisteredFunction]: Registered function (or None if not found)", "chunk_size_bytes": 508, "original_size_bytes": 510, "start_byte": 254259, "end_byte": 254769}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:786d7196c4d3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sidecar_call_registered_function", "qualified_name": "_Robot._sidecar_call_registered_function", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5552, 5558], "text": "def _sidecar_call_registered_function(self, function_name, *args, **kwargs):\n        \"\"\" Call a sidecar registered function by name \"\"\"\n        if function_name not in self._sidecar_registered_functions:\n            user_msg = f'Failed to call sidecar function {function_name}, it is not registered'\n            self.LogTrace(user_msg, logging.ERROR)\n            raise NotFoundException(user_msg)\n        self._sidecar_registered_functions[function_name].function(*args, **kwargs)", "hash": "786d7196c4d3", "chunk_type": "method", "node_type": "function_definition", "signature": "_sidecar_call_registered_function(self, function_name, *args, **kwargs)", "docstring": "Call a sidecar registered function by name", "chunk_size_bytes": 480, "original_size_bytes": 480, "start_byte": 254775, "end_byte": 255255}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:15ac6219aa7d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sidecar_get_registered_attr", "qualified_name": "_Robot._sidecar_get_registered_attr", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5560, 5562], "text": "def _sidecar_get_registered_attr(self, attr_name: str) -> any:\n        \"\"\" Callback for getting an attribute from local namespace \"\"\"\n        return getattr(_Robot, attr_name, None)", "hash": "15ac6219aa7d", "chunk_type": "method", "node_type": "function_definition", "signature": "_sidecar_get_registered_attr(self, attr_name: str)", "docstring": "Callback for getting an attribute from local namespace", "chunk_size_bytes": 181, "original_size_bytes": 181, "start_byte": 255261, "end_byte": 255442}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:8d02c7b53f60", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sidecar_set_registered_attr", "qualified_name": "_Robot._sidecar_set_registered_attr", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5564, 5566], "text": "def _sidecar_set_registered_attr(self, attr_name: str, attr_val: any):\n        \"\"\" Callback for setting an attribute into local namespace \"\"\"\n        setattr(_Robot, attr_name, attr_val)", "hash": "8d02c7b53f60", "chunk_type": "method", "node_type": "function_definition", "signature": "_sidecar_set_registered_attr(self, attr_name: str, attr_val: any)", "docstring": "Callback for setting an attribute into local namespace", "chunk_size_bytes": 186, "original_size_bytes": 186, "start_byte": 255448, "end_byte": 255634}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:ca78b7868ca9", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sidecar_del_registered_attr", "qualified_name": "_Robot._sidecar_del_registered_attr", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5568, 5570], "text": "def _sidecar_del_registered_attr(self, attr_name: str):\n        \"\"\" Callback for deleting an attribute from local namespace \"\"\"\n        delattr(_Robot, attr_name)", "hash": "ca78b7868ca9", "chunk_type": "method", "node_type": "function_definition", "signature": "_sidecar_del_registered_attr(self, attr_name: str)", "docstring": "Callback for deleting an attribute from local namespace", "chunk_size_bytes": 162, "original_size_bytes": 162, "start_byte": 255640, "end_byte": 255802}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:dca0f377c463", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sidecar_register_function", "qualified_name": "_Robot._sidecar_register_function", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5572, 5645], "text": "def _sidecar_register_function(self,\n                                   function: rsc.RegisteredFunction,\n                                   original_function: Optional[callable] = None):\n        \"\"\" Common code for registering a function in our namespace.\n        This function is called in the following cases:\n        1. We're sidecar\n            1.1 We're registering a new function\n            1.2 We're overriding an existing function from this \"Robot\" class\n        2. We're not a sidecar (we're a normal Python application) and we've received an indication from the robot\n           that a sidecar has registered a custom function that we should make available in our namespace so it can\n           be called.\n        Args:\n            function (rsc.RegisteredFunction): The function to register\n            original_function (Optional[callable]): The original class method we're overriding. We need to store it so\n                                                    we can restore it later when unregistering the overriding one.\n        Raises:\n            PermissionError: Trying to register a function that's already registered\n        \"\"\"\n        if function.name in self._sidecar_registered_functions:\n            raise PermissionError((f'Cannot register function {function.name}, '\n                                   f'it is already registered by module '\n                                   f'{self._sidecar_registered_functions[function.name].module_name}'))\n        if (function.cyclic_id is not None and function.cyclic_id > 0\n                and function.cyclic_id in self._registered_cyclic_id):\n            raise PermissionError((f'Cannot register function {function.name}, '\n                                   f'cyclic ID {function.cyclic_id} is already registered by '\n                                   f'{self._registered_cyclic_id[function.cyclic_id].name}'))\n        if self._sidecar_mode:\n            self._sidecar_register_to_robot(function)\n        def _registered_function_wrapper(*args: Tuple[any], **kwargs):\n            \"\"\" Function wrapper that retrieves the registered function from the dictionary, by name, and call it\n                with the provided arguments \"\"\"\n            self._sidecar_call_registered_function(function.name, *args, **kwargs)\n        def _registered_function_wrapper_self(_, *args: Tuple[any], **kwargs):\n            \"\"\" Same as _registered_function_wrapper, but for cases where it's called from another method of this\n                class and thus receiving 'self' argument (which we discard here)\"\"\"\n            _registered_function_wrapper(*args, **kwargs)\n        if \".\" in function.name:\n            nested_function = _registered_function_wrapper\n        else:\n            nested_function = _registered_function_wrapper_self\n        rsc.register_nested_function(function_full_name=function.name,\n                                     get_parent_attr=self._sidecar_get_registered_attr,\n                                     set_parent_attr=self._sidecar_set_registered_attr,\n                                     function=nested_function)\n        rgf.attach_global_function(_registered_function_wrapper, function.name)\n        self._sidecar_registered_functions[function.name] = function\n        if function.cyclic_id is not None and function.cyclic_id > 0:\n            self._registered_cyclic_id[function.cyclic_id] = function\n        if original_function is not None:\n            self._sidecar_overridden_functions[function.name] = original_function", "hash": "dca0f377c463", "chunk_type": "method", "node_type": "function_definition", "signature": "_sidecar_register_function(self,\n                                   function: rsc.RegisteredFunction,\n                                   original_function: Optional[callable] = None)", "docstring": "Common code for registering a function in our namespace.\n        This function is called in the following cases:\n        1. We're sidecar\n            1.1 We're registering a new function\n            1.2 We're overriding an existing function from this \"Robot\" class\n        2. We're not a sidecar (we're a normal Python application) and we've received an indication from the robot\n           that a sidecar has registered a custom function that we should make available in our namespace so it can\n           be called.\n\n        Args:\n            function (rsc.RegisteredFunction): The function to register\n            original_function (Optional[callable]): The original class method we're overriding. We need to store it so\n                                                    we can restore it later when unregistering the overriding one.\n\n        Raises:\n            PermissionError: Trying to register a function that's already registered", "chunk_size_bytes": 3513, "original_size_bytes": 4716, "start_byte": 255808, "end_byte": 260524}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a21c064be2ff", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sidecar_register_to_robot", "qualified_name": "_Robot._sidecar_register_to_robot", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5647, 5677], "text": "def _sidecar_register_to_robot(self, function: rsc.RegisteredFunction):\n        \"\"\"Synchronously register a sidecar function with the robot (awaiting robot's response before continuing)\n        Args:\n            function (rsc.RegisteredFunction): The function to register\n        Raises:\n            TimeoutException: No robot response received\n            PermissionError: Robot refused the function registration (explanation found in exception message)\n        \"\"\"\n        failed = True\n        try:\n            response = self._send_json_command(\n                '-SidecarRegisterFct',\n                function.to_dict(),\n                expected_responses=[mx_st.MX_ST_REGISTER_FCT_SUCCESS, mx_st.MX_ST_REGISTER_FCT_FAILURE],\n                timeout=2)\n        except TimeoutException as e:\n            failed = True\n            raise TimeoutException(\n                f'Failed to register function {function.name}: Timeout waiting for robot response') from e\n        message = \"(unknown reason)\"\n        if response.json_data:\n            failed = response.id != mx_st.MX_ST_REGISTER_FCT_SUCCESS\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n            message = json_data.get(MX_JSON_KEY_SIDECAR_FCT_RSP_MSG, \"\")\n        if failed:\n            raise PermissionError(f'Failed to register function {function.name}: {message}')", "hash": "a21c064be2ff", "chunk_type": "method", "node_type": "function_definition", "signature": "_sidecar_register_to_robot(self, function: rsc.RegisteredFunction)", "docstring": "Synchronously register a sidecar function with the robot (awaiting robot's response before continuing)\n\n        Args:\n            function (rsc.RegisteredFunction): The function to register\n\n        Raises:\n            TimeoutException: No robot response received\n            PermissionError: Robot refused the function registration (explanation found in exception message)", "chunk_size_bytes": 1360, "original_size_bytes": 1466, "start_byte": 260530, "end_byte": 261996}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c9a8da53978b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sidecar_unregister_function", "qualified_name": "_Robot._sidecar_unregister_function", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5679, 5714], "text": "def _sidecar_unregister_function(self, function_name: str):\n        \"\"\"Unregister a function that was previously registered\n        (unregister from robot class, and from global namespace robot_global_functions.py)\n        Args:\n            function_name (str): The name of the function to unregister\n        \"\"\"\n        if function_name not in self._sidecar_registered_functions:\n            return\n        rsc.unregister_nested_function(function_full_name=function_name,\n                                       get_parent_attr=self._sidecar_get_registered_attr,\n                                       del_parent_attr=self._sidecar_del_registered_attr)\n        rgf.detach_global_function(function_name)\n        cyclic_id = self._sidecar_registered_functions[function_name].cyclic_id\n        del self._sidecar_registered_functions[function_name]\n        if function_name in self._sidecar_overridden_functions:\n            self._sidecar_set_registered_attr(function_name, self._sidecar_overridden_functions[function_name])\n            del self._sidecar_overridden_functions[function_name]\n        if cyclic_id is not None and cyclic_id > 0 and cyclic_id in self._registered_cyclic_id:\n            fct_or_var = self._registered_cyclic_id[cyclic_id]\n            if isinstance(fct_or_var, rsc.RegisteredFunction):\n                del self._registered_cyclic_id[cyclic_id]\n        if self._sidecar_mode and self.IsConnected():\n            self._sidecar_push_unregistered_fct_to_robot(function_name)", "hash": "c9a8da53978b", "chunk_type": "method", "node_type": "function_definition", "signature": "_sidecar_unregister_function(self, function_name: str)", "docstring": "Unregister a function that was previously registered\n        (unregister from robot class, and from global namespace robot_global_functions.py)\n\n        Args:\n            function_name (str): The name of the function to unregister", "chunk_size_bytes": 1492, "original_size_bytes": 1952, "start_byte": 262002, "end_byte": 263954}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:4886b2ede6c7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_sidecar_push_unregistered_fct_to_robot", "qualified_name": "_Robot._sidecar_push_unregistered_fct_to_robot", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5716, 5718], "text": "def _sidecar_push_unregistered_fct_to_robot(self, function_name: str):\n        \"\"\" Tell the robot about a registered function \"\"\"\n        self._send_json_command('-SidecarUnregisterFct', {\"name\": function_name})", "hash": "4886b2ede6c7", "chunk_type": "method", "node_type": "function_definition", "signature": "_sidecar_push_unregistered_fct_to_robot(self, function_name: str)", "docstring": "Tell the robot about a registered function", "chunk_size_bytes": 211, "original_size_bytes": 211, "start_byte": 263960, "end_byte": 264171}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:0817de3e3620", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_register_variable", "qualified_name": "_Robot._register_variable", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5720, 5727], "text": "def _register_variable(self, variable: rsc.RegisteredVariable):\n        \"\"\" Called when the robot reports an existing variable \"\"\"\n        self._registered_vars_by_name[variable.name] = variable\n        if variable.cyclic_id is not None and variable.cyclic_id > 0:\n            self._registered_cyclic_id[variable.cyclic_id] = variable\n        self.vars.register_attribute(variable.name, variable.name)", "hash": "0817de3e3620", "chunk_type": "method", "node_type": "function_definition", "signature": "_register_variable(self, variable: rsc.RegisteredVariable)", "docstring": "Called when the robot reports an existing variable", "chunk_size_bytes": 401, "original_size_bytes": 453, "start_byte": 264177, "end_byte": 264630}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:c666ea2bb533", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_unregister_variable", "qualified_name": "_Robot._unregister_variable", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5729, 5755], "text": "def _unregister_variable(self, name: str) -> any:\n        \"\"\"Delete a variable previously registered with RegisterVariable\n        Args:\n            name (str): Name of the variable to unregister\n        Returns:\n            any: The variable value before it gets deleted\n        \"\"\"\n        old_value = None\n        if name in self._registered_vars_by_name:\n            variable = self._registered_vars_by_name[name]\n            old_value = variable.get_value()\n            self.vars.unregister_attribute(name)\n            del self._registered_vars_by_name[name]\n            if variable.cyclic_id is not None and variable.cyclic_id > 0:\n                var = self.GetVariableByCyclicId(variable.cyclic_id)\n                if var:\n                    del self._registered_cyclic_id[variable.cyclic_id]\n        return old_value", "hash": "c666ea2bb533", "chunk_type": "method", "node_type": "function_definition", "signature": "_unregister_variable(self, name: str)", "docstring": "Delete a variable previously registered with RegisterVariable\n\n        Args:\n            name (str): Name of the variable to unregister\n\n        Returns:\n            any: The variable value before it gets deleted", "chunk_size_bytes": 826, "original_size_bytes": 966, "start_byte": 264636, "end_byte": 265602}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:a787052f8e0d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_get_variable", "qualified_name": "_Robot._get_variable", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5757, 5762], "text": "def _get_variable(self, name: str) -> Optional[any]:\n        \"\"\" Attribute container callback used to get a variable value when someone calls robot.vars.X to access\n            variable X\"\"\"\n        if name not in self._registered_vars_by_name:\n            return None\n        return self._registered_vars_by_name[name]", "hash": "a787052f8e0d", "chunk_type": "method", "node_type": "function_definition", "signature": "_get_variable(self, name: str)", "docstring": "Attribute container callback used to get a variable value when someone calls robot.vars.X to access\n            variable X", "chunk_size_bytes": 319, "original_size_bytes": 319, "start_byte": 265608, "end_byte": 265927}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:3aec9b17e876", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_set_variable", "qualified_name": "_Robot._set_variable", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5764, 5780], "text": "def _set_variable(self, name: str, value: any) -> any:\n        \"\"\" Attribute container callback used to set a variable value when someone calls robot.vars.X=val to modify\n            variable X\"\"\"\n        if isinstance(value, rsc.RegisteredVariable):\n            value = value.get_value()\n        prev_val = copy.deepcopy(value)\n        self.SetVariable(name, value, self.default_timeout)\n        return prev_val", "hash": "3aec9b17e876", "chunk_type": "method", "node_type": "function_definition", "signature": "_set_variable(self, name: str, value: any)", "docstring": "Attribute container callback used to set a variable value when someone calls robot.vars.X=val to modify\n            variable X", "chunk_size_bytes": 412, "original_size_bytes": 813, "start_byte": 265933, "end_byte": 266746}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:4e863c096e06", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_register_robot_sidecar_cmd", "qualified_name": "_Robot._register_robot_sidecar_cmd", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5782, 5813], "text": "def _register_robot_sidecar_cmd(self, function_name: str, cmd_def: dict):\n        \"\"\"Register into the current namespace a function that a remote sidecar just registered on the robot.\n            This way, this function can be called on the robot object in current application,\n            for example robot.some_sidecar_module.some_sidecar_function(some_args)\n        Args:\n            function_name (str): Name of the function to register\n            cmd_def (dict): Description of the function as provided by the robot's command dictionary API\n        \"\"\"\n        exists = hasattr(_Robot, function_name)\n        if exists:\n            self.logger.error(f'Trying to register function {function_name} but it already exists in Robot class')\n            return\n        def _sidecar_cmd_wrapper(*args, **kwargs):\n            json_data: dict = {MX_JSON_KEY_SIDECAR_FCT_EXEC_ARGS: args, MX_JSON_KEY_SIDECAR_FCT_EXEC_KWARGS: kwargs}\n            self._send_json_command(function_name, json_data)\n        function = rsc.RegisteredFunction.from_robot_cmd_def(function=_sidecar_cmd_wrapper,\n                                                             name=function_name,\n                                                             cmd_def=cmd_def)\n        self._sidecar_register_function(function)", "hash": "4e863c096e06", "chunk_type": "method", "node_type": "function_definition", "signature": "_register_robot_sidecar_cmd(self, function_name: str, cmd_def: dict)", "docstring": "Register into the current namespace a function that a remote sidecar just registered on the robot.\n            This way, this function can be called on the robot object in current application,\n            for example robot.some_sidecar_module.some_sidecar_function(some_args)\n\n        Args:\n            function_name (str): Name of the function to register\n            cmd_def (dict): Description of the function as provided by the robot's command dictionary API", "chunk_size_bytes": 1290, "original_size_bytes": 1966, "start_byte": 266752, "end_byte": 268718}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:90fbf8debf2a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_dict_cmd_added", "qualified_name": "_Robot._handle_dict_cmd_added", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5815, 5839], "text": "def _handle_dict_cmd_added(self, message: Message):\n        \"\"\"Handle a message listing one API function available on the robot.\n        Parameters\n        ----------\n        message : Message object that describes the robot registered command\n        \"\"\"\n        if self._sidecar_mode:\n            return\n        if not message.json_data:\n            return\n        json_data: dict = message.json_data.get(MX_JSON_KEY_DATA, {})\n        for function_name, cmd_def in json_data.items():\n            sidecar_id: int = int(cmd_def.get(MX_JSON_KEY_SIDECAR_FCT_SIDECAR_ID, 0))\n            if sidecar_id != 0 and function_name not in self._sidecar_registered_functions:\n                self._register_robot_sidecar_cmd(function_name, cmd_def)", "hash": "90fbf8debf2a", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_dict_cmd_added(self, message: Message)", "docstring": "Handle a message listing one API function available on the robot.\n\n        Parameters\n        ----------\n        message : Message object that describes the robot registered command", "chunk_size_bytes": 736, "original_size_bytes": 938, "start_byte": 268724, "end_byte": 269662}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:85850419161a", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_dict_cmd_removed", "qualified_name": "_Robot._handle_dict_cmd_removed", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5841, 5862], "text": "def _handle_dict_cmd_removed(self, message: Message):\n        \"\"\"Handle a message indicating that the robot no longer has the specified API function.\n        Parameters\n        ----------\n        message : Message object that contains the name of the functions to unregister\n        \"\"\"\n        if self._sidecar_mode:\n            return\n        if not message.json_data:\n            return\n        json_data: dict = message.json_data.get(MX_JSON_KEY_DATA, {})\n        for function_name, _ in json_data.items():\n            self._sidecar_unregister_function(function_name)", "hash": "85850419161a", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_dict_cmd_removed(self, message: Message)", "docstring": "Handle a message indicating that the robot no longer has the specified API function.\n\n        Parameters\n        ----------\n        message : Message object that contains the name of the functions to unregister", "chunk_size_bytes": 571, "original_size_bytes": 809, "start_byte": 269668, "end_byte": 270477}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:cf35f03e27d1", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_sidecar_status", "qualified_name": "_Robot._handle_sidecar_status", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5864, 5889], "text": "def _handle_sidecar_status(self, message: Message):\n        \"\"\"Handle the message that indicates the sidecar scripting engines status.\n        Parameters\n        ----------\n        message : Message object that contains the status of all connected scripting engines\n        \"\"\"\n        if not message.json_data:\n            return\n        json_data: dict[str, dict] = message.json_data.get(MX_JSON_KEY_DATA, {})\n        self._sidecar_status = []\n        for _, json_sidecar in json_data.items():\n            sidecar_status = RobotSidecarStatus()\n            sidecar_status.id = json_sidecar.get(MX_JSON_KEY_SIDECAR_STATUS_ID, None)\n            sidecar_status.embedded = bool(json_sidecar.get(MX_JSON_KEY_SIDECAR_STATUS_EMBEDDED, False))\n            sidecar_status.remote_ip = str(json_sidecar.get(MX_JSON_KEY_SIDECAR_STATUS_REMOTE_IP, \"\"))\n            if (MX_JSON_KEY_SIDECAR_STATUS_FUNCTIONS in json_sidecar\n                    and isinstance(json_sidecar[MX_JSON_KEY_SIDECAR_STATUS_FUNCTIONS], list)):\n                sidecar_status.registered_functions = json_sidecar[MX_JSON_KEY_SIDECAR_STATUS_FUNCTIONS]\n            self._sidecar_status.append(sidecar_status)", "hash": "cf35f03e27d1", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_sidecar_status(self, message: Message)", "docstring": "Handle the message that indicates the sidecar scripting engines status.\n\n        Parameters\n        ----------\n        message : Message object that contains the status of all connected scripting engines", "chunk_size_bytes": 1164, "original_size_bytes": 1255, "start_byte": 270483, "end_byte": 271738}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:cf802a307356", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_variable_added", "qualified_name": "_Robot._handle_variable_added", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5891, 5931], "text": "def _handle_variable_added(self, message: Message):\n        \"\"\"Handle a message indicating that variables were created or modified on the robot (also called as connection)\n        Parameters\n        ----------\n        message : Message object that describes all the variables that were created or modified\n        \"\"\"\n        if not message.json_data:\n            return\n        json_data: dict = message.json_data.get(MX_JSON_KEY_DATA, {})\n        variables: dict[str, dict] = json_data.get(MX_JSON_KEY_VAR_LIST, {})\n        for name, var in variables.items():\n            value = var.get(MX_JSON_KEY_VAR_VAL)\n            cyclic_id = var.get(MX_JSON_KEY_VAR_CYCLIC_ID, None)\n            if name in self._registered_vars_by_name:\n                registered_var = self._registered_vars_by_name[name]\n                registered_var.set_value(value)\n                if registered_var.cyclic_id != cyclic_id:\n                    if registered_var.cyclic_id is not None:\n                        var_cyclic = self.GetVariableByCyclicId(registered_var.cyclic_id)\n                        if var_cyclic:\n                            del self._registered_cyclic_id[registered_var.cyclic_id]\n                    registered_var.cyclic_id = cyclic_id\n                    if cyclic_id is not None and cyclic_id > 0:\n                        self._registered_cyclic_id[cyclic_id] = registered_var\n            else:\n                variable = rsc.RegisteredVariable(name=name, default=value, cyclic_id=cyclic_id)\n                self._register_variable(variable)", "hash": "cf802a307356", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_variable_added(self, message: Message)", "docstring": "Handle a message indicating that variables were created or modified on the robot (also called as connection)\n\n        Parameters\n        ----------\n        message : Message object that describes all the variables that were created or modified", "chunk_size_bytes": 1544, "original_size_bytes": 1896, "start_byte": 271744, "end_byte": 273640}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_base.py:87177861e689", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_handle_variable_removed", "qualified_name": "_Robot._handle_variable_removed", "source_path": "mecademicpy/mecademicpy/_robot_base.py", "loc": [5933, 5949], "text": "def _handle_variable_removed(self, message: Message):\n        \"\"\"Handle a message indicating that variables were deleted on the robot\n        Parameters\n        ----------\n        message : Message object that describes all the variables that were removed\n        \"\"\"\n        if not message.json_data:\n            return\n        json_data: dict = message.json_data.get(MX_JSON_KEY_DATA, {})\n        variables: dict[str, dict] = json_data.get(MX_JSON_KEY_VAR_LIST, {})\n        for name, _ in variables.items():\n            self._unregister_variable(name)", "hash": "87177861e689", "chunk_type": "method", "node_type": "function_definition", "signature": "_handle_variable_removed(self, message: Message)", "docstring": "Handle a message indicating that variables were deleted on the robot\n\n        Parameters\n        ----------\n        message : Message object that describes all the variables that were removed", "chunk_size_bytes": 553, "original_size_bytes": 589, "start_byte": 273646, "end_byte": 274235}
