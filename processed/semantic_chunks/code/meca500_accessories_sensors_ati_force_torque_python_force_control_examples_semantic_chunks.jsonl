{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:e6125c442fc3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "time", "qualified_name": "time", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [19, 19], "text": "import time", "hash": "e6125c442fc3", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 11, "original_size_bytes": 11, "start_byte": 527, "end_byte": 538}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:8bd3f84ddc47", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "math", "qualified_name": "math", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [20, 20], "text": "import math", "hash": "8bd3f84ddc47", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 11, "original_size_bytes": 11, "start_byte": 539, "end_byte": 550}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:0f3c72e18f95", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "List", "qualified_name": "List", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [21, 21], "text": "from typing import List, Tuple, Optional", "hash": "0f3c72e18f95", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 40, "original_size_bytes": 40, "start_byte": 551, "end_byte": 591}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:dd691568a7f7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "NetFTSensor", "qualified_name": "NetFTSensor", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [22, 22], "text": "from netft_sensor import NetFTSensor", "hash": "dd691568a7f7", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 36, "original_size_bytes": 36, "start_byte": 592, "end_byte": 628}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:be60ae675e65", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ForceController", "qualified_name": "ForceController", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [32, 143], "text": "class ForceController:\n    \"\"\"\n    Force control system for Meca500 robot with ATI sensors.\n    Provides high-level force control functions for common applications\n    including surface approach, constant force operations, and compliance.\n    \"\"\"", "hash": "be60ae675e65", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "Force control system for Meca500 robot with ATI sensors.\n    \n    Provides high-level force control functions for common applications\n    including surface approach, constant force operations, and compliance.", "chunk_size_bytes": 246, "original_size_bytes": 251, "start_byte": 841, "end_byte": 4647}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:712c9dd25cef", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "ForceController.__init__", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [40, 65], "text": "def __init__(self, robot_ip: str, sensor_ip: str):\n        \"\"\"\n        Initialize force controller.\n        Args:\n            robot_ip (str): IP address of Meca500 robot\n            sensor_ip (str): IP address of ATI sensor\n        \"\"\"\n        self.robot_ip = robot_ip\n        self.sensor_ip = sensor_ip\n        self.robot = None\n        self.sensor = None\n        self.max_velocity = 10.0  # mm/s\n        self.force_threshold = 0.5  # N\n        self.control_frequency = 50  # Hz\n        self.max_force = 50.0  # N\n        self.max_torque = 5.0  # Nm\n        self.emergency_stop = False", "hash": "712c9dd25cef", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self, robot_ip: str, sensor_ip: str)", "docstring": "Initialize force controller.\n        \n        Args:\n            robot_ip (str): IP address of Meca500 robot\n            sensor_ip (str): IP address of ATI sensor", "chunk_size_bytes": 586, "original_size_bytes": 740, "start_byte": 1102, "end_byte": 1842}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:bc3d80cacb6d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "connect", "qualified_name": "ForceController.connect", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [67, 100], "text": "def connect(self) -> bool:\n        \"\"\"\n        Connect to robot and sensor.\n        Returns:\n            bool: True if both connections successful\n        \"\"\"\n        try:\n            if MECADEMIC_AVAILABLE:\n                self.robot = Robot()\n                self.robot.Connect(self.robot_ip)\n                self.robot.ActivateRobot()\n                self.robot.Home()\n                self.robot.SetVelTimeout(0.05)  # 50ms timeout\n                print(f\"\u2713 Connected to robot at {self.robot_ip}\")\n            self.sensor = NetFTSensor(self.sensor_ip)\n            if self.sensor.connect():\n                self.sensor.start_streaming(1000)\n                time.sleep(1)  # Allow stabilization\n                self.sensor.set_bias()\n                print(f\"\u2713 Connected to sensor at {self.sensor_ip}\")\n                return True\n            else:\n                print(\"\u2717 Failed to connect to sensor\")\n                return False\n        except Exception as e:\n            print(f\"Connection error: {e}\")\n            return False", "hash": "bc3d80cacb6d", "chunk_type": "method", "node_type": "function_definition", "signature": "connect(self)", "docstring": "Connect to robot and sensor.\n        \n        Returns:\n            bool: True if both connections successful", "chunk_size_bytes": 1032, "original_size_bytes": 1213, "start_byte": 1856, "end_byte": 3063}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:dd68d47f9777", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "nect(self)", "qualified_name": "ForceController.nect(self)", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [102, 112], "text": "sconnect(self):\n        \"\"\"Disconnect from robot and sensor.\"\"\"\n        if self.sensor:\n            self.sensor.disconnect()\n        if self.robot and MECADEMIC_AVAILABLE:\n            self.robot.MoveVelTrf([0, 0, 0, 0, 0, 0])  # Stop movement\n            self.robot.DeactivateRobot()\n            self.robot.Disconnect()\n        print(\"Disconnected from robot and sensor\")", "hash": "dd68d47f9777", "chunk_type": "method", "node_type": "function_definition", "signature": "nect(self):\n    ", "docstring": "connect from robot and sensor.\"\"\"", "chunk_size_bytes": 371, "original_size_bytes": 395, "start_byte": 3073, "end_byte": 3468}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:85108aedb3a2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "safety_limits(self)", "qualified_name": "ForceController.safety_limits(self)", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [114, 135], "text": "eck_safety_limits(self) -> bool:\n        \"\"\"\n        Check if current forces are within safety limits.\n        Returns:\n            bool: True if safe, False if limits exceeded\n        \"\"\"\n        force_data = self.sensor.get_force()\n        force_magnitude = math.sqrt(sum(f*f for f in force_data[:3]))\n        if force_magnitude > self.max_force:\n            print(f\"Force limit exceeded: {force_magnitude:.2f} N > {self.max_force} N\")\n            return False\n        torque_magnitude = math.sqrt(sum(t*t for t in force_data[3:]))\n        if torque_magnitude > self.max_torque:\n            print(f\"Torque limit exceeded: {torque_magnitude:.3f} Nm > {self.max_torque} Nm\")\n            return False\n        return True", "hash": "85108aedb3a2", "chunk_type": "method", "node_type": "function_definition", "signature": "safety_limits(self) -> bo", "docstring": "Check if current forces are within safety limits.\n        \n        Returns:\n            bool: True if safe, False if limits exceeded\n        \"\"\"", "chunk_size_bytes": 719, "original_size_bytes": 820, "start_byte": 3478, "end_byte": 4298}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:4f41eaf7e864", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ncy_stop_check(self)", "qualified_name": "ForceController.ncy_stop_check(self)", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [137, 143], "text": "ergency_stop_check(self):\n        \"\"\"Emergency stop if safety limits exceeded.\"\"\"\n        if not self.check_safety_limits():\n            self.emergency_stop = True\n            if self.robot and MECADEMIC_AVAILABLE:\n                self.robot.MoveVelTrf([0, 0, 0, 0, 0, 0])\n            print(\"EMERGENCY STOP: Safety limits exceeded!\")\ncla", "hash": "4f41eaf7e864", "chunk_type": "method", "node_type": "function_definition", "signature": "ncy_stop_check(self):\n    ", "docstring": "rgency stop if safety limits exceeded.\"\"\"", "chunk_size_bytes": 337, "original_size_bytes": 339, "start_byte": 4308, "end_byte": 4647}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:72e215ec6a51", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "eApproach(Force", "qualified_name": "eApproach(Force", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [146, 221], "text": "SurfaceApproach(ForceController):\n    \"\"\"\n    Force-controlled surface approach operations.\n    Slowly approach a surface until contact force is detected,\n    useful for automated contact operations and surface detection.\n    \"\"\"", "hash": "72e215ec6a51", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "Force-controlled surface approach operations.\n    \n    Slowly approach a surface until contact force is detected,\n    useful for automated contact operations and surface detection.\n    \"\"\"", "chunk_size_bytes": 229, "original_size_bytes": 234, "start_byte": 4650, "end_byte": 7622}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:3800d0763407", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ch_surface_z(self,", "qualified_name": "eApproach(Force.ch_surface_z(self,", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [154, 221], "text": "proach_surface_z(self, target_force: float = 5.0, \n                          approach_velocity: float = 2.0,\n                          max_distance: float = 50.0) -> bool:\n        \"\"\"\n        Approach surface in Z direction until target force is reached.\n        Args:\n            target_force (float): Target contact force in Newtons\n            approach_velocity (float): Approach velocity in mm/s\n            max_distance (float): Maximum approach distance in mm\n        Returns:\n            bool: True if surface contact achieved, False if failed\n        \"\"\"\n        if not (self.robot and self.sensor and MECADEMIC_AVAILABLE):\n            print(\"Robot and sensor must be connected\")\n            return False\n        print(f\"Starting surface approach: target force = {target_force:.1f} N\")\n        start_time = time.time()\n        distance_traveled = 0.0\n        try:\n            while distance_traveled < max_distance and not self.emergency_stop:\n                force_data = self.sensor.get_force()\n                current_force = abs(force_data[2])  # Z-axis force\n                self.emergency_stop_check()\n                if self.emergency_stop:\n                    break\n                if current_force >= target_force:\n                    self.robot.MoveVelTrf([0, 0, 0, 0, 0, 0])\n                    print(f\"\u2713 Surface contact achieved: {current_force:.2f} N\")\n                    return True\n                velocity = [0, 0, -approach_velocity, 0, 0, 0]  # Move down\n                self.robot.MoveVelTrf(velocity)\n                dt = 1.0 / self.control_frequency\n                distance_traveled += approach_velocity * dt\n                print(f\"Force: {current_force:5.2f} N, Distance: {distance_traveled:5.1f} mm\", end='\\r')\n                time.sleep(dt)\n            self.robot.MoveVelTrf([0, 0, 0, 0, 0, 0])\n            if distance_traveled >= max_distance:\n                print(f\"\\n\u2717 Maximum approach distance reached: {max_distance} mm\")\n                return False\n            return False\n        except Exception as e:\n            print(f\"\\nSurface approach error: {e}\")\n            if self.robot:\n                self.robot.MoveVelTrf([0, 0, 0, 0, 0, 0])\n            return False\nclass C", "hash": "3800d0763407", "chunk_type": "method", "node_type": "function_definition", "signature": "ch_surface_z(self, target_force: float = 5.0, \n                          approach_velocity: float = 2.0,\n                          max_distance: float = 50.0) -> bo", "docstring": "Approach surface in Z direction until target force is reached.\n        \n        Args:\n            target_force (float): Target contact force in Newtons\n            approach_velocity (float): Approach velocity in mm/s\n            max_distance (float): Maximum approach distance in mm\n            \n        Returns:\n            bool: True if surface contact achieved, False if failed\n        \"\"\"", "chunk_size_bytes": 2217, "original_size_bytes": 2726, "start_byte": 4900, "end_byte": 7622}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:ba2caaabef2d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "rceControl(ForceCont", "qualified_name": "rceControl(ForceCont", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [224, 398], "text": "tantForceControl(ForceController):\n    \"\"\"\n    Constant force control for polishing and grinding operations.\n    Maintains constant contact force while following a trajectory,\n    compensating for surface variations and tool wear.\n    \"\"\"", "hash": "ba2caaabef2d", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "nstant force control for polishing and grinding operations.\n    \n    Maintains constant contact force while following a trajectory,\n    compensating for surface variations and tool wear.\n    \"\"\"", "chunk_size_bytes": 238, "original_size_bytes": 243, "start_byte": 7625, "end_byte": 14203}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:eb96f7a5f6e7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "elf, rob", "qualified_name": "rceControl(ForceCont.elf, rob", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [232, 242], "text": "__(self, robot_ip: str, sensor_ip: str):\n        super().__init__(robot_ip, sensor_ip)\n        self.kp_force = 0.5   # Proportional gain\n        self.ki_force = 0.01  # Integral gain  \n        self.kd_force = 0.05  # Derivative gain\n        self.force_error_integral = 0.0\n        self.previous_force_error = 0.0", "hash": "eb96f7a5f6e7", "chunk_type": "method", "node_type": "function_definition", "signature": "elf, robot_ip: str, sensor_ip: str):\n        ", "docstring": null, "chunk_size_bytes": 312, "original_size_bytes": 424, "start_byte": 7888, "end_byte": 8312}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:9550c014a5c8", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "orce_polishing(self, tar", "qualified_name": "rceControl(ForceCont.orce_polishing(self, tar", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [244, 285], "text": "nt_force_polishing(self, target_force: float = 10.0,\n                               polishing_trajectory: List[List[float]] = None,\n                               lateral_velocity: float = 5.0) -> bool:\n        \"\"\"\n        Perform constant force polishing operation.\n        Args:\n            target_force (float): Target polishing force in Newtons\n            polishing_trajectory (List): List of [x, y] positions for polishing path\n            lateral_velocity (float): Lateral movement velocity in mm/s\n        Returns:\n            bool: True if polishing completed successfully\n        \"\"\"\n        if not polishing_trajectory:\n            polishing_trajectory = [[i, 0] for i in range(0, 100, 5)]\n        print(f\"Starting constant force polishing: target force = {target_force:.1f} N\")\n        try:\n            for i, position in enumerate(polishing_trajectory):\n                if self.emergency_stop:\n                    break\n                print(f\"Polishing point {i+1}/{len(polishing_trajectory)}: ({position[0]:.1f}, {position[1]:.1f})\")\n                if not self._move_with_force_control(position[0], position[1], \n                                                   target_force, lateral_velocity):\n                    print(f\"Failed to reach position {position}\")\n                    return False\n                self._maintain_force(target_force, duration=2.0)\n            print(\"\u2713 Polishing operation completed\")\n            return True\n        except Exception as e:\n            print(f\"Polishing error: {e}\")\n            return False\n    de", "hash": "9550c014a5c8", "chunk_type": "method", "node_type": "function_definition", "signature": "orce_polishing(self, target_force: float = 10.0,\n                               polishing_trajectory: List[List[float]] = None,\n                               lateral_velocity: float = 5.0) -> bool:\n", "docstring": "Perform constant force polishing operation.\n        \n        Args:\n            target_force (float): Target polishing force in Newtons\n            polishing_trajectory (List): List of [x, y] positions for polishing path\n            lateral_velocity (float): Lateral movement velocity in mm/s\n            \n        Returns:\n            bool: True if polishing completed successfully\n        \"\"\"\n        i", "chunk_size_bytes": 1559, "original_size_bytes": 1847, "start_byte": 8322, "end_byte": 10167}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:232181e70eae", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "orce_control(self, targe", "qualified_name": "rceControl(ForceCont.orce_control(self, targe", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [287, 342], "text": "th_force_control(self, target_x: float, target_y: float,\n                               target_force: float, lateral_velocity: float) -> bool:\n        \"\"\"\n        Move to target X,Y position while maintaining Z force.\n        Args:\n            target_x (float): Target X position in mm\n            target_y (float): Target Y position in mm  \n            target_force (float): Target Z force in Newtons\n            lateral_velocity (float): Lateral movement velocity in mm/s\n        Returns:\n            bool: True if position reached successfully\n        \"\"\"\n        if not (self.robot and self.sensor and MECADEMIC_AVAILABLE):\n            return False\n        current_pose = self.robot.GetPose()\n        current_x, current_y = current_pose[0], current_pose[1]\n        dx = target_x - current_x\n        dy = target_y - current_y\n        distance = math.sqrt(dx*dx + dy*dy)\n        if distance < 1.0:  # Already at target\n            return True\n        vx = (dx / distance) * lateral_velocity\n        vy = (dy / distance) * lateral_velocity\n        start_time = time.time()\n        movement_time = distance / lateral_velocity\n        while time.time() - start_time < movement_time and not self.emergency_stop:\n            force_data = self.sensor.get_force()\n            current_force = abs(force_data[2])  # Z-axis force\n            vz = self._calculate_force_correction(current_force, target_force)\n            velocity = [vx, vy, vz, 0, 0, 0]\n            self.robot.MoveVelTrf(velocity)\n            self.emergency_stop_check()\n            time.sleep(1.0 / self.control_frequency)\n        self.robot.MoveVelTrf([0, 0, 0, 0, 0, 0])\n        return True\n    de", "hash": "232181e70eae", "chunk_type": "method", "node_type": "function_definition", "signature": "orce_control(self, target_x: float, target_y: float,\n                               target_force: float, lateral_velocity: float) -> bool:\n  ", "docstring": "Move to target X,Y position while maintaining Z force.\n        \n        Args:\n            target_x (float): Target X position in mm\n            target_y (float): Target Y position in mm  \n            target_force (float): Target Z force in Newtons\n            lateral_velocity (float): Lateral movement velocity in mm/s\n            \n        Returns:\n            bool: True if position reached successfully\n        \"\"\"\n        if", "chunk_size_bytes": 1659, "original_size_bytes": 2079, "start_byte": 10177, "end_byte": 12256}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:c00255fa836e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "rce(self, targe", "qualified_name": "rceControl(ForceCont.rce(self, targe", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [344, 368], "text": "n_force(self, target_force: float, duration: float = 2.0):\n        \"\"\"\n        Maintain constant force for specified duration.\n        Args:\n            target_force (float): Target force in Newtons\n            duration (float): Duration to maintain force in seconds\n        \"\"\"\n        start_time = time.time()\n        while time.time() - start_time < duration and not self.emergency_stop:\n            force_data = self.sensor.get_force()\n            current_force = abs(force_data[2])\n            vz = self._calculate_force_correction(current_force, target_force)\n            velocity = [0, 0, vz, 0, 0, 0]\n            self.robot.MoveVelTrf(velocity)\n            self.emergency_stop_check()\n            time.sleep(1.0 / self.control_frequency)\n    de", "hash": "c00255fa836e", "chunk_type": "method", "node_type": "function_definition", "signature": "rce(self, target_force: float, duration: float = 2.0):\n        \"\"", "docstring": "Maintain constant force for specified duration.\n        \n        Args:\n            target_force (float): Target force in Newtons\n            duration (float): Duration to maintain force in seconds\n        \"\"\"\n        sta", "chunk_size_bytes": 752, "original_size_bytes": 921, "start_byte": 12266, "end_byte": 13187}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:60bbb893d2c6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "orce_correction(self, curre", "qualified_name": "rceControl(ForceCont.orce_correction(self, curre", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [370, 398], "text": "te_force_correction(self, current_force: float, target_force: float) -> float:\n        \"\"\"\n        Calculate velocity correction using PID control.\n        Args:\n            current_force (float): Current measured force\n            target_force (float): Target force setpoint\n        Returns:\n            float: Z velocity correction in mm/s\n        \"\"\"\n        error = target_force - current_force\n        self.force_error_integral += error\n        error_derivative = error - self.previous_force_error\n        self.previous_force_error = error\n        output = (self.kp_force * error + \n                 self.ki_force * self.force_error_integral +\n                 self.kd_force * error_derivative)\n        max_correction = 5.0  # mm/s\n        return max(-max_correction, min(max_correction, output))\nclass For", "hash": "60bbb893d2c6", "chunk_type": "method", "node_type": "function_definition", "signature": "orce_correction(self, current_force: float, target_force: float) -> float:\n ", "docstring": "Calculate velocity correction using PID control.\n        \n        Args:\n            current_force (float): Current measured force\n            target_force (float): Target force setpoint\n            \n        Returns:\n            float: Z velocity correction in mm/s\n        \"\"\"\n        # P", "chunk_size_bytes": 811, "original_size_bytes": 1006, "start_byte": 13197, "end_byte": 14203}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:4753e1f2a48b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "nsertion(ForceContro", "qualified_name": "nsertion(ForceContro", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [401, 495], "text": "uidedInsertion(ForceController):\n    \"\"\"\n    Force-guided insertion operations for assembly tasks.\n    Provides compliant insertion with force and torque monitoring\n    for peg-in-hole and similar assembly operations.\n    \"\"\"", "hash": "4753e1f2a48b", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "e-guided insertion operations for assembly tasks.\n    \n    Provides compliant insertion with force and torque monitoring\n    for peg-in-hole and similar assembly operations.\n    \"\"\"\n    \n    de", "chunk_size_bytes": 225, "original_size_bytes": 230, "start_byte": 14206, "end_byte": 17924}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:d3f53bbe735e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "sertion(self, inser", "qualified_name": "nsertion(ForceContro.sertion(self, inser", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [409, 474], "text": "t_insertion(self, insertion_depth: float = 20.0,\n                          max_insertion_force: float = 20.0,\n                          max_lateral_force: float = 5.0) -> bool:\n        \"\"\"\n        Perform compliant insertion with force monitoring.\n        Args:\n            insertion_depth (float): Target insertion depth in mm\n            max_insertion_force (float): Maximum allowable insertion force\n            max_lateral_force (float): Maximum allowable lateral force\n        Returns:\n            bool: True if insertion completed successfully\n        \"\"\"\n        print(f\"Starting compliant insertion: depth = {insertion_depth:.1f} mm\")\n        if not (self.robot and self.sensor and MECADEMIC_AVAILABLE):\n            return False\n        insertion_velocity = 1.0  # mm/s - slow for compliance\n        depth_achieved = 0.0\n        try:\n            while depth_achieved < insertion_depth and not self.emergency_stop:\n                force_data = self.sensor.get_force()\n                fz = abs(force_data[2])  # Insertion force\n                fx, fy = abs(force_data[0]), abs(force_data[1])  # Lateral forces\n                if fz > max_insertion_force:\n                    print(f\"Insertion force exceeded: {fz:.2f} N\")\n                    break\n                if fx > max_lateral_force or fy > max_lateral_force:\n                    print(f\"Lateral force exceeded: Fx={fx:.2f}, Fy={fy:.2f} N\")\n                    self._apply_lateral_compliance(force_data)\n                velocity = [0, 0, -insertion_velocity, 0, 0, 0]\n                self.robot.MoveVelTrf(velocity)\n                depth_achieved += insertion_velocity / self.control_frequency\n                print(f\"Depth: {depth_achieved:5.1f} mm, Force: Fz={fz:5.2f} N\", end='\\r')\n                time.sleep(1.0 / self.control_frequency)\n            self.robot.MoveVelTrf([0, 0, 0, 0, 0, 0])\n            if depth_achieved >= insertion_depth:\n                print(f\"\\n\u2713 Insertion completed: {depth_achieved:.1f} mm\")\n                return True\n            else:\n                print(f\"\\n\u2717 Insertion stopped early: {depth_achieved:.1f} mm\")\n                return False\n        except Exception as e:\n            print(f\"\\nInsertion error: {e}\")\n            if self.robot:\n                self.robot.MoveVelTrf([0, 0, 0, 0, 0, 0])\n            return False\n    def _a", "hash": "d3f53bbe735e", "chunk_type": "method", "node_type": "function_definition", "signature": "sertion(self, insertion_depth: float = 20.0,\n                          max_insertion_force: float = 20.0,\n                          max_lateral_force: float = 5.0) -> bool:\n  ", "docstring": "Perform compliant insertion with force monitoring.\n        \n        Args:\n            insertion_depth (float): Target insertion depth in mm\n            max_insertion_force (float): Maximum allowable insertion force\n            max_lateral_force (float): Maximum allowable lateral force\n            \n        Returns:\n            bool: True if insertion completed successfully\n        \"\"\"\n        pri", "chunk_size_bytes": 2334, "original_size_bytes": 2767, "start_byte": 14458, "end_byte": 17221}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:3069bd66f47d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "ompliance(self, force_dat", "qualified_name": "nsertion(ForceContro.ompliance(self, force_dat", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [476, 495], "text": "al_compliance(self, force_data: List[float]):\n        \"\"\"\n        Apply lateral compliance based on force feedback.\n        Args:\n            force_data (List[float]): Current force/torque readings\n        \"\"\"\n        compliance_gain = 0.1  # mm/s per Newton\n        vx = -force_data[0] * compliance_gain  # Opposite to force direction\n        vy = -force_data[1] * compliance_gain\n        velocity = [vx, vy, 0, 0, 0, 0]\n        self.robot.MoveVelTrf(velocity)\n        time.sleep(0.1)", "hash": "3069bd66f47d", "chunk_type": "method", "node_type": "function_definition", "signature": "ompliance(self, force_data: List[float]):\n        \"\"\"\n  ", "docstring": "y lateral compliance based on force feedback.\n        \n        Args:\n            force_data (List[float]): Current force/torque readings\n        \"\"\"\n        # Compl", "chunk_size_bytes": 485, "original_size_bytes": 693, "start_byte": 17231, "end_byte": 17924}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:3b6c1b1d9d41", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "roach():\n    \"\"\"Demon", "qualified_name": "roach():\n    \"\"\"Demon", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [499, 520], "text": "_approach():\n    \"\"\"Demonstration of surface approach functionality.\"\"\"\n    robot_ip = \"192.168.0.100\"\n    sensor_ip = \"192.168.1.100\"\n    print(\"=== Surface Approach Demo ===\")\n    approach = SurfaceApproach(robot_ip, sensor_ip)\n    if approach.connect():\n        success = approach.approach_surface_z(target_force=5.0, \n                                            approach_velocity=2.0)\n        if success:\n            print(\"Surface approach completed successfully\")\n        else:\n            print(\"Surface approach failed\")\n        approach.disconnect()\n    else:\n        print(\"Failed to connect to robot and sensor\")\ndef demo_cons", "hash": "3b6c1b1d9d41", "chunk_type": "function", "node_type": "function_definition", "signature": "roach():\n    \"\"\"Demonst", "docstring": "of surface approach functionality.\"\"\"\n    robot_ip =", "chunk_size_bytes": 637, "original_size_bytes": 707, "start_byte": 17971, "end_byte": 18678}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:a108b0acb306", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "rce_polishing():\n    \"\"\"Demon", "qualified_name": "rce_polishing():\n    \"\"\"Demon", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [523, 551], "text": "t_force_polishing():\n    \"\"\"Demonstration of constant force polishing.\"\"\"\n    robot_ip = \"192.168.0.100\"\n    sensor_ip = \"192.168.1.100\"\n    print(\"=== Constant Force Polishing Demo ===\")\n    polisher = ConstantForceControl(robot_ip, sensor_ip)\n    if polisher.connect():\n        polishing_path = [\n            [0, 0], [10, 0], [20, 0], [30, 0],\n            [30, 10], [20, 10], [10, 10], [0, 10]\n        ]\n        success = polisher.constant_force_polishing(target_force=8.0,\n                                                   polishing_trajectory=polishing_path,\n                                                   lateral_velocity=3.0)\n        if success:\n            print(\"Polishing operation completed successfully\")\n        else:\n            print(\"Polishing operation failed\")\n        polisher.disconnect()\n    else:\n        print(\"Failed to connect to robot and sensor\")\ndef demo_comp", "hash": "a108b0acb306", "chunk_type": "function", "node_type": "function_definition", "signature": "rce_polishing():\n    \"\"\"Demonst", "docstring": "of constant force polishing.\"\"\"\n    robot_ip =", "chunk_size_bytes": 891, "original_size_bytes": 1005, "start_byte": 18681, "end_byte": 19686}
{"chunk_id": "meca_samples:meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py:3d20a4edf2c4", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "nsertion():\n    \"\"\"Demon", "qualified_name": "nsertion():\n    \"\"\"Demon", "source_path": "meca500-accessories/sensors/ati-force-torque/python/force_control_examples.py", "loc": [554, 576], "text": "nt_insertion():\n    \"\"\"Demonstration of compliant insertion.\"\"\"\n    robot_ip = \"192.168.0.100\"\n    sensor_ip = \"192.168.1.100\"\n    print(\"=== Compliant Insertion Demo ===\")\n    inserter = ForceGuidedInsertion(robot_ip, sensor_ip)\n    if inserter.connect():\n        success = inserter.compliant_insertion(insertion_depth=15.0,\n                                              max_insertion_force=15.0,\n                                              max_lateral_force=3.0)\n        if success:\n            print(\"Insertion completed successfully\")\n        else:\n            print(\"Insertion failed\")\n        inserter.disconnect()\n    else:\n        print(\"Failed to connect to robot and sensor\")\nif __name__ =", "hash": "3d20a4edf2c4", "chunk_type": "function", "node_type": "function_definition", "signature": "nsertion():\n    \"\"\"Demonst", "docstring": "of compliant insertion.\"\"\"\n    robot_ip =", "chunk_size_bytes": 701, "original_size_bytes": 764, "start_byte": 19689, "end_byte": 20453}
