{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:cd89a6634e6c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "queue", "qualified_name": "queue", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [9, 9], "text": "import queue", "hash": "cd89a6634e6c", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 12, "original_size_bytes": 12, "start_byte": 308, "end_byte": 320}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:e6125c442fc3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "time", "qualified_name": "time", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [10, 10], "text": "import time", "hash": "e6125c442fc3", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 11, "original_size_bytes": 11, "start_byte": 321, "end_byte": 332}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:59f9eee7282f", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "PurePath", "qualified_name": "PurePath", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [11, 11], "text": "from pathlib import PurePath", "hash": "59f9eee7282f", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 28, "original_size_bytes": 28, "start_byte": 333, "end_byte": 361}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:5ea2ded87fd2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "pandas as pd", "qualified_name": "pandas as pd", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [13, 13], "text": "import pandas as pd", "hash": "5ea2ded87fd2", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 19, "original_size_bytes": 19, "start_byte": 363, "end_byte": 382}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:e3269ed95593", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "MxRobotStatusCode as mx_st", "qualified_name": "MxRobotStatusCode as mx_st", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [15, 15], "text": "from .mx_robot_def import MxRobotStatusCode as mx_st", "hash": "e3269ed95593", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 52, "original_size_bytes": 52, "start_byte": 384, "end_byte": 436}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:9e7a5dc6e16d", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "unknown", "qualified_name": "unknown", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [17, 17], "text": "from .robot_classes import *", "hash": "9e7a5dc6e16d", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 28, "original_size_bytes": 28, "start_byte": 494, "end_byte": 522}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:d801645ecc5e", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "RobotTrajectories", "qualified_name": "RobotTrajectories", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [18, 18], "text": "from .robot_trajectory_files import RobotTrajectories", "hash": "d801645ecc5e", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 53, "original_size_bytes": 53, "start_byte": 523, "end_byte": 576}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:7037e0a9bf04", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_RobotTrajectoryLogger", "qualified_name": "_RobotTrajectoryLogger", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [63, 364], "text": "class _RobotTrajectoryLogger:\n    \"\"\"Class to handle logging robot state to file.\n    Attributes\n    ----------\n    file_name : str\n        Name of file produced by logger\n    fields : dict of strings\n        Fields to be logged. Key: attribute name in 'RobotState'. Value: Equivalent UpperCamelCase string or enum value\n        used in 'SetRealTimeMonitoring'\n    command_queue : queue\n        Queue to store sent commands.\n    element_width : int\n        Each numerical element will have this width.\n    timestamp_element_width: int\n        Each timestamp will have this width\n    done_logging: bool\n        'write_fields' wont log more robot states when this is True. Set to True by 'end_log'\n    logging_commands: bool\n        Indicate if sent commands are being logged\n    expanded_fields:\n        Elements of 'fields', but expanded to have a name for each sub-element of corresponding robot states\n    data_dict:\n        Keys: timestamps. Values: robot state stored at moment corresponding to timestamp\n    robot_trajectories: RobotTrajectories object\n        Contains robot states logged data and information about the robot used during logging\n    \"\"\"", "hash": "7037e0a9bf04", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "Class to handle logging robot state to file.\n\n    Attributes\n    ----------\n    file_name : str\n        Name of file produced by logger\n    fields : dict of strings\n        Fields to be logged. Key: attribute name in 'RobotState'. Value: Equivalent UpperCamelCase string or enum value\n        used in 'SetRealTimeMonitoring'\n    command_queue : queue\n        Queue to store sent commands.\n    element_width : int\n        Each numerical element will have this width.\n    timestamp_element_width: int\n        Each timestamp will have this width\n    done_logging: bool\n        'write_fields' wont log more robot states when this is True. Set to True by 'end_log'\n    logging_commands: bool\n        Indicate if sent commands are being logged\n    expanded_fields:\n        Elements of 'fields', but expanded to have a name for each sub-element of corresponding robot states\n    data_dict:\n        Keys: timestamps. Values: robot state stored at moment corresponding to timestamp\n    robot_trajectories: RobotTrajectories object\n        Contains robot states logged data and information about the robot used during logging", "chunk_size_bytes": 1159, "original_size_bytes": 1160, "start_byte": 3358, "end_byte": 17353}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:44d51cbca476", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "_RobotTrajectoryLogger.__init__", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [91, 178], "text": "def __init__(self,\n                 robot_info: RobotInfo,\n                 robot_rt_data: RobotRtData,\n                 fields: list[str] = None,\n                 file_name: str = None,\n                 file_path: str = None,\n                 record_time: bool = True,\n                 monitoring_interval: float = None):\n        \"\"\"Initialize class.\n        Parameters\n        ----------\n        robot_info : RobotInfo\n            Contains robot information.\n        robot_rt_data : RobotRtData object\n            Contains state of robot.\n        fields : list of strings\n            List of fields to be logged.\n        file_name: string or None\n            Log file name\n            If None, file name will be built with date/time and robot information (robot type, serial, version).\n        file_path : string or None\n            Path to save the zipped file that contains logged data + robot info in, respectively, csv and json file.\n            If not provided, file will be saved in working directory.\n        record_time : bool\n            If true, current time will also be recorded in the text file. (Time is also available in filename.)\n        monitoring_interval: float\n            Indicates rate at which state from robot is received on monitor port. Unit: seconds\n        \"\"\"\n        current_date_time = time.strftime('%Y-%m-%d-%H-%M-%S')\n        serial_number_or_blank = ('_serial_' + robot_info.serial) if robot_info.serial else \"\"\n        if file_name:\n            self.file_name = file_name\n        else:\n            self.file_name = (f'{robot_info.model}_R{robot_info.revision}_'\n                              f'v{robot_info.version.short_version}_'\n                              f'log_{current_date_time}{serial_number_or_blank}')\n        self.file_path = file_path\n        self.fields = dict()\n        if fields is None:\n            if robot_info.rt_message_capable:\n                for attr in vars(robot_rt_data):\n                    if attr.startswith('rt_'):\n                        self.fields[attr] = robot_rt_data_to_real_time_monit[attr][1]\n            else:\n                self.fields = {\n                    'rt_target_joint_pos': robot_rt_data_to_real_time_monit['rt_target_joint_pos'][1],\n                    'rt_target_cart_pos': robot_rt_data_to_real_time_monit['rt_target_cart_pos'][1]\n                }\n        else:\n            for field in fields:\n                for key, val in robot_rt_data_to_real_time_monit.items():\n                    if (isinstance(field, str) and field.lower() == val[1].lower()) or field == val[0]:\n                        self.fields[key] = val[1]\n                        break\n        self.command_queue: queue.Queue = queue.Queue()\n        self.element_width = 10\n        self.timestamp_element_width = 15\n        self.done_logging = False\n        self.logging_commands = True\n        self.expanded_fields: list = []\n        self.data_dict: dict = dict()  # Key: timestamp, Value: List of all corresponding robot_rt_data values\n        self.robot_trajectories = RobotTrajectories()\n        self.robot_trajectories.robot_context.robot_information.append(dict())\n        for attr in ['model', 'revision', 'version']:\n            self.robot_trajectories.robot_context.robot_information[0][attr] = f'{getattr(robot_info, attr)}'\n        if robot_info.serial is not None:\n            self.robot_trajectories.robot_context.robot_information[0]['serial_number'] = f'{robot_info.serial}'\n        if record_time:\n            self.robot_trajectories.robot_context.robot_information[0]['time_recorded'] = f'{current_date_time}'\n        if monitoring_interval:\n            self.robot_trajectories.robot_context.robot_information[0]['monitoring_interval'] = f'{monitoring_interval}'\n        self.write_field_and_element_headers(robot_info, robot_rt_data)", "hash": "44d51cbca476", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self,\n                 robot_info: RobotInfo,\n                 robot_rt_data: RobotRtData,\n                 fields: list[str] = None,\n                 file_name: str = None,\n                 file_path: str = None,\n                 record_time: bool = True,\n                 monitoring_interval: float = None)", "docstring": "Initialize class.\n\n        Parameters\n        ----------\n        robot_info : RobotInfo\n            Contains robot information.\n        robot_rt_data : RobotRtData object\n            Contains state of robot.\n        fields : list of strings\n            List of fields to be logged.\n        file_name: string or None\n            Log file name\n            If None, file name will be built with date/time and robot information (robot type, serial, version).\n        file_path : string or None\n            Path to save the zipped file that contains logged data + robot info in, respectively, csv and json file.\n            If not provided, file will be saved in working directory.\n        record_time : bool\n            If true, current time will also be recorded in the text file. (Time is also available in filename.)\n        monitoring_interval: float\n            Indicates rate at which state from robot is received on monitor port. Unit: seconds", "chunk_size_bytes": 3813, "original_size_bytes": 4223, "start_byte": 4524, "end_byte": 8747}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:e1c6d0208957", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "get_timestamp_data", "qualified_name": "_RobotTrajectoryLogger.get_timestamp_data", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [180, 199], "text": "def get_timestamp_data(self, robot_rt_data: RobotRtData, field):\n        \"\"\" Return timestamp data object associated with the specific field (or None).\n        Parameters\n        ----------\n        robot_rt_data : RobotRtData object\n            Current state of robot to get timestamp_data from\n        field : String\n            Name of the field to get timestamp_data for.\n        \"\"\"\n        if field == 'rt_accelerometer':\n            index = 5  # For now, only index 5 supported (joint 5's accelerometer)\n            accel_dict = getattr(robot_rt_data, field)\n            if index not in accel_dict:\n                return None\n            field_attr = accel_dict[index]\n        else:\n            field_attr = getattr(robot_rt_data, field)\n        return field_attr", "hash": "e1c6d0208957", "chunk_type": "method", "node_type": "function_definition", "signature": "get_timestamp_data(self, robot_rt_data: RobotRtData, field)", "docstring": "Return timestamp data object associated with the specific field (or None).\n\n        Parameters\n        ----------\n        robot_rt_data : RobotRtData object\n            Current state of robot to get timestamp_data from\n        field : String\n            Name of the field to get timestamp_data for.", "chunk_size_bytes": 770, "original_size_bytes": 772, "start_byte": 8753, "end_byte": 9525}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:deb1ab2c25e3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "_build_io_fields", "qualified_name": "_RobotTrajectoryLogger._build_io_fields", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [201, 221], "text": "def _build_io_fields(self, prefix: str, io_type: str, count: int) -> list[str]:\n        \"\"\"Build a list of digital IO field names\n        Parameters\n        ----------\n        prefix : str\n            IO bank prefix (ex: 'ioModule')\n        io_type : str\n            IO type ('Input' or 'Output')\n        count : int\n            Number of IOs of this type in this bank\n        Returns\n        -------\n        list[str]\n            _description_\n        \"\"\"\n        fields = []\n        for idx in range(count):\n            fields.append(f'{prefix}{io_type}_{idx + 1}')\n        return fields", "hash": "deb1ab2c25e3", "chunk_type": "method", "node_type": "function_definition", "signature": "_build_io_fields(self, prefix: str, io_type: str, count: int)", "docstring": "Build a list of digital IO field names\n\n        Parameters\n        ----------\n        prefix : str\n            IO bank prefix (ex: 'ioModule')\n        io_type : str\n            IO type ('Input' or 'Output')\n        count : int\n            Number of IOs of this type in this bank\n\n        Returns\n        -------\n        list[str]\n            _description_", "chunk_size_bytes": 589, "original_size_bytes": 591, "start_byte": 9531, "end_byte": 10122}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:a4ca2dbe6c46", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "write_field_and_element_headers", "qualified_name": "_RobotTrajectoryLogger.write_field_and_element_headers", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [223, 307], "text": "def write_field_and_element_headers(self, robot_info: RobotInfo, robot_rt_data: RobotRtData):\n        \"\"\"Write the full field name and element name in each column.\n        Parameters\n        ----------\n        robot_info : RobotInfo\n            Information about the robot, such as model name and number of joints.\n        robot_rt_data : RobotRtData object\n            Contains state of robot.\n        \"\"\"\n        def assemble_with_prefix(field, names):\n            return [field + '_' + str(x) for x in names]\n        for key, value in self.fields.items():\n            if (key.endswith('joint_pos') or key.endswith('joint_vel') or key.endswith('joint_torq')):\n                self.expanded_fields.extend(assemble_with_prefix(value, range(robot_info.num_joints)))\n            elif key.endswith('cart_pos') or key.endswith('wrf') or key.endswith('trf'):\n                if robot_info.num_joints == 4:\n                    self.expanded_fields.extend(assemble_with_prefix(value, ['X', 'Y', 'Z', 'Gamma']))\n                else:\n                    self.expanded_fields.extend(assemble_with_prefix(value, ['X', 'Y', 'Z', 'Alpha', 'Beta', 'Gamma']))\n            elif key.endswith('cart_vel'):\n                if robot_info.num_joints == 4:\n                    self.expanded_fields.extend(assemble_with_prefix(value, ['X_Dot', 'Y_Dot', 'Z_Dot', 'Omega_Z']))\n                else:\n                    self.expanded_fields.extend(\n                        assemble_with_prefix(value, ['X_Dot', 'Y_Dot', 'Z_Dot', 'Omega_X', 'Omega_Y', 'Omega_Z']))\n            elif key.endswith('rt_accelerometer'):\n                self.expanded_fields.extend(assemble_with_prefix(value, ['X', 'Y', 'Z']))\n            elif key.endswith('conf_turn'):\n                self.expanded_fields.append(value)\n            elif key.endswith('conf'):\n                self.expanded_fields.extend(assemble_with_prefix(value, ['Shoulder', 'Elbow', 'Wrist']))\n            elif key.endswith('checkpoint'):\n                self.expanded_fields.append(value)\n            elif key.endswith('rt_effective_time_scaling'):\n                self.expanded_fields.append(value)\n            elif key.endswith('rt_vm'):\n                columns = ['Baseboard', 'Psu', 'SafeMcu']\n                columns += range(robot_info.num_joints)\n                self.expanded_fields.extend(assemble_with_prefix(value, columns))\n            elif key.endswith('rt_current'):\n                columns = ['Baseboard']\n                self.expanded_fields.extend(assemble_with_prefix(value, columns))\n            elif key.endswith('rt_external_tool_status'):\n                self.expanded_fields.extend(\n                    assemble_with_prefix(value, ['SimModel', 'PhysicalModel', 'Present', 'Homed', 'Error']))\n            elif key.endswith('rt_valve_state'):\n                self.expanded_fields.extend(assemble_with_prefix(value, ['valve1', 'valve2']))\n            elif key.endswith('rt_gripper_state'):\n                self.expanded_fields.extend(\n                    assemble_with_prefix(value, ['Holding', 'TargetReached', 'Closed', 'Opened']))\n            elif key.endswith('rt_gripper_force'):\n                self.expanded_fields.extend(assemble_with_prefix(value, ['%']))\n            elif key.endswith('rt_gripper_pos'):\n                self.expanded_fields.extend(assemble_with_prefix(value, ['mm']))\n            elif key.endswith('rt_io_module_status'):\n                self.expanded_fields.extend(assemble_with_prefix(value, ['BankId', 'Present', 'SimMode', 'Error']))\n            elif key.endswith('rt_vacuum_state'):\n                self.expanded_fields.extend(assemble_with_prefix(value, ['VacuumOn', 'PurgeOn', 'Holding']))\n            elif key.endswith('rt_vacuum_pressure'):\n                self.expanded_fields.extend(assemble_with_prefix(value, ['kPa']))\n            elif key.endswith('rt_io_module_outputs'):\n                nb_outputs = len(robot_rt_data.rt_io_module_outputs.data)\n                if nb_outputs != 0:\n                    self.expanded_fields.extend(self._build_io_fields('IoModule', 'Output', nb_outputs))\n            elif key.endswith('rt_io_module_inputs'):\n                nb_inputs = len(robot_rt_data.rt_io_module_inputs.data)\n                if nb_inputs != 0:\n                    self.expanded_fields.extend(self._build_io_fields('IoModule', 'Input', nb_inputs))\n            elif key.endswith('rt_sig_gen_status'):\n                self.expanded_fields.extend(assemble_with_prefix(value, ['BankId', 'Present', 'SimMode', 'Error']))\n            elif key.endswith('rt_sig_gen_outputs'):\n                nb_outputs = len(robot_rt_data.rt_sig_gen_outputs.data)\n                if nb_outputs != 0:\n                    self.expanded_fields.extend(self._build_io_fields('SigGen', 'Output', nb_outputs))\n            elif key.endswith('rt_sig_gen_inputs'):\n                nb_inputs = len(robot_rt_data.rt_sig_gen_inputs.data)\n                if nb_inputs != 0:\n                    self.expanded_fields.extend(self._build_io_fields('SigGen', 'Input', nb_inputs))\n            else:\n                raise ValueError(f'Missing formatting for field: {key}')", "hash": "a4ca2dbe6c46", "chunk_type": "method", "node_type": "function_definition", "signature": "write_field_and_element_headers(self, robot_info: RobotInfo, robot_rt_data: RobotRtData)", "docstring": "Write the full field name and element name in each column.\n\n        Parameters\n        ----------\n        robot_info : RobotInfo\n            Information about the robot, such as model name and number of joints.\n        robot_rt_data : RobotRtData object\n            Contains state of robot.", "chunk_size_bytes": 5119, "original_size_bytes": 5258, "start_byte": 10128, "end_byte": 15386}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:0e1e461ba9f2", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "write_fields", "qualified_name": "_RobotTrajectoryLogger.write_fields", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [309, 331], "text": "def write_fields(self, timestamp, robot_rt_data: RobotRtData):\n        \"\"\"Write fields to file.\n        Parameters\n        ----------\n        timestamp : numeric\n            The timestamp of the current data.\n        robot_rt_data : RobotRtData object\n            This object contains the current robot state.\n        \"\"\"\n        if self.done_logging:\n            return\n        formatted_tim = f'{timestamp:{self.timestamp_element_width}}'\n        self.data_dict[formatted_tim] = []\n        for field in self.fields:\n            ts_data = self.get_timestamp_data(robot_rt_data, field)\n            if ts_data is None:\n                continue\n            self.data_dict[formatted_tim].extend([f'{x:{self.element_width}}' for x in ts_data.data])", "hash": "0e1e461ba9f2", "chunk_type": "method", "node_type": "function_definition", "signature": "write_fields(self, timestamp, robot_rt_data: RobotRtData)", "docstring": "Write fields to file.\n\n        Parameters\n        ----------\n        timestamp : numeric\n            The timestamp of the current data.\n        robot_rt_data : RobotRtData object\n            This object contains the current robot state.", "chunk_size_bytes": 744, "original_size_bytes": 856, "start_byte": 15392, "end_byte": 16248}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:e1c9d648dbd6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "stop_logging_commands", "qualified_name": "_RobotTrajectoryLogger.stop_logging_commands", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [333, 335], "text": "def stop_logging_commands(self):\n        \"\"\"Stops saving sent commands to log\"\"\"\n        self.logging_commands = False", "hash": "e1c9d648dbd6", "chunk_type": "method", "node_type": "function_definition", "signature": "stop_logging_commands(self)", "docstring": "Stops saving sent commands to log", "chunk_size_bytes": 118, "original_size_bytes": 118, "start_byte": 16254, "end_byte": 16372}
{"chunk_id": "meca_samples:mecademicpy/mecademicpy/_robot_trajectory_logger.py:04fa2fd073cc", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "end_log", "qualified_name": "_RobotTrajectoryLogger.end_log", "source_path": "mecademicpy/mecademicpy/_robot_trajectory_logger.py", "loc": [337, 364], "text": "def end_log(self, ignore_checkpoints=True):\n        \"\"\" Write all accumulated sent commands and close file.\n        Return\n        --------\n        string\n            Filename where logged info can be found\n        \"\"\"\n        self.done_logging = True\n        self.robot_trajectories.robot_df_hist.output_dfs.append(\n            pd.DataFrame.from_dict(self.data_dict, orient='index', columns=self.expanded_fields))\n        while not self.command_queue.empty():\n            command = self.command_queue.get()\n            if ignore_checkpoints and command.startswith('SetCheckpoint'):\n                continue\n            self.robot_trajectories.robot_context.sent_commands.append(command)\n        self.robot_trajectories.to_file(self.file_name, file_path=self.file_path)\n        if self.file_path:\n            return PurePath.joinpath(PurePath(self.file_path), self.file_name)\n        else:\n            return PurePath(self.file_name)", "hash": "04fa2fd073cc", "chunk_type": "method", "node_type": "function_definition", "signature": "end_log(self, ignore_checkpoints=True)", "docstring": "Write all accumulated sent commands and close file.\n\n        Return\n        --------\n\n        string\n            Filename where logged info can be found", "chunk_size_bytes": 933, "original_size_bytes": 975, "start_byte": 16378, "end_byte": 17353}
