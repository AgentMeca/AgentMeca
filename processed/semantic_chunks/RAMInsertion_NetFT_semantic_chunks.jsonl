{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:d11613a5082c", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "socket", "qualified_name": "socket", "source_path": "RAMInsertion/NetFT.py", "loc": [2, 2], "text": "import socket", "hash": "d11613a5082c", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 13, "original_size_bytes": 13, "start_byte": 19, "end_byte": 32}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:d695fd83bcac", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "struct", "qualified_name": "struct", "source_path": "RAMInsertion/NetFT.py", "loc": [3, 3], "text": "import struct", "hash": "d695fd83bcac", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 13, "original_size_bytes": 13, "start_byte": 33, "end_byte": 46}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:e6125c442fc3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "time", "qualified_name": "time", "source_path": "RAMInsertion/NetFT.py", "loc": [4, 4], "text": "import time", "hash": "e6125c442fc3", "chunk_type": "import", "node_type": "import_statement", "signature": null, "docstring": null, "chunk_size_bytes": 11, "original_size_bytes": 11, "start_byte": 47, "end_byte": 58}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:2e2e6a61c0d3", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Thread", "qualified_name": "Thread", "source_path": "RAMInsertion/NetFT.py", "loc": [5, 5], "text": "from threading import Thread", "hash": "2e2e6a61c0d3", "chunk_type": "import", "node_type": "import_from_statement", "signature": null, "docstring": null, "chunk_size_bytes": 28, "original_size_bytes": 28, "start_byte": 59, "end_byte": 87}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:eb0c1f480510", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "Sensor", "qualified_name": "Sensor", "source_path": "RAMInsertion/NetFT.py", "loc": [11, 187], "text": "class Sensor:\n     '''The class interface for an ATI Force/Torque sensor.\n     This class contains all the functions necessary to communicate\n     with an ATI Force/Torque sensor with a Net F/T interface\n     using RDT.\n     '''", "hash": "eb0c1f480510", "chunk_type": "class", "node_type": "class_definition", "signature": null, "docstring": "The class interface for an ATI Force/Torque sensor.\n     This class contains all the functions necessary to communicate\n     with an ATI Force/Torque sensor with a Net F/T interface\n     using RDT.", "chunk_size_bytes": 228, "original_size_bytes": 228, "start_byte": 146, "end_byte": 7107}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:6e1ca976e692", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "__init__", "qualified_name": "Sensor.__init__", "source_path": "RAMInsertion/NetFT.py", "loc": [17, 28], "text": "def __init__(self, ip):\n          '''Start the sensor interface\n          This function intializes the class and opens the socket for the\n          sensor.\n          Args:\n               ip (str): The IP address of the Net F/T box.\n          '''\n          self.ip = ip\n          self.port = 49152\n          self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n          self.mean = [0] * 6\n          self.stream = False", "hash": "6e1ca976e692", "chunk_type": "method", "node_type": "function_definition", "signature": "__init__(self, ip)", "docstring": "Start the sensor interface\n          This function intializes the class and opens the socket for the\n          sensor.\n          Args:\n               ip (str): The IP address of the Net F/T box.", "chunk_size_bytes": 427, "original_size_bytes": 427, "start_byte": 380, "end_byte": 807}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:4b685415d727", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "send", "qualified_name": "Sensor.send", "source_path": "RAMInsertion/NetFT.py", "loc": [30, 40], "text": "def send(self, command, count = 0):\n          '''Send a given command to the Net F/T box with specified sample count.\n          This function sends the given RDT command to the Net F/T box, along with\n          the specified sample count, if needed.\n          Args:\n               command (int): The RDT command.\n               count (int, optional): The sample count to send. Defaults to 0.\n          '''\n          header = 0x1234\n          message = struct.pack('!HHI', header, command, count)\n          self.sock.sendto(message, (self.ip, self.port))", "hash": "4b685415d727", "chunk_type": "method", "node_type": "function_definition", "signature": "send(self, command, count = 0)", "docstring": "Send a given command to the Net F/T box with specified sample count.\n          This function sends the given RDT command to the Net F/T box, along with\n          the specified sample count, if needed.\n          Args:\n               command (int): The RDT command.\n               count (int, optional): The sample count to send. Defaults to 0.", "chunk_size_bytes": 553, "original_size_bytes": 553, "start_byte": 814, "end_byte": 1367}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:67de1b51968b", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "recieve", "qualified_name": "Sensor.recieve", "source_path": "RAMInsertion/NetFT.py", "loc": [42, 54], "text": "def recieve(self):\n          '''Recieves and unpacks a response from the Net F/T box.\n          This function recieves and unpacks an RDT response from the Net F/T\n          box and saves it to the data class attribute.\n          Returns:\n               list of float: The force and torque values recieved. The first three\n                    values are the forces recorded, and the last three are the measured\n                    torques.\n          '''\n          rawdata = self.sock.recv(1024)\n          data = struct.unpack('!IIIiiiiii', rawdata)[3:]\n          output = [data[i] - self.mean[i] for i in range(6)]\n          return output", "hash": "67de1b51968b", "chunk_type": "method", "node_type": "function_definition", "signature": "recieve(self)", "docstring": "Recieves and unpacks a response from the Net F/T box.\n          This function recieves and unpacks an RDT response from the Net F/T\n          box and saves it to the data class attribute.\n          Returns:\n               list of float: The force and torque values recieved. The first three\n                    values are the forces recorded, and the last three are the measured\n                    torques.", "chunk_size_bytes": 638, "original_size_bytes": 638, "start_byte": 1374, "end_byte": 2012}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:5efcbddf11a6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "tare", "qualified_name": "Sensor.tare", "source_path": "RAMInsertion/NetFT.py", "loc": [56, 75], "text": "def tare(self, n = 10):\n          '''Tare the sensor.\n          This function takes a given number of readings from the sensor\n          and averages them. This mean is then stored and subtracted from\n          all future measurements.\n          Args:\n               n (int, optional): The number of samples to use in the mean.\n                    Defaults to 10.\n          Returns:\n               list of float: The mean values calculated.\n          '''\n          self.mean = [0] * 6\n          self.getMeasurements(n = n)\n          mean = [0] * 6\n          for i in range(n):\n               self.recieve()\n               for i in range(6):\n                    mean[i] += self.measurement()[i] / float(n)\n          self.mean = mean\n          return mean", "hash": "5efcbddf11a6", "chunk_type": "method", "node_type": "function_definition", "signature": "tare(self, n = 10)", "docstring": "Tare the sensor.\n          This function takes a given number of readings from the sensor\n          and averages them. This mean is then stored and subtracted from\n          all future measurements.\n          Args:\n               n (int, optional): The number of samples to use in the mean.\n                    Defaults to 10.\n          Returns:\n               list of float: The mean values calculated.", "chunk_size_bytes": 753, "original_size_bytes": 753, "start_byte": 2019, "end_byte": 2772}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:8766857b36be", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "zero", "qualified_name": "Sensor.zero", "source_path": "RAMInsertion/NetFT.py", "loc": [77, 79], "text": "def zero(self):\n          '''Remove the mean found with `tare` to start recieving raw sensor values.'''\n          self.mean = [0] * 6", "hash": "8766857b36be", "chunk_type": "method", "node_type": "function_definition", "signature": "zero(self)", "docstring": "Remove the mean found with `tare` to start recieving raw sensor values.", "chunk_size_bytes": 133, "original_size_bytes": 133, "start_byte": 2779, "end_byte": 2912}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:29a9980278c7", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "recieveHandler", "qualified_name": "Sensor.recieveHandler", "source_path": "RAMInsertion/NetFT.py", "loc": [81, 85], "text": "def recieveHandler(self):\n          '''A handler to recieve and store data.'''\n          while self.stream:\n                  self.recieve()", "hash": "29a9980278c7", "chunk_type": "method", "node_type": "function_definition", "signature": "recieveHandler(self)", "docstring": "A handler to recieve and store data.", "chunk_size_bytes": 140, "original_size_bytes": 157, "start_byte": 2919, "end_byte": 3076}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:77e6a7d057f0", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "getMeasurement", "qualified_name": "Sensor.getMeasurement", "source_path": "RAMInsertion/NetFT.py", "loc": [89, 104], "text": "def getMeasurement(self):\n          '''Get a single measurement from the sensor\n          Request a single measurement from the sensor and return it. If\n          The sensor is currently streaming, started by running `startStreaming`,\n          then this function will simply return the most recently returned value.\n          Returns:\n               list of float: The force and torque values recieved. The first three\n                    values are the forces recorded, and the last three are the measured\n                    torques.\n          '''\n          self.getMeasurements(1)\n          measured_data=[0,0,0,0,0,0]\n          output=self.recieve()\n          for i in range(6):\n               measured_data[i] = output[i]/ COUNTS_PER_FORCE\n          return measured_data", "hash": "77e6a7d057f0", "chunk_type": "method", "node_type": "function_definition", "signature": "getMeasurement(self)", "docstring": "Get a single measurement from the sensor\n          Request a single measurement from the sensor and return it. If\n          The sensor is currently streaming, started by running `startStreaming`,\n          then this function will simply return the most recently returned value.\n          Returns:\n               list of float: The force and torque values recieved. The first three\n                    values are the forces recorded, and the last three are the measured\n                    torques.", "chunk_size_bytes": 776, "original_size_bytes": 776, "start_byte": 3093, "end_byte": 3869}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:9b2e1bcbd3f6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "measurement", "qualified_name": "Sensor.measurement", "source_path": "RAMInsertion/NetFT.py", "loc": [106, 117], "text": "def measurement(self):\n          '''Get the most recent force/torque measurement\n          Returns:\n               list of float: The force and torque values recieved. The first three\n                    values are the forces recorded, and the last three are the measured\n                    torques.\n          '''\n          measured_data=[0,0,0,0,0,0]\n          output=self.recieve()\n          for i in range(6):\n               measured_data[i] = output[i]/ COUNTS_PER_FORCE\n          return measured_data", "hash": "9b2e1bcbd3f6", "chunk_type": "method", "node_type": "function_definition", "signature": "measurement(self)", "docstring": "Get the most recent force/torque measurement\n          Returns:\n               list of float: The force and torque values recieved. The first three\n                    values are the forces recorded, and the last three are the measured\n                    torques.", "chunk_size_bytes": 506, "original_size_bytes": 506, "start_byte": 3881, "end_byte": 4387}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:4ded37cab152", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "getForce", "qualified_name": "Sensor.getForce", "source_path": "RAMInsertion/NetFT.py", "loc": [119, 125], "text": "def getForce(self):\n          '''Get a single force measurement from the sensor\n          Request a single measurement from the sensor and return it.\n          Returns:\n               list of float: The force values recieved.\n          '''\n          return self.getMeasurement()[:3]", "hash": "4ded37cab152", "chunk_type": "method", "node_type": "function_definition", "signature": "getForce(self)", "docstring": "Get a single force measurement from the sensor\n          Request a single measurement from the sensor and return it.\n          Returns:\n               list of float: The force values recieved.", "chunk_size_bytes": 282, "original_size_bytes": 282, "start_byte": 4394, "end_byte": 4676}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:5a6236e5e8af", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "force", "qualified_name": "Sensor.force", "source_path": "RAMInsertion/NetFT.py", "loc": [127, 132], "text": "def force(self):\n          '''Get the most recent force measurement\n          Returns:\n               list of float: The force values recieved.\n          '''\n          return self.measurement()[:3]", "hash": "5a6236e5e8af", "chunk_type": "method", "node_type": "function_definition", "signature": "force(self)", "docstring": "Get the most recent force measurement\n          Returns:\n               list of float: The force values recieved.", "chunk_size_bytes": 197, "original_size_bytes": 197, "start_byte": 4683, "end_byte": 4880}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:ceba1fb6a1f6", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "getTorque", "qualified_name": "Sensor.getTorque", "source_path": "RAMInsertion/NetFT.py", "loc": [134, 140], "text": "def getTorque(self):\n          '''Get a single torque measurement from the sensor\n          Request a single measurement from the sensor and return it.\n          Returns:\n               list of float: The torque values recieved.\n          '''\n          return self.getMeasurement()[3:]", "hash": "ceba1fb6a1f6", "chunk_type": "method", "node_type": "function_definition", "signature": "getTorque(self)", "docstring": "Get a single torque measurement from the sensor\n          Request a single measurement from the sensor and return it.\n          Returns:\n               list of float: The torque values recieved.", "chunk_size_bytes": 285, "original_size_bytes": 285, "start_byte": 4887, "end_byte": 5172}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:910885835118", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "torque", "qualified_name": "Sensor.torque", "source_path": "RAMInsertion/NetFT.py", "loc": [142, 147], "text": "def torque(self):\n          '''Get the most recent torque measurement\n          Returns:\n               list of float: The torque values recieved.\n          '''\n          return self.measurement()[3:]", "hash": "910885835118", "chunk_type": "method", "node_type": "function_definition", "signature": "torque(self)", "docstring": "Get the most recent torque measurement\n          Returns:\n               list of float: The torque values recieved.", "chunk_size_bytes": 200, "original_size_bytes": 200, "start_byte": 5179, "end_byte": 5379}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:fe8a11510b78", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "startStreaming", "qualified_name": "Sensor.startStreaming", "source_path": "RAMInsertion/NetFT.py", "loc": [149, 166], "text": "def startStreaming(self, handler = True):\n          '''Start streaming data continuously\n          This function commands the Net F/T box to start sending data continuouly.\n          By default this also starts a new thread with a handler to save all data\n          points coming in. These data points can still be accessed with `measurement`,\n          `force`, and `torque`. This handler can also be disabled and measurements\n          can be recieved manually using the `recieve` function.\n          Args:\n               handler (bool, optional): If True start the handler which saves data to be\n                    used with `measurement`, `force`, and `torque`. If False the\n                    measurements must be recieved manually. Defaults to True.\n          '''\n          self.getMeasurements(0)\n          if handler:\n               self.stream = True\n               self.thread = Thread(target = self.recieveHandler)\n               self.thread.daemon = True\n               self.thread.start()", "hash": "fe8a11510b78", "chunk_type": "method", "node_type": "function_definition", "signature": "startStreaming(self, handler = True)", "docstring": "Start streaming data continuously\n          This function commands the Net F/T box to start sending data continuouly.\n          By default this also starts a new thread with a handler to save all data\n          points coming in. These data points can still be accessed with `measurement`,\n          `force`, and `torque`. This handler can also be disabled and measurements\n          can be recieved manually using the `recieve` function.\n          Args:\n               handler (bool, optional): If True start the handler which saves data to be\n                    used with `measurement`, `force`, and `torque`. If False the\n                    measurements must be recieved manually. Defaults to True.", "chunk_size_bytes": 1003, "original_size_bytes": 1003, "start_byte": 5386, "end_byte": 6389}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:065a9c43d250", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "getMeasurements", "qualified_name": "Sensor.getMeasurements", "source_path": "RAMInsertion/NetFT.py", "loc": [168, 175], "text": "def getMeasurements(self, n):\n          '''Request a given number of samples from the sensor\n          This function requestes a given number of samples from the sensor. These\n          measurements must be recieved manually using the `recieve` function.\n          Args:\n               n (int): The number of samples to request.\n          '''\n          self.send(2, count = n)", "hash": "065a9c43d250", "chunk_type": "method", "node_type": "function_definition", "signature": "getMeasurements(self, n)", "docstring": "Request a given number of samples from the sensor\n          This function requestes a given number of samples from the sensor. These\n          measurements must be recieved manually using the `recieve` function.\n          Args:\n               n (int): The number of samples to request.", "chunk_size_bytes": 376, "original_size_bytes": 376, "start_byte": 6396, "end_byte": 6772}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:57522aef4d05", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "stopStreaming", "qualified_name": "Sensor.stopStreaming", "source_path": "RAMInsertion/NetFT.py", "loc": [177, 184], "text": "def stopStreaming(self):\n          '''Stop streaming data continuously\n          This function stops the sensor from streaming continuously as started using\n          `startStreaming`.\n          '''\n          self.stream = False\n          time.sleep(0.1)\n          self.send(0)", "hash": "57522aef4d05", "chunk_type": "method", "node_type": "function_definition", "signature": "stopStreaming(self)", "docstring": "Stop streaming data continuously\n          This function stops the sensor from streaming continuously as started using\n          `startStreaming`.", "chunk_size_bytes": 277, "original_size_bytes": 277, "start_byte": 6779, "end_byte": 7056}
{"chunk_id": "meca_samples:RAMInsertion/NetFT.py:8ee4b2284c22", "repo": "meca_samples", "commit": "806f144", "lang": "python", "symbol": "setBias", "qualified_name": "Sensor.setBias", "source_path": "RAMInsertion/NetFT.py", "loc": [186, 187], "text": "def setBias(self):\n          self.send(0x42)", "hash": "8ee4b2284c22", "chunk_type": "method", "node_type": "function_definition", "signature": "setBias(self)", "docstring": null, "chunk_size_bytes": 44, "original_size_bytes": 44, "start_byte": 7063, "end_byte": 7107}
