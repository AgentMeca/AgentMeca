[
  {
    "snippet": "import socket",
    "span": [
      2,
      2
    ],
    "start_byte": 19,
    "end_byte": 32,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/RAMInsertion/NetFT.py"
  },
  {
    "snippet": "import struct",
    "span": [
      3,
      3
    ],
    "start_byte": 33,
    "end_byte": 46,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/RAMInsertion/NetFT.py"
  },
  {
    "snippet": "import time",
    "span": [
      4,
      4
    ],
    "start_byte": 47,
    "end_byte": 58,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/RAMInsertion/NetFT.py"
  },
  {
    "snippet": "from threading import Thread",
    "span": [
      5,
      5
    ],
    "start_byte": 59,
    "end_byte": 87,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/RAMInsertion/NetFT.py"
  },
  {
    "snippet": "class Sensor:\n     '''The class interface for an ATI Force/Torque sensor.\n     This class contains all the functions necessary to communicate\n     with an ATI Force/Torque sensor with a Net F/T interface\n     using RDT.\n     '''\n     def __init__(self, ip):\n          '''Start the sensor interface\n          This function intializes the class and opens the socket for the\n          sensor.\n          Args:\n               ip (str): The IP address of the Net F/T box.\n          '''\n          self.ip = ip\n          self.port = 49152\n          self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n          self.mean = [0] * 6\n          self.stream = False\n\n     def send(self, command, count = 0):\n          '''Send a given command to the Net F/T box with specified sample count.\n          This function sends the given RDT command to the Net F/T box, along with\n          the specified sample count, if needed.\n          Args:\n               command (int): The RDT command.\n               count (int, optional): The sample count to send. Defaults to 0.\n          '''\n          header = 0x1234\n          message = struct.pack('!HHI', header, command, count)\n          self.sock.sendto(message, (self.ip, self.port))\n\n     def recieve(self):\n          '''Recieves and unpacks a response from the Net F/T box.\n          This function recieves and unpacks an RDT response from the Net F/T\n          box and saves it to the data class attribute.\n          Returns:\n               list of float: The force and torque values recieved. The first three\n                    values are the forces recorded, and the last three are the measured\n                    torques.\n          '''\n          rawdata = self.sock.recv(1024)\n          data = struct.unpack('!IIIiiiiii', rawdata)[3:]\n          output = [data[i] - self.mean[i] for i in range(6)]\n          return output\n\n     def tare(self, n = 10):\n          '''Tare the sensor.\n          This function takes a given number of readings from the sensor\n          and averages them. This mean is then stored and subtracted from\n          all future measurements.\n          Args:\n               n (int, optional): The number of samples to use in the mean.\n                    Defaults to 10.\n          Returns:\n               list of float: The mean values calculated.\n          '''\n          self.mean = [0] * 6\n          self.getMeasurements(n = n)\n          mean = [0] * 6\n          for i in range(n):\n               self.recieve()\n               for i in range(6):\n                    mean[i] += self.measurement()[i] / float(n)\n          self.mean = mean\n          return mean\n\n     def zero(self):\n          '''Remove the mean found with `tare` to start recieving raw sensor values.'''\n          self.mean = [0] * 6\n\n     def recieveHandler(self):\n                \n          '''A handler to recieve and store data.'''\n          while self.stream:\n                  self.recieve()\n\n        \n\n     def getMeasurement(self):\n          '''Get a single measurement from the sensor\n          Request a single measurement from the sensor and return it. If\n          The sensor is currently streaming, started by running `startStreaming`,\n          then this function will simply return the most recently returned value.\n          Returns:\n               list of float: The force and torque values recieved. The first three\n                    values are the forces recorded, and the last three are the measured\n                    torques.\n          '''\n          self.getMeasurements(1)\n          measured_data=[0,0,0,0,0,0]\n          output=self.recieve()\n          for i in range(6):\n               measured_data[i] = output[i]/ COUNTS_PER_FORCE\n          return measured_data\n     \n     def measurement(self):\n          '''Get the most recent force/torque measurement\n          Returns:\n               list of float: The force and torque values recieved. The first three\n                    values are the forces recorded, and the last three are the measured\n                    torques.\n          '''\n          measured_data=[0,0,0,0,0,0]\n          output=self.recieve()\n          for i in range(6):\n               measured_data[i] = output[i]/ COUNTS_PER_FORCE\n          return measured_data\n\n     def getForce(self):\n          '''Get a single force measurement from the sensor\n          Request a single measurement from the sensor and return it.\n          Returns:\n               list of float: The force values recieved.\n          '''\n          return self.getMeasurement()[:3]\n\n     def force(self):\n          '''Get the most recent force measurement\n          Returns:\n               list of float: The force values recieved.\n          '''\n          return self.measurement()[:3]\n\n     def getTorque(self):\n          '''Get a single torque measurement from the sensor\n          Request a single measurement from the sensor and return it.\n          Returns:\n               list of float: The torque values recieved.\n          '''\n          return self.getMeasurement()[3:]\n\n     def torque(self):\n          '''Get the most recent torque measurement\n          Returns:\n               list of float: The torque values recieved.\n          '''\n          return self.measurement()[3:]\n\n     def startStreaming(self, handler = True):\n          '''Start streaming data continuously\n          This function commands the Net F/T box to start sending data continuouly.\n          By default this also starts a new thread with a handler to save all data\n          points coming in. These data points can still be accessed with `measurement`,\n          `force`, and `torque`. This handler can also be disabled and measurements\n          can be recieved manually using the `recieve` function.\n          Args:\n               handler (bool, optional): If True start the handler which saves data to be\n                    used with `measurement`, `force`, and `torque`. If False the\n                    measurements must be recieved manually. Defaults to True.\n          '''\n          self.getMeasurements(0)\n          if handler:\n               self.stream = True\n               self.thread = Thread(target = self.recieveHandler)\n               self.thread.daemon = True\n               self.thread.start()\n\n     def getMeasurements(self, n):\n          '''Request a given number of samples from the sensor\n          This function requestes a given number of samples from the sensor. These\n          measurements must be recieved manually using the `recieve` function.\n          Args:\n               n (int): The number of samples to request.\n          '''\n          self.send(2, count = n)\n\n     def stopStreaming(self):\n          '''Stop streaming data continuously\n          This function stops the sensor from streaming continuously as started using\n          `startStreaming`.\n          '''\n          self.stream = False\n          time.sleep(0.1)\n          self.send(0)\n\n     def setBias(self):\n          self.send(0x42)",
    "span": [
      11,
      187
    ],
    "start_byte": 146,
    "end_byte": 7107,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/RAMInsertion/NetFT.py",
    "name": "Sensor"
  }
]