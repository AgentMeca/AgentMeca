[
  {
    "snippet": "import copy",
    "span": [
      9,
      9
    ],
    "start_byte": 311,
    "end_byte": 322,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import functools",
    "span": [
      10,
      10
    ],
    "start_byte": 323,
    "end_byte": 339,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import ipaddress",
    "span": [
      11,
      11
    ],
    "start_byte": 340,
    "end_byte": 356,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import json",
    "span": [
      12,
      12
    ],
    "start_byte": 357,
    "end_byte": 368,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import logging",
    "span": [
      13,
      13
    ],
    "start_byte": 369,
    "end_byte": 383,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import math",
    "span": [
      14,
      14
    ],
    "start_byte": 384,
    "end_byte": 395,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import pathlib",
    "span": [
      15,
      15
    ],
    "start_byte": 396,
    "end_byte": 410,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import queue",
    "span": [
      16,
      16
    ],
    "start_byte": 411,
    "end_byte": 423,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import socket",
    "span": [
      17,
      17
    ],
    "start_byte": 424,
    "end_byte": 437,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import threading",
    "span": [
      18,
      18
    ],
    "start_byte": 438,
    "end_byte": 454,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import time",
    "span": [
      19,
      19
    ],
    "start_byte": 455,
    "end_byte": 466,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import weakref",
    "span": [
      20,
      20
    ],
    "start_byte": 467,
    "end_byte": 481,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "from argparse import ArgumentError",
    "span": [
      21,
      21
    ],
    "start_byte": 482,
    "end_byte": 516,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "from typing import Callable, Optional, Tuple, Union",
    "span": [
      22,
      22
    ],
    "start_byte": 517,
    "end_byte": 568,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import requests",
    "span": [
      24,
      24
    ],
    "start_byte": 570,
    "end_byte": 585,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import mecademicpy._robot_trajectory_logger as mx_traj",
    "span": [
      26,
      26
    ],
    "start_byte": 587,
    "end_byte": 641,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import mecademicpy.robot_global_functions as rgf",
    "span": [
      27,
      27
    ],
    "start_byte": 642,
    "end_byte": 690,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "import mecademicpy.robot_sidecar_classes as rsc",
    "span": [
      28,
      28
    ],
    "start_byte": 691,
    "end_byte": 738,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "from mecademicpy.robot_sidecar_classes import VariablesContainer",
    "span": [
      29,
      29
    ],
    "start_byte": 739,
    "end_byte": 803,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "from .mx_robot_def import MxRobotStatusCode as mx_st",
    "span": [
      32,
      32
    ],
    "start_byte": 875,
    "end_byte": 927,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "from .mx_robot_def import *",
    "span": [
      33,
      33
    ],
    "start_byte": 928,
    "end_byte": 955,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "from .robot_classes import *",
    "span": [
      34,
      34
    ],
    "start_byte": 956,
    "end_byte": 984,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "from .robot_trajectory_files import RobotTrajectories",
    "span": [
      35,
      35
    ],
    "start_byte": 985,
    "end_byte": 1038,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "from .tools import *",
    "span": [
      36,
      36
    ],
    "start_byte": 1039,
    "end_byte": 1059,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py"
  },
  {
    "snippet": "def disconnect_on_exception_decorator(func):\n    \"\"\"Decorator to call disconnect if an exception is raised. Needs to be declared outside of class.\n\n    Attributes\n    ----------\n    func : function object\n        Function to wrap.\n\"\"\"\n\n    @functools.wraps(func)\n    def wrap(self, *args, **kwargs):\n        try:\n            return func(self, *args, **kwargs)\n        # pylint: disable=broad-exception-caught\n        except BaseException as e:\n            # pylint: disable=protected-access\n            if self._disconnect_on_exception:\n                self._disconnect()\n                raise DisconnectError('Automatically disconnected as a result of exception, '\n                                      'set \\'disconnect_on_exception\\' to False to disable.') from e\n            else:\n                raise e\n\n    return wrap",
    "span": [
      48,
      71
    ],
    "start_byte": 1358,
    "end_byte": 2183,
    "node_type": "function_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py",
    "name": "disconnect_on_exception_decorator"
  },
  {
    "snippet": "class _RobotEvents:\n    \"\"\"Class for storing possible status events for the Mecademic robot.\n\n    Attributes\n    ----------\n    on_connected : event\n        Set if robot is connected.\n    on_disconnected : event\n        Set if robot is disconnected.\n    on_status_updated : event\n        Set if robot status is updated.\n    on_network_config_updated : event\n        Set if robot network configuration is updated.\n    on_status_gripper_updated : event\n        Set if gripper status is updated.\n    on_external_tool_status_updated: event\n        Set if external tool status has been updated.\n    on_gripper_state_updated: event\n        Set if gripper state has been updated.\n    on_valve_state_updated: event\n        Set if pneumatic module valve state has been updated.\n    on_output_state_updated: event\n        Set if digital outputs state has been updated.\n    on_input_state_updated: event\n        Set if digital inputs state has been updated.\n    on_vacuum_state_updated: event\n        Set if IO expansion module's vacuum module state has been updated.\n    on_holding_part: event\n        Set if gripper or IO expansion's vacuum gripper is holding a part.\n    on_released_part: event\n        Set if gripper or IO expansion's vacuum gripper is not holding a part.\n    on_vacuum_purge_done: event\n        Set when the vacuum gripper is not purging.\n    on_io_status_updated: event\n        Set if IO expansion module's status has been updated.\n    on_activated : event\n        Set if robot is activated.\n    on_deactivated : event\n        Set if robot is deactivated.\n    on_homed : event\n        Set if robot is homed.\n    on_error : event\n        Set if robot is in error.\n    on_error_reset : event\n        Set if robot error has been reset.\n    on_safety_stop_reset : event\n        Set if all safety signals that require the power supply Reset function (estop and pstop1) are reset.\n    on_safety_stop_resettable : event\n        Set if the power supply Reset function is currently available to reset safety signals (estop and pstop1).\n    on_safety_stop_state_change : event\n        Set if any safety stop status changes (see RobotSafetyStatus)\n    on_motion_paused : event\n        Set if robot motion is paused.\n    on_motion_resumed : event\n        Set if robot motion is not paused.\n    on_motion_cleared : event\n        Set if there are no pending ClearMotion commands.\n    on_activate_sim : event\n        Set if robot is in sim mode.\n    on_deactivate_sim : event\n        Set if robot is not in sim mode.\n    on_activate_ext_tool_sim : event\n        Set if robot is in gripper sim mode.\n    on_deactivate_ext_tool_sim : event\n        Set if robot is not in gripper sim mode.\n    on_io_sim_enabled : event\n        Set if robot IO module is not in sim mode.\n    on_io_sim_disabled : event\n        Set if robot IO module is in sim mode.\n    on_activate_recovery_mode : event\n        Set if robot is in recovery mode.\n    on_deactivate_recovery_mode : event\n        Set if robot is not in recovery mode.\n    on_joints_updated : event\n        Set if joint angles has been updated.\n    on_pose_updated : event\n        Set if robot pose has been updated.\n    on_brakes_activated : event\n        Set if brakes are activated.\n    on_brakes_deactivated : event\n        Set if brakes are deactivated.\n    on_offline_program_started : event\n        Set if there has been a change in the offline program state.\n    on_offline_program_op_done : event\n        Set when offline program operation (list/load/save/delete) has completed.\n    on_end_of_block : event\n        Set if end of block has been reached.\n    on_end_of_cycle: event\n        Set if end of cycle has been reached.\n    on_time_scaling_changed: event\n        Set if time scaling has changed.\n\"\"\"\n\n    def __init__(self):\n        self.on_connected = InterruptableEvent()\n        self.on_disconnected = InterruptableEvent()\n\n        self.on_status_updated = InterruptableEvent()\n        self.on_network_config_updated = InterruptableEvent()\n\n        self.on_status_gripper_updated = InterruptableEvent()\n        self.on_external_tool_status_updated = InterruptableEvent()\n        self.on_gripper_state_updated = InterruptableEvent()\n        self.on_valve_state_updated = InterruptableEvent()\n        self.on_output_state_updated = InterruptableEvent()\n        self.on_input_state_updated = InterruptableEvent()\n        self.on_vacuum_state_updated = InterruptableEvent()\n        self.on_holding_part = InterruptableEvent()\n        self.on_released_part = InterruptableEvent()\n        self.on_vacuum_purge_done = InterruptableEvent()\n        self.on_io_status_updated = InterruptableEvent()\n\n        self.on_activated = InterruptableEvent()\n        self.on_deactivated = InterruptableEvent()\n\n        self.on_homed = InterruptableEvent()\n\n        self.on_error = InterruptableEvent()\n        self.on_error_reset = InterruptableEvent()\n\n        # Safety stop support\n        self.on_safety_stop_reset = InterruptableEvent()\n        self.on_safety_stop_resettable = InterruptableEvent()\n        self.on_safety_stop_state_change = InterruptableEvent()\n\n        # Support for deprecated safety stop methods\n        self.on_pstop2 = InterruptableEvent()\n        self.on_pstop2_resettable = InterruptableEvent()\n        self.on_pstop2_reset = InterruptableEvent()\n        self.on_estop = InterruptableEvent()\n        self.on_estop_reset = InterruptableEvent()\n        self.on_estop_resettable = InterruptableEvent()\n\n        self.on_motion_paused = InterruptableEvent()\n        self.on_motion_resumed = InterruptableEvent()\n        self.on_motion_cleared = InterruptableEvent()\n\n        self.on_activate_sim = InterruptableEvent()\n        self.on_deactivate_sim = InterruptableEvent()\n\n        self.on_activate_ext_tool_sim = InterruptableEvent()\n        self.on_deactivate_ext_tool_sim = InterruptableEvent()\n\n        self.on_io_sim_enabled = InterruptableEvent()\n        self.on_io_sim_disabled = InterruptableEvent()\n\n        self.on_activate_recovery_mode = InterruptableEvent()\n        self.on_deactivate_recovery_mode = InterruptableEvent()\n\n        self.on_joints_updated = InterruptableEvent()\n        self.on_pose_updated = InterruptableEvent()\n\n        self.on_brakes_activated = InterruptableEvent()\n        self.on_brakes_deactivated = InterruptableEvent()\n\n        self.on_offline_program_started = InterruptableEvent()\n        self.on_file_op_done = InterruptableEvent()\n\n        self.on_time_scaling_changed = InterruptableEvent()\n\n        self.on_end_of_block = InterruptableEvent()\n        self.on_end_of_cycle = InterruptableEvent()\n\n        self.on_disconnected.set()\n        self.on_deactivated.set()\n        self.on_error_reset.set()\n\n        self.on_safety_stop_reset.set()\n        self.on_safety_stop_resettable.set()\n        self.on_safety_stop_state_change.set()\n        self.on_pstop2_reset.set()\n        self.on_pstop2_resettable.set()\n        self.on_estop_reset.set()\n        self.on_estop_resettable.set()\n\n        self.on_motion_resumed.set()\n        self.on_deactivate_sim.set()\n\n        self.on_time_scaling_changed.set()\n\n        self.on_status_updated.set()\n        self.on_network_config_updated.set()\n        self.on_status_gripper_updated.set()\n        self.on_external_tool_status_updated.set()\n        self.on_gripper_state_updated.set()\n        self.on_valve_state_updated.set()\n        self.on_output_state_updated.set()\n        self.on_input_state_updated.set()\n        self.on_vacuum_state_updated.set()\n        self.on_holding_part.set()\n        self.on_released_part.set()\n        self.on_vacuum_purge_done.set()\n        self.on_io_status_updated.set()\n\n        self.on_joints_updated.set()\n        self.on_pose_updated.set()\n        self.on_brakes_activated.set()\n\n    def clear_all(self):\n        \"\"\"Clear all events.\n\n        \"\"\"\n        for interruptable_event in self.__dict__.values():\n            interruptable_event.clear()\n\n    def abort_all(self, skipped_events: list[str] = None, message=\"\"):\n        \"\"\"Abort all events, except for events in skipped_events list.\n\n        \"\"\"\n        for event_name, interruptable_event in self.__dict__.items():\n            if not skipped_events or event_name not in skipped_events:\n                interruptable_event.abort(message)\n\n    def abort_all_on_error(self, message=\"\"):\n        \"\"\"Abort all events in the specific case where the robot has reported an error.\n\n        \"\"\"\n        self.abort_all(\n            skipped_events=[\n                'on_connected',  # Don't abort a wait for \"on_connected\" (should be done by now anyways)\n                'on_deactivated',  # Don't abort waiting for \"on_deactivated\". WaitDeactivated is can be used in error\n                'on_status_updated',  # Don't abort a wait for \"on_status_updated\", that's what we're doing!\n                'on_network_config_updated',  # Don't abort a wait for \"on_network_config_updated\", available in error\n                'on_error_reset',  # Don't abort a wait for \"on_error_reset\" because we got an error\n                'on_end_of_cycle',  # Don't abort a wait for \"on_end_of_cycle\", cycles should continue during error\n                'on_activate_recovery_mode',  # Don't abort wait for \"on_activate_recovery_mode\", available in error\n                'on_deactivate_recovery_mode',  # Don't abort wait for \"on_deactivate_recovery_mode\", available in error\n                'on_safety_stop_resettable',  # The \"Safety stop resettable\" state may still change while in error\n                'on_safety_stop_reset',  # The Safety stop reset state may still change while in error\n                'on_safety_stop_state_change',  # The \"Safety stop resettable\" state may still change while in error\n                'on_estop_reset',  # The EStop state may still change while in error\n                'on_pstop2_resettable',  # The \"PStop2 resettable\" state may still change while in error\n                'on_pstop2_reset',  # The PStop2 state may still change while in error\n                'on_estop_resettable',  # The \"EStop resettable\" state may still change while in error\n                'on_estop_reset',  # The EStop state may still change while in error\n                'on_time_scaling_changed',  # The set time scaling still works in error\n            ],\n            message=message)\n\n    def clear_abort_all(self):\n        \"\"\"Clear aborts for all events.\n\n        \"\"\"\n        for interruptable_event in self.__dict__.values():\n            interruptable_event.clear_abort()",
    "span": [
      74,
      318
    ],
    "start_byte": 2186,
    "end_byte": 12691,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py",
    "name": "_RobotEvents"
  },
  {
    "snippet": "class _CallbackQueue():\n    \"\"\"Queue class for storing triggered callbacks. Only registered callbacks are added to the queue.\n\n    Attributes\n    ----------\n    _queue : queue\n        Queue to use to store callback names and associated data.\n    _registered_callbacks : set\n        Set of names of registered callbacks.\n\"\"\"\n\n    def __init__(self, robot_callbacks):\n        self._queue = queue.Queue()\n        self._registered_callbacks = set()\n\n        for attr in robot_callbacks.__dict__:\n            if robot_callbacks.__dict__[attr] is not None:\n                self._registered_callbacks.add(attr)\n\n    def qsize(self) -> int:\n        \"\"\"Returns the queue size.\n\n        \"\"\"\n        return self._queue.qsize()\n\n    def register(self, callback_name):\n        \"\"\" Register a callback so it's enabled\"\"\"\n        if not callback_name in self._registered_callbacks:\n            self._registered_callbacks.add(callback_name)\n\n    def unregister(self, callback_name):\n        \"\"\" Unregister a callback so it's no longer called\"\"\"\n        if callback_name in self._registered_callbacks:\n            self._registered_callbacks.remove(callback_name)\n\n    def put(self, callback_name, data=None):\n        \"\"\"Put the callback name and associated data into the queue if is registered.\n\n        Parameters\n        ----------\n        callback_name : str\n            Name of callback.\n        data : any object type\n            Associated data.\n\n        \"\"\"\n        if callback_name in self._registered_callbacks or callback_name == _TERMINATE:\n            self._queue.put((callback_name, data))\n\n    def get(self, block=False, timeout: float = None) -> tuple[str, str]:\n        \"\"\"Get the next callback in the queue.\n\n        Parameters\n        ----------\n        block : bool\n            Block on next available callback if true.\n        timeout : float\n            Maximum time to wait on a callback.\n\n        Returns\n        -------\n        tuple of callback name and data\n\n        \"\"\"\n        return self._queue.get(block=block, timeout=timeout)",
    "span": [
      321,
      385
    ],
    "start_byte": 12694,
    "end_byte": 14734,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py",
    "name": "_CallbackQueue"
  },
  {
    "snippet": "class _Robot:\n    \"\"\"Class for controlling a Mecademic robot.\n\n    Attributes (private, please use public methods instead, i.e. methods not starting with underscore)\n    ----------\n    _address : string\n        The IP address associated to the Mecademic Robot.\n    _command_socket : socket object\n        Socket connecting to the command port of the Mecademic robot.\n    _monitor_socket : socket object\n        Socket connecting to the monitor port of the Mecademic robot.\n\n    _rx_thread : thread handle\n        Thread used to receive messages from the command port.\n    _command_rx_queue : queue\n        Queue used to temporarily store messages from the command port.\n    _tx_thread : thread handle\n        Thread used to transmit messages to the command port.\n    _command_tx_queue : queue\n        Queue used to temporarily store commands to be sent to the command port.\n    _monitor_rx_thread : thread handle\n        Thread used to receive messages from the monitor port.\n    _monitor_rx_queue : queue\n        Queue used to temporarily store messages from the monitor port.\n    _rx_timestamp : float\n        Last time a message was received from the robot\n\n    _rx_handler_thread : thread handle\n        Thread used to read messages from the command response queue.\n    _monitor_rx_handler_thread : thread handle\n        Thread used to read messages from the monitor queue.\n\n    _main_lock : recursive lock object\n        Used to protect internal state of the robot object.\n\n    _robot_info: RobotInfo object\n        Store information concerning robot (ex.: serial number)\n    _robot_rt_data : RobotRtData object\n        Stores current robot real-time data.\n        All attributes of this object are the latest captured on monitor port, so they don't necessarily share the same\n        timestamp\n    _robot_rt_data_stable : RobotRtData object\n        Stores current robot real-time data, but all attributes of object share the same timestamp\n    _robot_status: RobotStatus object\n        Stores current robot status\n    _robot_safety_status: RobotSafetyStatus object\n        Stores current robot safety status\n    _robot_psu_inputs: RobotPowerSupplyInputs object\n        Stores current robot power supply input states\n    _robot_collision_status: CollisionStatus\n        Stores current collision status (self collision and work zone boundary)\n    _gripper_status: GripperStatus object\n        Stores current gripper status\n    _external_tool_status: ExtToolStatus object\n        Stores current external tool status\n    _gripper_state: GripperState object\n        Stores current gripper state\n    _gripper_state_before_last_move : GripperState object\n        Stores gripper state at the time a Open/Close/Move gripper command is sent\n        (then used to accelerate WaitGripperMoveCompletion in case target_pos_reached is already True when its called\n         because otherwise it's not possible to know if the move has completed, or not yet started)\n    _valve_state: ValveState object\n        Stores current pneumatic valve state\n    _psu_io_status: IoStatus object\n        Stores current PSU IO module status\n    _io_module_status: IoStatus object\n        Stores current IO module status\n    _vacuum_state: IoStatus object\n        Stores current IO module's vacuum gripper state\n    _sig_gen_status: IoStatus object\n        Stores current signal generator status\n    _fw_update_status: Firmware update status\n        Stores current firmware update status reported by the robot\n    _robot_events : RobotEvents object\n        Stores events related to the robot state.\n\n    _file_logger : RobotDataLogger object\n        Collects RobotInformation, all RobotRtData and SentCommands during determined period\n    _monitoring_interval : float\n        Initial monitoring interval to restore after logging session\n\n    _robot_callbacks : RobotCallbacks instance\n        Stores user-defined callback functions.\n    _callback_queue : queue\n        Queue storing triggered callbacks.\n    _callback_thread : thread handle\n        Callbacks will run in this thread if so configured.\n\n    _user_checkpoints : dictionary\n        Stores checkpoints set or expected by user.\n    _internal_checkpoints : dictionary\n        Stores checkpoints set internally by the Robot class.\n    _internal_checkpoint_counter : int\n        Stores the next available checkpoint id for internal checkpoints.\n\n    _enable_synchronous_mode : boolean\n        If enabled, commands block until action is completed.\n\n    _clear_motion_requests : int\n        Number of pending ClearMotion requests.\n\n    logger : logger object\n        Logger used throughout class.\n\n    default_timeout : float\n        Default timeout to use for blocking operations.\n\n    _tmp_rt_joint_pos : list of float\n        Values from legacy mx_st.MX_ST_GET_JOINTS event received in current cycle\n    _tmp_rt_cart_pos : list of float\n        Values from legacy mx_st.MX_ST_GET_POSE event received in current cycle\n\n    _tx_sync : integer\n        Value sent in the most recent \"SyncCmdQueue\" request sent to robot\n    _rx_sync : integer\n        Most recent response to \"SyncCmdQueue\" (mx_st.MX_ST_SYNC_CMD_QUEUE) received from the robot\n\"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor for an instance of the Robot class.\n        \"\"\"\n        # Initialize member variables that are NOT reset by \"with\" block (i.e. by __enter__ and __exit__)\n        self.logger = logging.getLogger(__name__)\n        self._is_initialized = False\n        self._offline_mode = False\n        # (callbacks remain registered after \"with\" block\n        self._robot_callbacks = RobotCallbacks()\n        self._run_callbacks_in_separate_thread = False\n        self._reset()\n\n        # Build a dictionary of robot commands that, when sending them, we need to update internal states.\n        # We do it like this to catch code using \"SendCustomCommand\" instead of calling the official public API\n        # (for example: robot.SendCustomCommand(\"ActivateRobot(1)\") needs to behave like robot.ActivateRobot)\n        self._send_cmd_handlers: dict[str, Callable] = {\n            'activaterobot': self._sending_ActivateRobot,\n            'deletefile': self._sending_DeleteFile,\n            'deleteprogram': self._sending_DeleteFile,\n            'clearmotion': self._sending_ClearMotion,\n            'listfiles': self._sending_ListFiles,\n            'listprograms': self._sending_ListFiles,\n            'loadfile': self._sending_LoadFile,\n            'loadprogram': self._sending_LoadFile,\n            'home': self._sending_Home,\n            'savefile': self._sending_SaveFile,\n            'saveprogram': self._sending_SaveFile,\n            'setmonitoringinterval': self._sending_SetMonitoringInterval,\n            'settimescaling': self._sending_SetTimeScaling,\n            'startprogram': self._sending_StartProgram,\n        }\n\n        self._messages_handlers = {\n            mx_st.MX_ST_NOT_ACTIVATED:  # 1005\n            lambda response: self._invalidate_checkpoints('robot is not activated', forced=False),\n            mx_st.MX_ST_ALREADY_ERR:  # 1011\n            lambda response: self._invalidate_checkpoints('robot is in error', forced=False),\n            mx_st.MX_ST_ACTIVATION_ERR:  # 1013\n            self._handle_activation_err,\n            mx_st.MX_ST_HOMING_ERR:  # 1014\n            self._handle_homing_err,\n            mx_st.MX_ST_IMPOSSIBLE_RESET_ERR:  # 1025\n            self._handle_impossible_reset_err,\n            mx_st.MX_ST_LIST_FILES_ERR:  # 1500\n            lambda response: self._robot_events.on_file_op_done.abort(\"Failed to list files\"),\n            mx_st.MX_ST_LOAD_FILE_ERR:  # 1501\n            self._handle_load_file_err,\n            mx_st.MX_ST_SAVE_FILE_ERR:  # 1502\n            self._handle_save_file_err,\n            mx_st.MX_ST_DELETE_FILE_ERR:  # 1503\n            self._handle_delete_file_err,\n            mx_st.MX_ST_GET_STATUS_ROBOT:  # 2007\n            self._handle_robot_status_response,\n            mx_st.MX_ST_BRAKES_OFF:  # 2008\n            lambda response: self._set_brakes_engaged(False),\n            mx_st.MX_ST_BRAKES_ON:  # 2010\n            lambda response: self._set_brakes_engaged(True),\n            mx_st.MX_ST_TIME_SCALING:  # 2015\n            self._handle_get_time_scaling_response,\n            mx_st.MX_ST_GET_JOINTS:  # 2026\n            self._handle_get_joints_legacy,\n            mx_st.MX_ST_GET_POSE:  # 2027\n            self._handle_get_pose_legacy,\n            mx_st.MX_ST_GET_CONF:  # 2029\n            self._handle_get_conf_legacy,\n            mx_st.MX_ST_GET_CONF_TURN:  # 2036\n            self._handle_get_conf_turn_legacy,\n            mx_st.MX_ST_PAUSE_MOTION:  # 2042\n            self._handle_pause_motion,\n            mx_st.MX_ST_RESUME_MOTION:  # 2043\n            self._handle_resume_motion,\n            mx_st.MX_ST_CLEAR_MOTION:  # 2044\n            self._handle_clear_motion,\n            mx_st.MX_ST_EXTTOOL_SIM:  # 2047\n            self._handle_ext_tool_sim_status_legacy,\n            MX_ST_EXTTOOL_SIM_OFF:  # 2048\n            self._handle_ext_tool_sim_status_off,\n            mx_st.MX_ST_RECOVERY_MODE_ON:  # 2049\n            lambda response: self._handle_recovery_mode_status(True),\n            mx_st.MX_ST_RECOVERY_MODE_OFF:  # 2050\n            lambda response: self._handle_recovery_mode_status(False),\n            mx_st.MX_ST_OFFLINE_START:  # 2063\n            self._handle_offline_start,\n            mx_st.MX_ST_GET_STATUS_GRIPPER:  # 2079\n            self._handle_gripper_status_response,\n            mx_st.MX_ST_GET_ROBOT_SERIAL:  # 2083\n            self._handle_robot_get_robot_serial_response,\n            mx_st.MX_ST_GET_EXT_TOOL_FW_VERSION:  # 2086\n            self._handle_ext_tool_fw_version,\n            mx_st.MX_ST_GET_NETWORK_CFG:  # 2089\n            self._handle_get_network_cfg_response,\n            mx_st.MX_ST_SYNC_CMD_QUEUE:  # 2097\n            self._handle_sync_response,\n            mx_st.MX_ST_GET_REAL_TIME_MONITORING:  # 2117\n            self._handle_get_realtime_monitoring_response,\n            mx_st.MX_ST_GET_OPERATION_MODE:  # 2176\n            self._handle_get_operation_mode,\n            mx_st.MX_ST_CONNECTION_WATCHDOG:  # 2177\n            lambda response: self._set_connection_watchdog_enabled(self._parse_response_bool(response)[0]),\n            mx_st.MX_ST_GET_COLLISION_STATUS:  # 2182\n            self._handle_collision_status_response,\n            mx_st.MX_ST_GET_WORK_ZONE_STATUS:  # 2183\n            self._handle_work_zone_status_response,\n            mx_st.MX_ST_RT_TARGET_JOINT_POS:  # 2200\n            self._handle_target_joint_pos,\n            mx_st.MX_ST_RT_TARGET_CART_POS:  # 2201\n            self._handle_target_cart_pos,\n            mx_st.MX_ST_RT_TARGET_JOINT_VEL:  # 2202\n            self._handle_target_joint_vel,\n            mx_st.MX_ST_RT_TARGET_JOINT_TORQ:  # 2203\n            self._handle_target_joint_torq,\n            mx_st.MX_ST_RT_TARGET_CART_VEL:  # 2204\n            self._handle_target_cart_vel,\n            mx_st.MX_ST_RT_TARGET_CONF:  # 2208\n            self._handle_target_conf,\n            mx_st.MX_ST_RT_TARGET_CONF_TURN:  # 2209\n            self._handle_target_conf_turn,\n            mx_st.MX_ST_RT_JOINT_POS:  # 2210\n            self._handle_joint_pos,\n            mx_st.MX_ST_RT_CART_POS:  # 2211\n            self._handle_cart_pos,\n            mx_st.MX_ST_RT_JOINT_VEL:  # 2212\n            self._handle_joint_vel,\n            mx_st.MX_ST_RT_JOINT_TORQ:  # 2213\n            self._handle_joint_torq,\n            mx_st.MX_ST_RT_CART_VEL:  # 2214\n            self._handle_cart_vel,\n            mx_st.MX_ST_RT_CONF:  # 2218\n            self._handle_conf,\n            mx_st.MX_ST_RT_CONF_TURN:  # 2219\n            self._handle_conf_turn,\n            mx_st.MX_ST_RT_ACCELEROMETER:  # 2220\n            self._handle_accelerometer,\n            mx_st.MX_ST_RT_ABS_JOINT_POS:  # 2221\n            self._handle_abs_joint_pos,\n            mx_st.MX_ST_RT_EFFECTIVE_TIME_SCALING:  # 2222\n            self._handle_effective_time_scaling_data,\n            mx_st.MX_ST_RT_VM:  # 2223\n            self._handle_rt_vm,\n            mx_st.MX_ST_RT_CURRENT:  # 2224\n            self._handle_rt_current,\n            mx_st.MX_ST_RT_CHECKPOINT:  # 2227\n            self._handle_rt_checkpoint,\n            mx_st.MX_ST_RT_WRF:  # 2228\n            self._handle_wrf,\n            mx_st.MX_ST_RT_TRF:  # 2229\n            self._handle_trf,\n            mx_st.MX_ST_RT_CYCLE_END:  # 2230\n            self._handle_cycle_end,\n            mx_st.MX_ST_RT_EXTTOOL_STATUS:  # 2300\n            self._handle_external_tool_status_response,\n            mx_st.MX_ST_RT_VALVE_STATE:  # 2310\n            self._handle_valve_state_response,\n            mx_st.MX_ST_RT_GRIPPER_STATE:  # 2320\n            self._handle_gripper_state_response,\n            mx_st.MX_ST_RT_GRIPPER_FORCE:  # 2321\n            self._handle_gripper_force_response,\n            mx_st.MX_ST_RT_GRIPPER_POS:  # 2322\n            self._handle_gripper_pos_response,\n            mx_st.MX_ST_RT_IO_STATUS:  # 2330\n            self._handle_io_status,\n            mx_st.MX_ST_RT_OUTPUT_STATE:  # 2340\n            self._handle_output_state,\n            mx_st.MX_ST_RT_INPUT_STATE:  # 2341\n            self._handle_input_state,\n            mx_st.MX_ST_RT_VACUUM_STATE:  # 2342\n            self._handle_vacuum_state,\n            mx_st.MX_ST_RT_VACUUM_PRESSURE:  # 2343\n            self._handle_vacuum_pressure,\n            mx_st.MX_ST_LIST_FILES:  # 2500\n            self._handle_file_op_done,\n            mx_st.MX_ST_LOAD_FILE:  # 2501\n            self._handle_file_op_done,\n            mx_st.MX_ST_SAVE_FILE:  # 2502\n            self._handle_file_op_done,\n            mx_st.MX_ST_DELETE_FILE:  # 2503\n            self._handle_file_op_done,\n            mx_st.MX_ST_EOB:  # 3012\n            self._handle_eob,\n            mx_st.MX_ST_NO_OFFLINE_SAVED:  # 3017\n            self._handle_offline_program_error,\n            mx_st.MX_ST_OFFLINE_INVALID:  # 3020\n            self._handle_offline_program_error,\n            mx_st.MX_ST_TORQUE_LIMIT_STATUS:  # 3028\n            self._handle_torque_limit_status,\n            mx_st.MX_ST_CHECKPOINT_REACHED:  # 3030\n            lambda response: self._handle_checkpoint(response, discarded=False),\n            mx_st.MX_ST_PSTOP2:  # 3032\n            self._handle_pstop2_state,\n            mx_st.MX_ST_FW_UPDATE_PROGRESS:  # 3038\n            self._handle_fw_update_progress,\n            mx_st.MX_ST_CHECKPOINT_DISCARDED:  # 3040\n            lambda response: self._handle_checkpoint(response, discarded=True),\n            mx_st.MX_ST_PSTOP1:  # 3069\n            self._handle_pstop1_state,\n            mx_st.MX_ST_ESTOP:  # 3070\n            self._handle_estop_state,\n            mx_st.MX_ST_SAFE_STOP_OPERATION_MODE:  # 3080\n            self._handle_operation_mode_stop_state,\n            mx_st.MX_ST_SAFE_STOP_ENABLING_DEVICE_RELEASED:  # 3081\n            self._handle_enabling_device_released_stop_state,\n            mx_st.MX_ST_SAFE_STOP_VOLTAGE_FLUCTUATION:  # 3082\n            self._handle_voltage_fluctuation_stop_state,\n            mx_st.MX_ST_SAFE_STOP_REBOOT:  # 3083\n            self._handle_reboot_stop_state,\n            mx_st.MX_ST_SAFE_STOP_REDUNDANCY_FAULT:  # 3084\n            self._handle_redundancy_fault_stop_state,\n            mx_st.MX_ST_SAFE_STOP_STANDSTILL_FAULT:  # 3085\n            self._handle_standstill_fault_stop_state,\n            mx_st.MX_ST_SAFE_STOP_CONNECTION_DROPPED:  # 3086\n            self._handle_connection_dropped_stop_state,\n            mx_st.MX_ST_SAFE_STOP_MINOR_ERROR:  # 3087\n            self._handle_minor_error_stop_state,\n            mx_st.MX_ST_DICT_CMD_ADDED:  # 3200\n            self._handle_dict_cmd_added,\n            mx_st.MX_ST_DICT_CMD_REMOVED:  # 3201\n            self._handle_dict_cmd_removed,\n            mx_st.MX_ST_SIDECAR_STATUS:  # 3203\n            self._handle_sidecar_status,\n            mx_st.MX_ST_VARIABLE_ADDED:  # 3310\n            self._handle_variable_added,\n            mx_st.MX_ST_VARIABLE_REMOVED:  # 3311\n            self._handle_variable_removed,\n        }\n\n        # Sidecar support stuff\n        self._sidecar_registered_functions: dict[str, rsc.RegisteredFunction] = {}\n        self._sidecar_overridden_functions: dict[str, callable] = {}\n        self._sidecar_status: list[RobotSidecarStatus] = []\n        self._registered_vars_by_name: dict[str, rsc.RegisteredVariable] = {}\n        self._registered_cyclic_id: dict[int, Union[rsc.RegisteredFunction, rsc.RegisteredVariable]] = {}\n\n        # Create a variables container\n        self.vars = VariablesContainer()\n        self.vars.attach(self._get_variable, self._set_variable)\n\n    def __del__(self):\n        \"\"\"Destructor for an instance of the Robot class.\n\n        Warnings\n        --------\n        In python, the  destructor is called by garbage collector, it may not be called when Robot object\n        instance is released so make sure to explicitly Disconnect from the robot, or use \"with\" block if you\n        need to control when the disconnection with robot occurs.\n        \"\"\"\n        self._reset()\n        self.UnregisterCallbacks()\n\n    def __enter__(self):\n        \"\"\"Function called when entering \"with\" block with a Robot object instance.\n\n        Raises\n        ------\n        InvalidStateError\n            Exception raised if robot is already connected when entering \"with\" statement (since by design the usage\n            of the \"with\" statement is to ensure proper disconnection from the robot at the end of the \"with\" scope\n        \"\"\"\n        if self.IsConnected():\n            raise InvalidStateError('Robot cannot be connected when entering \\'with\\' block')\n        return self\n\n    #pylint: disable=redefined-outer-name\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Function called when exiting \"with\" block with a Robot object instance.\n        This forces disconnection with the robot and reset of all states, except registered callbacks\n        which remain attached in case the same Robot object is reconnected later.\n        \"\"\"\n        self._reset()\n\n    def _reset(self):\n        \"\"\" Reset the Robot class (disconnects, stop threads, clears queues, etc).\n        (this code is common to constructor, destructor and __exit__ implicit functions)\n        Only thing that is not reset are registered callbacks.\n        \"\"\"\n        if self._is_initialized and self.IsConnected():\n            self._disconnect()\n            # Note: Don't unregister callbacks, we allow them to remain valid after a \"with\" block\n            # self.UnregisterCallbacks()\n\n        self._address = None\n        self._port = None\n\n        self._command_socket = None\n        self._monitor_socket = None\n\n        self._rx_thread = None\n        self._tx_thread = None\n        self._monitor_rx_thread = None\n\n        self._rx_handler_thread = None\n        self._monitor_rx_handler_thread = None\n\n        self._main_lock = threading.RLock()\n\n        # self._robot_callbacks = RobotCallbacks() -> Not reset here, only upon UnregisterCallback\n        self._callback_queue = _CallbackQueue(self._robot_callbacks)\n        self._callback_thread = None\n\n        self._network_config = NetworkConfig()\n\n        self._robot_info = RobotInfo()\n        self._robot_rt_data = None\n        self._robot_rt_data_stable = None\n        self._robot_status = RobotStatus()\n        self._robot_safety_status = RobotSafetyStatus()\n        self._robot_psu_inputs = RobotPowerSupplyInputs()\n        self._robot_collision_status = CollisionStatus()\n        self._first_robot_status_received = False\n        self._using_legacy_json_api = False\n        self._gripper_status = GripperStatus()\n        self._external_tool_status = ExtToolStatus()\n        self._gripper_state = GripperState()\n        self._gripper_state_before_last_move = GripperState()\n        self._valve_state = ValveState()\n        self._psu_io_status = IoStatus()\n        self._io_module_status = IoStatus()\n        self._vacuum_state = VacuumState()\n        self._sig_gen_status = IoStatus()\n        self._robot_events = _RobotEvents()\n        self._reset_fw_update_status()\n\n        self._file_logger = None\n        self._monitoring_interval = None\n        self._monitoring_interval_to_restore = None\n        self._auto_connection_watchdog = False\n        self._auto_connection_watchdog_last = 0\n\n        self._reset_disconnect_attributes()\n\n        self._enable_synchronous_mode = None\n        self._disconnect_on_exception = None\n\n        self._offline_mode = None\n        self._sidecar_mode = None\n        self._monitor_mode = None\n\n        self.default_timeout = DEFAULT_WAIT_TIMEOUT\n\n        # Variables to hold joint positions and poses while waiting for timestamp.\n        self._tmp_rt_joint_pos = None\n        self._tmp_rt_cart_pos = None\n\n        self._is_sync = InterruptableEvent()\n        self._is_sync.set()\n        self._tx_sync = 0\n        self._tx_sync_pending = 0\n        self._rx_sync = 0\n\n        self._captured_trajectory = None\n\n        self._unregister_functions(remote_attributes_only=False)\n\n        self._is_initialized = True\n\n    def _reset_disconnect_attributes(self):\n        \"\"\" Reset class attributes that need to be reset following a disconnection with the robot \"\"\"\n        if not self._offline_mode:\n            self._command_rx_queue = queue.Queue()\n            self._command_tx_queue = queue.Queue()\n            self._monitor_rx_queue = queue.Queue()\n        self._rx_timestamp = 0\n        self._monitor_timeout_used = False\n        self._custom_response_events = list()\n\n        self._user_checkpoints = dict()\n        self._internal_checkpoints = dict()\n        self._internal_checkpoint_counter = MX_CHECKPOINT_ID_MAX + 1\n\n        self._clear_motion_requests = 0\n\n        self._unregister_functions(remote_attributes_only=True)\n        self._unregister_variables()\n\n    def _unregister_functions(self, remote_attributes_only: bool):\n        \"\"\"Unregister all functions that are no longer relevant\n\n        Args:\n            remote_attributes_only (_type_): True -> Unregister only attributes that were remotely created.\n                                                     (this is typically done when disconnecting from the robot and we\n                                                      must cleanup functions that the robot reported to us earlier)\n                                             False -> Unregister all functions (i.e. we're destroying)\n        \"\"\"\n        if not self._is_initialized:\n            # We're initializing, do this only when disconnecting or destroying\n            return\n\n        functions_to_unregister: list[str] = []\n        for function_name, function in self._sidecar_registered_functions.items():\n            if not remote_attributes_only or not function.locally_created:\n                functions_to_unregister.append(function_name)\n        for function_name in functions_to_unregister:\n            self._sidecar_unregister_function(function_name)\n\n    def _unregister_variables(self):\n        \"\"\" Unregister all robot variables \"\"\"\n        if not self._is_initialized:\n            # We're initializing, do this only when disconnecting or destroying\n            return\n\n        variables_to_unregister: list[str] = []\n        for name, _ in self._registered_vars_by_name.items():\n            variables_to_unregister.append(name)\n\n        for name in variables_to_unregister:\n            self._unregister_variable(name)\n\n    def _reset_fw_update_status(self):\n        self._fw_update_status = UpdateProgress()\n        self._fw_update_reboot_timestamp = 0.0  # Timestamp, non-zero while rebooting\n        self._fw_update_started: bool = False\n        self._fw_update_reboot_done: bool = False\n\n    #####################################################################################\n    # Static methods.\n    #####################################################################################\n\n    #pylint: disable=unused-argument\n    def _rx_thread_fct(self, robot_socket: socket.socket, rx_queue: queue.Queue):\n        \"\"\"Handle received data on the socket.\n\n        Parameters\n        ----------\n        robot_socket : socket\n            Socket to use for receiving data.\n\n        rx_queue : queue\n            Thread-safe queue to push complete messages onto.\n\n        logger : logger instance\n            Logger to use.\n\n        \"\"\"\n        remainder = ''\n        while True:\n            # Wait for a message from the robot.\n            try:\n                robot_socket.setblocking(True)\n                raw_responses = robot_socket.recv(1024)\n            except (ConnectionAbortedError, BrokenPipeError, OSError):\n                break\n\n            # Socket has been closed.\n            if raw_responses == b'':\n                break\n\n            responses = raw_responses.decode('ascii').split('\\0')\n\n            # Add the remainder from the previous message if necessary.\n            if remainder != '':\n                responses[0] = remainder + responses[0]\n\n            # Set the remainder as the last response (which is '' if complete).\n            remainder = responses[-1]\n\n            # Put all responses into the queue.\n            for response in responses[:-1]:\n                # #logger.debug(f'Socket Rx - Response: {response}')\n                rx_queue.put(Message.from_string(response))\n\n        if self._rx_handler_thread is not None:\n            # Socket closed for reason other than ourself calling Disconnect -> Let's print a trace\n            self.logger.warning(f'Rx thread: TCP socket with the robot has been closed')\n\n        # Notify the queue that we're disconnected\n        rx_queue.put(_TERMINATE)\n\n    def _tx_thread_fct(self, robot_socket: socket.socket, tx_queue: queue.Queue):\n        \"\"\"Handle sending data on the socket.\n\n        Parameters\n        ----------\n        robot_socket : socket\n            Socket to use for sending data.\n\n        tx_queue : queue\n            Thread-safe queue to get messages from.\n\n        logger : logger instance\n            Logger to use.\n\n        \"\"\"\n        while True:\n            # Wait for a command to be available from the queue.\n            command: str = tx_queue.get(block=True)\n\n            # Terminate thread if requested, otherwise send the command.\n            if command == _TERMINATE:\n                return\n            else:\n                self.logger.debug(f'Socket Tx - Command: {command}')\n                robot_socket.sendall((command + '\\0').encode('ascii'))\n\n    @staticmethod\n    def _connect_socket(logger: logging.Logger, address: str, port: int, socket_timeout=1.0) -> socket.socket:\n        \"\"\"Connects to an arbitrary socket.\n\n        Parameters\n        ----------\n        logger : logger instance\n            Logger to use.\n        address : string\n            Address to use.\n        port : int\n            Port number to use.\n        socket_timeout: seconds\n            Time allocated (in seconds) to connect to robot\n\n        Returns\n        -------\n        new_socket : socket object\n            Successfully-connected socket object.\n\n        \"\"\"\n        logger.debug(f'Attempting to connect to {address}:{port}')\n\n        new_socket: socket.socket = socket_connect_loop(address, port, socket_timeout)\n\n        # Set final socket timeout\n        new_socket.settimeout(socket_timeout)\n        return new_socket\n\n    def _handle_callbacks(self, polling=False):\n        \"\"\"Runs callbacks found in callback_queue.\"\"\"\n\n        is_connected = True\n        while True:\n\n            # If we are not blocking on empty, return if empty.\n            if polling and self._callback_queue.qsize() == 0:\n                return\n\n            try:\n                # Call blocking with timeout of 0.1.\n                # If polling:\n                #   we know this won't block since there is something in the queue (validated above).\n                # If not polling (i.e. we're the callback thread)\n                #   then check with short timeout and ignore the error. We do this to periodically check if the\n                #   connection was dropped, so we detect a disconnection and trigger \"on_disconnected\" callback\n                #   even in the case the app is never calling IsConnected\n                callback_name, data = self._callback_queue.get(block=True, timeout=0.1)\n            # pylint: disable=broad-exception-caught\n            except Exception:\n                # Check if still connected\n                if is_connected:\n                    is_connected = self.IsConnected()\n                    # Continue even if no more connected so we run one last loop and get the chance to call\n                    # the \"on_disconnected\" callback that we may just have pushed to the queue\n                    continue\n                else:\n                    break\n\n            if callback_name == _TERMINATE:\n                return\n\n            callback_function = self._robot_callbacks.__dict__[callback_name]\n            if callback_function is not None:\n                if data is not None:\n                    callback_function(data)\n                else:\n                    callback_function()\n\n    #####################################################################################\n    # Public methods = Pascal case is used to maintain consistency with text and c++ API.\n    #####################################################################################\n\n    # General management functions.\n\n    def RegisterCallbacks(self, callbacks: RobotCallbacks, run_callbacks_in_separate_thread: bool):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Check that callbacks are an instance of the appropriate class.\n        if not isinstance(callbacks, RobotCallbacks):\n            raise TypeError('Callbacks object is not the appropriate class.')\n\n        if self.IsConnected():\n            raise InvalidStateError('Callbacks cannot be set if already connected.')\n\n        self._callback_queue = _CallbackQueue(callbacks)\n\n        # Remember user provided callbacks. Callback thread will actually be started upon Connect.\n        self._robot_callbacks = callbacks\n        self._run_callbacks_in_separate_thread = run_callbacks_in_separate_thread\n\n    def RegisterCallback(self, callback_name: str, callback_method: Callable[[], None]):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not hasattr(self._robot_callbacks, callback_name):\n            raise ValueError(f'Unknown callback name {callback_name}')\n        setattr(self._robot_callbacks, callback_name, callback_method)\n        self._callback_queue.register(callback_name)\n\n    def UnregisterCallbacks(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        self._stop_callback_thread()\n\n        self._robot_callbacks = RobotCallbacks()\n        self._callback_queue = _CallbackQueue(self._robot_callbacks)\n        if not self.IsConnected():\n            self._run_callbacks_in_separate_thread = False\n            self._callback_thread = None\n\n    def UnregisterCallback(self, callback_name: str):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not hasattr(self._robot_callbacks, callback_name):\n            raise ValueError(f'Unknown callback name {callback_name}')\n        setattr(self._robot_callbacks, callback_name, None)\n        self._callback_queue.unregister(callback_name)\n\n    def _start_callback_thread(self):\n        if self._run_callbacks_in_separate_thread and self._callback_thread is None:\n            self._callback_thread = threading.Thread(target=self._handle_callbacks)\n            self._callback_thread.daemon = True  # Make sure thread does not prevent application from quitting\n            self._callback_thread.start()\n\n    def _stop_callback_thread(self):\n        if self._callback_thread:\n            self._callback_queue.put(_TERMINATE)\n            if self._callback_thread != threading.current_thread():\n                self._callback_thread.join(timeout=self.default_timeout)\n                self._callback_thread = None\n\n    # Robot control functions.\n\n    def _Connect(self,\n                 address: str = MX_DEFAULT_ROBOT_IP,\n                 enable_synchronous_mode: bool = False,\n                 disconnect_on_exception: bool = True,\n                 monitor_mode: bool = False,\n                 sidecar_mode: bool = False,\n                 offline_mode: bool = False,\n                 timeout: float = 1.0):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        try:\n            with self._main_lock:\n\n                if self.IsConnected():\n                    return  # Still connected -> Do nothing\n\n                # Check that the ip address is valid and set address.\n                if not isinstance(address, str):\n                    raise TypeError(f'Invalid IP address ({address}).')\n\n                self._enable_synchronous_mode = enable_synchronous_mode\n                self._disconnect_on_exception = disconnect_on_exception\n                self._offline_mode = offline_mode\n                self._sidecar_mode = sidecar_mode\n                self._monitor_mode = monitor_mode\n\n                # Make sure we start from a fresh state\n                self._reset_disconnect_attributes()\n\n                # Check if user has specified a custom port to connect to\n                addr_port = address.split(':')\n                mode_str = \"monitoring mode\" if self._monitor_mode else \"control mode\"\n                if len(addr_port) > 1:\n                    self._port = int(addr_port[1])\n                    address = addr_port[0]\n                else:\n                    self._port = MX_ROBOT_TCP_PORT_FEED if self._monitor_mode else MX_ROBOT_TCP_PORT_CONTROL\n\n                if self._fw_update_reboot_timestamp == 0:  # Don't print this trace when reconnecting during update\n                    self.logger.info(f\"Connecting to robot {address}:{self._port} ({mode_str})\")\n\n                ipaddress.ip_address(address)\n                self._address = address\n\n                # Reset robot status to default values\n                self._robot_status = RobotStatus()\n                self._robot_safety_status = RobotSafetyStatus()\n                self._robot_psu_inputs = RobotPowerSupplyInputs()\n                self._robot_collision_status = CollisionStatus()\n                self._first_robot_status_received = False\n                self._using_legacy_json_api = False\n\n                if not self._monitor_mode:\n                    self._initialize_command_socket(timeout)\n                    self._initialize_command_connection()\n                else:\n                    # Activate the monitoring timeout to detect if we're no more receiving anything from the robot\n                    self._monitor_timeout_used = True\n\n                self._robot_events.clear_all()\n\n                self._robot_events.on_deactivated.set()\n                self._robot_events.on_error_reset.set()\n\n                self._robot_events.on_safety_stop_reset.set()\n                self._robot_events.on_safety_stop_resettable.set()\n                self._robot_events.on_safety_stop_state_change.set()\n                self._set_robot_operation_mode(MxRobotOperationMode.MX_ROBOT_OPERATION_MODE_AUTO)\n                self._set_reset_ready(False)\n                self._robot_events.on_pstop2_reset.set()\n                self._robot_events.on_pstop2_resettable.set()\n                self._robot_events.on_estop_reset.set()\n                self._robot_events.on_estop_resettable.set()\n\n                self._robot_events.on_motion_resumed.set()\n                self._set_brakes_engaged(True)\n                self._set_connection_watchdog_enabled(False)\n\n                self._robot_events.on_status_updated.set()\n                self._robot_events.on_network_config_updated.set()\n                self._robot_events.on_status_gripper_updated.set()\n                self._robot_events.on_external_tool_status_updated.set()\n                self._robot_events.on_gripper_state_updated.set()\n                self._robot_events.on_valve_state_updated.set()\n                self._robot_events.on_output_state_updated.set()\n                self._robot_events.on_input_state_updated.set()\n                self._robot_events.on_vacuum_state_updated.set()\n                self._robot_events.on_holding_part.set()\n                self._robot_events.on_released_part.set()\n                self._robot_events.on_vacuum_purge_done.set()\n                self._robot_events.on_io_status_updated.set()\n\n                self._robot_events.on_joints_updated.set()\n                self._robot_events.on_pose_updated.set()\n\n            if (self._robot_info.version.is_at_least(11, 1, 5) and (self._port == MX_ROBOT_TCP_PORT_CONTROL)):\n                # Enable JSON mode automatically on this robot\n                self._send_custom_command('EnableJsonMode()',\n                                          expected_responses=None,\n                                          timeout=None,\n                                          skip_internal_check=True)\n\n            connect_to_monitoring_port = True\n            if not self._monitor_mode and self._robot_info.version.major >= 8:\n                can_query_robot_info = True\n\n                if not self._robot_info.rt_message_capable:\n                    # For these versions (8.3-), it is not possible to get robot information if in error.\n                    self._send_custom_command('GetStatusRobot',\n                                              expected_responses=[mx_st.MX_ST_GET_STATUS_ROBOT],\n                                              timeout=self.default_timeout,\n                                              skip_internal_check=True)\n                    if self._robot_status.error_status:\n                        can_query_robot_info = False\n\n                if can_query_robot_info:\n                    # Fetch the robot serial number\n                    self._send_custom_command('GetRobotSerial',\n                                              expected_responses=[mx_st.MX_ST_GET_ROBOT_SERIAL],\n                                              timeout=self.default_timeout,\n                                              skip_internal_check=True)\n\n                    # Fetch full version\n                    full_version_response = self._send_custom_command('GetFwVersionFull',\n                                                                      [mx_st.MX_ST_GET_FW_VERSION_FULL],\n                                                                      timeout=self.default_timeout,\n                                                                      skip_internal_check=True)\n                    full_version = full_version_response.data\n                    self._robot_info.version.update_version(full_version)\n\n                    # Fetch the current real-time monitoring settings\n                    if self._robot_info.rt_message_capable:\n                        self._send_custom_command('GetRealTimeMonitoring',\n                                                  expected_responses=[mx_st.MX_ST_GET_REAL_TIME_MONITORING],\n                                                  timeout=self.default_timeout,\n                                                  skip_internal_check=True)\n\n                        # Get initial monitoring interval\n                        monitoring_interval_response = self._send_custom_command(\n                            'GetMonitoringInterval',\n                            expected_responses=[mx_st.MX_ST_GET_MONITORING_INTERVAL],\n                            timeout=self.default_timeout,\n                            skip_internal_check=True)\n                        if isinstance(monitoring_interval_response, Message):\n                            self._monitoring_interval = float(f'{monitoring_interval_response.data}')\n                            self._monitoring_interval_to_restore = self._monitoring_interval\n\n                    # Check if this robot supports sending monitoring data on ctrl port (which we want to do to avoid\n                    # race conditions between the two sockets causing potential problems with this API)\n                    # Also make sure we have received a robot status event before continuing\n                    if self._robot_info.rt_on_ctrl_port_capable:\n                        connect_to_monitoring_port = False  # We won't need to connect to monitoring port\n                        if self._sidecar_mode:\n                            # In sidecar mode, the robot automatically enables ctrl port monitoring\n                            pass\n                        else:\n                            if self._robot_info.sidecar_capable:\n                                self._send_custom_command('SetDictMonitoring(1,0)',\n                                                          expected_responses=None,\n                                                          timeout=None,\n                                                          skip_internal_check=True)\n                                self._send_custom_command('SetVariablesMonitoring(1)',\n                                                          expected_responses=None,\n                                                          timeout=None,\n                                                          skip_internal_check=True)\n                            self._send_custom_command('SetCtrlPortMonitoring(1)',\n                                                      expected_responses=[mx_st.MX_ST_GET_STATUS_ROBOT],\n                                                      timeout=self.default_timeout,\n                                                      skip_internal_check=True)\n                        # Since we're going to receive monitoring messages on the control port, we'll periodically\n                        # receive events from the robot and can thus enable the \"monitor timeout\" to detect that\n                        # we're disconnected from the robot if ever we no more receive any message from it\n                        self._monitor_timeout_used = True\n                    else:\n                        self._send_custom_command('GetStatusRobot',\n                                                  expected_responses=[mx_st.MX_ST_GET_STATUS_ROBOT],\n                                                  timeout=self.default_timeout,\n                                                  skip_internal_check=True)\n\n            if connect_to_monitoring_port:\n                with self._main_lock:\n                    self._initialize_monitoring_socket(timeout)\n                    self._initialize_monitoring_connection()\n\n            # Now that we're connected, let's update _robot_info with the connected Ip address\n            self._robot_info.ip_address = address\n\n            self.logger.info(f'{self._robot_info}')  # Note: This will print \"Connected to...\"\n\n            if self._robot_info.version.major < 8:\n                self.logger.warning('Python API not supported for firmware under version 8')\n\n            self._robot_events.on_connected.set()\n            self._callback_queue.put('on_connected')\n\n            # Start callback thread if necessary\n            self._start_callback_thread()\n        except Exception as e:\n            if self._fw_update_reboot_timestamp == 0:  # Don't print this trace when reconnecting during firmware update\n                self.logger.info(f'Failed to connect: {e}')\n            self._disconnect()\n            # Uniformize the raised exception to CommunicationError (the message string may clarify what happened)\n            raise CommunicationError(e) from e\n\n    def Disconnect(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self.IsConnected():\n            if self._fw_update_reboot_timestamp == 0:  # Don't print this trace when reconnecting during firmware update\n                self.logger.info('Disconnecting from the robot.')\n            self._disconnect()\n        else:\n            self.logger.debug('Ignoring Disconnect() called on a non-connected robot.')\n\n    def _disconnect(self):\n        \"\"\"\n        Internal function to disconnect Mecademic Robot object from the Mecademic robot and cleanup internal states.\n\n        \"\"\"\n        # Don't acquire _main_lock while shutting down queues to avoid deadlock.\n        self._shut_down_queue_threads()\n\n        # Awake any blocked interruptable event\n        self._invalidate_interruptable_events(message=\"Ask to disconnect from the robot\")\n\n        with self._main_lock:\n            message = \"explicitly disconnected from the robot\"\n            self._shut_down_socket_threads()\n\n            # Invalidate checkpoints and appropriate interruptable events\n            self._invalidate_checkpoints(message, forced=True)\n            self._invalidate_interruptable_events_on_clear_motion(message)\n\n            # Reset attributes which should not persist after disconnect.\n            self._reset_disconnect_attributes()\n\n            # Finally, close sockets.\n            if self._command_socket is not None:\n                try:\n                    self._command_socket.close()\n                # pylint: disable=broad-exception-caught\n                except Exception as e:\n                    self.logger.error(f'Error closing command socket: {e}')\n                self._command_socket = None\n            if self._monitor_socket is not None:\n                try:\n                    self._monitor_socket.close()\n                # pylint: disable=broad-exception-caught\n                except Exception as e:\n                    self.logger.error(f'Error closing monitoring socket: {e}')\n                self._monitor_socket = None\n\n            self._robot_events.on_connected.clear()\n            self._robot_events.on_disconnected.set()\n            self._callback_queue.put('on_disconnected')\n\n            self._robot_events.abort_all(message=message)\n\n        # Now that we're disconnected and posted 'on_disconnected' callback we can stop the callback thread\n        self._stop_callback_thread()\n\n    def IsConnected(self) -> bool:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._robot_events.on_connected.is_set():\n            try:\n                self._check_internal_states(refresh_monitoring_mode=True)\n                return True\n            # pylint: disable=broad-exception-caught\n            except Exception:\n                if not self._fw_update_status.in_progress:\n                    self.logger.info('Connection to robot was lost.')\n                return False\n        else:\n            return False\n\n    def IsControlling(self) -> bool:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not self.IsConnected() or self._monitor_mode:\n            return False\n        return True\n\n    def IsSynchronousMode(self) -> bool:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not self.IsConnected() or not self._enable_synchronous_mode:\n            return False\n        return True\n\n    def ConnectionWatchdog(self, timeout: float, message: Optional[str] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            if message is not None and self._robot_info.version.is_at_least(11, 1):\n                # Use JSON format\n                watchdog_ags = {\n                    MX_JSON_KEY_CONNECTION_WATCHDOG_TIMEOUT: timeout,\n                    MX_JSON_KEY_CONNECTION_WATCHDOG_MESSAGE: message\n                }\n                self._send_json_command('-ConnectionWatchdog', watchdog_ags)\n            else:\n                self._send_custom_command(f\"-ConnectionWatchdog({timeout})\")\n\n    def AutoConnectionWatchdog(self, enable: bool, timeout: float = 0, message: Optional[str] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            if self._auto_connection_watchdog and not enable:\n                # Disabling watchdog, let's immediately tell robot to disable the watchdog\n                self.ConnectionWatchdog(timeout, message)\n            self._auto_connection_watchdog = enable\n\n    @disconnect_on_exception_decorator\n    def ActivateRobot(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('ActivateRobot')\n\n        if self._enable_synchronous_mode:\n            self.WaitActivated()\n\n    # pylint: disable=unused-argument\n    def _sending_ActivateRobot(self, args: list[str]):\n        \"\"\" This function updates internal states when sending ActivateRobot command to the robot \"\"\"\n        self._robot_events.on_activated.clear_abort()\n        self._robot_events.on_homed.clear_abort()\n\n    def DeactivateRobot(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('DeactivateRobot')\n\n        if self._enable_synchronous_mode:\n            self.WaitDeactivated()\n\n    @disconnect_on_exception_decorator\n    def Home(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('Home')\n\n        if self._enable_synchronous_mode:\n            self.WaitHomed()\n\n    # pylint: disable=unused-argument\n    def _sending_Home(self, args: list[str]):\n        \"\"\" This function updates internal states when sending Home command to the robot \"\"\"\n        self._robot_events.on_homed.clear_abort()\n\n    @disconnect_on_exception_decorator\n    def PauseMotion(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('PauseMotion')\n\n        if self._enable_synchronous_mode:\n            self._robot_events.on_motion_paused.wait(timeout=self.default_timeout)\n\n    @disconnect_on_exception_decorator\n    def ResumeMotion(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('ResumeMotion')\n\n        if self._enable_synchronous_mode:\n            self.WaitMotionResumed(timeout=self.default_timeout)\n\n    @disconnect_on_exception_decorator\n    def ClearMotion(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('ClearMotion')\n\n        if self._enable_synchronous_mode:\n            self.WaitMotionCleared(timeout=self.default_timeout)\n\n    # pylint: disable=unused-argument\n    def _sending_ClearMotion(self, args: list[str]):\n        \"\"\" This function updates internal states when sending ClearMotion command to the robot \"\"\"\n        # Clearing the motion queue also requires clearing checkpoints, as the robot will not send them anymore.\n        message = \"ClearMotion\"\n        # Increment the number of pending ClearMotion requests.\n        self._clear_motion_requests += 1\n        self._robot_events.on_motion_cleared.clear()\n        self._invalidate_checkpoints(message, forced=False)\n        self._invalidate_interruptable_events_on_clear_motion(message)\n\n    # Non-motion commands.\n\n    def _set_monitoring_interval_internal(self, t: float):\n        \"\"\"Sets the rate at which the monitoring port sends data.\n\n        Parameters\n        ----------\n        t : float\n            Monitoring interval duration in seconds.\n\n        \"\"\"\n        with self._main_lock:\n            self._send_command('SetMonitoringInterval', [t])\n\n    def _sending_SetMonitoringInterval(self, args: list[str]):\n        \"\"\" This function updates internal states when sending SetMonitoringInterval command to the robot \"\"\"\n        self._monitoring_interval = float(args[0])\n        self._refresh_auto_connection_watchdog(force=True)\n\n    def GetStatusGripper(self, synchronous_update: bool = False, timeout: float = None) -> GripperStatus:\n        \"\"\"Return a copy of the current gripper status.\n           LEGACY. Use GetRtExtToolStatus and GetRtGripperState instead.\n\n        Parameters\n        ----------\n        synchronous_update: boolean\n            True -> Synchronously get updated gripper status. False -> Get latest known status.\n        timeout: float, defaults to DEFAULT_WAIT_TIMEOUT\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        GripperStatus\n            Object containing the current gripper status\n\n        \"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetStatusGripper', None, self._robot_events.on_status_gripper_updated, timeout)\n\n        with self._main_lock:\n            return copy.deepcopy(self._gripper_status)\n\n    def WaitGripperMoveCompletion(self, timeout: Optional[float] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not self._robot_info.gripper_pos_ctrl_capable:\n            raise NotImplementedError(f\"Unsupported method for this firmware version\")\n\n        if timeout is not None and timeout <= 0:\n            raise ValueError(\"timeout must be None or a positive value\")\n\n        DEFAULT_START_MOVE_TIMEOUT = 0.2\n        DEFAULT_COMPLETE_MOVE_TIMEOUT = 5\n        if timeout is not None:\n            complete_move_timeout = timeout\n        else:\n            complete_move_timeout = DEFAULT_COMPLETE_MOVE_TIMEOUT\n\n        # Use a checkpoint to make sure the last gripper command has been processed\n        if not self._enable_synchronous_mode:\n            start_time = time.monotonic()\n            checkpoint = self._set_checkpoint_internal()\n            checkpoint.wait(complete_move_timeout)\n            # Update timeout left\n            complete_move_timeout -= (time.monotonic() - start_time)\n\n        start_move_timeout = DEFAULT_START_MOVE_TIMEOUT\n        if start_move_timeout > complete_move_timeout:\n            start_move_timeout = complete_move_timeout\n\n        # Detect a rising edge of either `target_pos_reached` or `holding_part` to rapidly confirm the end of move.\n        # This is needed to ensure the gripper has started moving and we're not reporting a previous state.\n        # When we have given the gripper enough time to start moving and `target_pos_reached` or `holding_part`\n        # are still true, it means that the gripper was already at target position or that an object is preventing\n        # the gripper from reaching that position, so the move completes.\n        holding_part_seen_false = not self._gripper_state_before_last_move.holding_part\n        pos_reached_seen_false = not self._gripper_state_before_last_move.target_pos_reached\n\n        current_time = time.monotonic()\n        start_time = current_time\n        timeout_time = start_time + start_move_timeout\n        waiting_move_start = True\n        while current_time < timeout_time:\n            wait_duration = timeout_time - current_time\n            self.logger.debug(f'WaitGripperMoveCompletion: Waiting for {wait_duration}s')\n            try:\n                self._robot_events.on_gripper_state_updated.wait(wait_duration)\n                with self._main_lock:\n                    gripper_state = self._gripper_state\n                    self._robot_events.on_gripper_state_updated.clear()\n                    self.logger.debug(f'WaitGripperMoveCompletion: New state is {str(gripper_state)}')\n\n                if waiting_move_start:\n                    if gripper_state.target_pos_reached:\n                        if pos_reached_seen_false:\n                            self.logger.debug(f'WaitGripperMoveCompletion: target_pos_reached')\n                            return\n                        if gripper_state.opened and not self._gripper_state_before_last_move.opened:\n                            self.logger.debug(f'WaitGripperMoveCompletion: now opened (was not)')\n                            return\n                        if gripper_state.closed and not self._gripper_state_before_last_move.closed:\n                            self.logger.debug(f'WaitGripperMoveCompletion: now closed (was not)')\n                            return\n\n                    if holding_part_seen_false and gripper_state.holding_part:\n                        self.logger.debug(f'WaitGripperMoveCompletion: holding_part')\n                        return\n\n                    if gripper_state.holding_part is False:\n                        self.logger.debug(f'WaitGripperMoveCompletion: holding_part_seen_false')\n                        holding_part_seen_false = True\n\n                    if gripper_state.target_pos_reached is False:\n                        self.logger.debug(f'WaitGripperMoveCompletion: pos_reached_seen_false')\n                        pos_reached_seen_false = True\n\n                else:\n                    if gripper_state.target_pos_reached or gripper_state.holding_part:\n                        self.logger.debug(f'WaitGripperMoveCompletion: move completed ')\n                        return\n            except TimeoutException:\n                if waiting_move_start:\n                    self.logger.debug(f'WaitGripperMoveCompletion: start_move_timeout reached')\n                    gripper_state = self._gripper_state\n                    if gripper_state.target_pos_reached or gripper_state.holding_part:\n                        # Gripper had time to start moving and the state still report that the gripper is at the target\n                        # position or holding a part. This happens when the gripper was not able to move because it is\n                        # forcing on an object.\n                        self.logger.debug(\n                            f'WaitGripperMoveCompletion: start_move_timeout reached with no change detected')\n                        return\n                    # We now give enough time for the move to complete\n                    waiting_move_start = False\n                    timeout_time = start_time + complete_move_timeout\n            current_time = time.monotonic()\n\n        if not gripper_state.target_pos_reached and not gripper_state.holding_part:\n            self.logger.warning(f'WaitGripperMoveCompletion: Timeout reached')\n            raise TimeoutException('Timeout while waiting for gripper to complete movement.')\n\n    def GripperOpen(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        self._gripper_state_before_last_move = copy.deepcopy(self._gripper_state)\n        self._send_motion_command('GripperOpen')\n\n        if self._enable_synchronous_mode and self._robot_info.gripper_pos_ctrl_capable and self.GetRtExtToolStatus(\n        ).is_gripper():\n            gripper_state = self.GetRtGripperState(synchronous_update=True)\n            if gripper_state.opened and gripper_state.target_pos_reached:\n                return\n            self.WaitGripperMoveCompletion()\n\n    def GripperClose(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        self._gripper_state_before_last_move = copy.deepcopy(self._gripper_state)\n        self._send_motion_command('GripperClose')\n\n        if self._enable_synchronous_mode and self._robot_info.gripper_pos_ctrl_capable and self.GetRtExtToolStatus(\n        ).is_gripper():\n            gripper_state = self.GetRtGripperState(synchronous_update=True)\n            if gripper_state.closed and gripper_state.target_pos_reached:\n                return\n            self.WaitGripperMoveCompletion()\n\n    def MoveGripper(self, target: Union[bool, float]):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if isinstance(target, bool):\n            if target:\n                self.GripperOpen()\n            else:\n                self.GripperClose()\n        else:\n            self._gripper_state_before_last_move = copy.deepcopy(self._gripper_state)\n            self._send_motion_command('MoveGripper', [target])\n            if self._enable_synchronous_mode:\n                rt_data = self.GetRobotRtData(synchronous_update=True)\n                if math.isclose(rt_data.rt_gripper_pos.data[0], target, abs_tol=0.1):\n                    return\n                self.WaitGripperMoveCompletion()\n\n    def SetOutputState(self, bank_id: MxIoBankId, *output_states: Union[MxDigitalIoState, int, str]):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        final_args = list(output_states)\n        final_args.insert(0, bank_id)\n        self._send_motion_command('SetOutputState', final_args)\n\n    def SetOutputState_Immediate(self, bank_id: MxIoBankId, *output_states: Union[MxDigitalIoState, int, str]):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        send_now = True\n        desired_state = list(output_states)\n        if self._enable_synchronous_mode:\n            if self.IsDesiredIoState(bank_id, False, *desired_state):\n                # Already desired state (and sync mode).\n                # In sync mode we send one command at the time so we're sure that no state change is pending. So if\n                # already in desired state we don't need to send the command. We actually DON'T want to send the command\n                # because there would be no state change reported by on_vacuum_state_updated and this would timeout\n                send_now = False\n\n        if send_now:\n            final_args = copy.deepcopy(desired_state)\n            final_args.insert(0, bank_id)\n            self._send_immediate_command('SetOutputState_Immediate', final_args,\n                                         self._robot_events.on_output_state_updated)\n            if self._enable_synchronous_mode:\n                # Wait until reached desired state (or timeout)\n                self.WaitIOState(bank_id, False, *desired_state, self.default_timeout)\n\n    def WaitForAnyCheckpoint(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if '*' not in self._internal_checkpoints:\n                self._internal_checkpoints['*'] = list()\n            event = InterruptableEvent()\n            self._internal_checkpoints['*'].append(event)\n\n        event.wait(timeout=timeout)\n\n    def WaitConnected(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_connected.wait(timeout=timeout)\n\n    def WaitDisconnected(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        start_time = time.monotonic()\n        while True:\n            try:\n                # Wait with short timeout, then check if connected again\n                if self.IsConnected():\n                    self._robot_events.on_disconnected.wait(timeout=0.1)\n                else:\n                    break\n            except TimeoutException as e:\n                if time.monotonic() - start_time > timeout:\n                    raise e\n                pass\n            except Exception as e:\n                raise e\n\n    def WaitActivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            if robot_model_is_mg2(self.GetRobotInfo().robot_model):\n                timeout = 5.0\n            else:\n                timeout = 30.0\n        self._robot_events.on_activated.wait(timeout=timeout)\n\n    def WaitDeactivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_deactivated.wait(timeout=timeout)\n\n    def WaitHomed(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            if robot_model_is_mg2(self.GetRobotInfo().robot_model):\n                timeout = 5.0\n            else:\n                timeout = 40.0\n        self._robot_events.on_homed.wait(timeout=timeout)\n\n    def WaitSimActivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_activate_sim.wait(timeout=timeout)\n\n    def WaitSimDeactivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_deactivate_sim.wait(timeout=timeout)\n\n    def WaitExtToolSimActivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_activate_ext_tool_sim.wait(timeout=timeout)\n\n    def WaitExtToolSimDeactivated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_deactivate_ext_tool_sim.wait(timeout=timeout)\n\n    # pylint: disable=unused-argument\n    def WaitIoSimEnabled(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n\n        self._robot_events.on_io_sim_enabled.wait(timeout=timeout)\n\n    # pylint: disable=unused-argument\n    def WaitIoSimDisabled(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n\n        self._robot_events.on_io_sim_disabled.wait(timeout=timeout)\n\n    def IsDesiredIoState(self, bank_id: MxIoBankId, is_input: bool, *args: Union[MxDigitalIoState, int, str]) -> bool:\n        \"\"\"See IsDesiredOutputState / IsDesiredInputState\n        \"\"\"\n        expected_states = list(args)\n        is_desired_state = True\n        with self._main_lock:\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                if is_input:\n                    curr_state = self._robot_rt_data.rt_io_module_inputs\n                else:\n                    curr_state = self._robot_rt_data.rt_io_module_outputs\n            elif bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                if is_input:\n                    curr_state = self._robot_rt_data.rt_sig_gen_inputs\n                else:\n                    curr_state = self._robot_rt_data.rt_sig_gen_outputs\n            else:\n                is_desired_state = False\n                curr_state = None\n            if curr_state is not None:\n                idx = 0\n                while idx < len(expected_states) and idx < len(curr_state.data):\n                    desired = expected_states[idx]\n                    if (desired == 0 or desired == MxDigitalIoState.MX_DIGITAL_IO_STATE_0\n                            or str(desired).lower() == 'off'):\n                        if curr_state.data[idx] != 0:\n                            is_desired_state = False\n                            break\n                    elif (desired == 1 or desired == MxDigitalIoState.MX_DIGITAL_IO_STATE_1\n                          or str(desired).lower() == 'on'):\n                        if curr_state.data[idx] != 1:\n                            is_desired_state = False\n                            break\n                    idx = idx + 1\n        return is_desired_state\n\n    def WaitIOState(self,\n                    bank_id: MxIoBankId,\n                    is_input: bool,\n                    *args: Union[MxDigitalIoState, int, str],\n                    timeout: float = None):\n        \"\"\"See WaitOutputState/WaitInputState\n        \"\"\"\n        expected_states = list(args)\n        if timeout is None:\n            timeout = self.default_timeout\n\n        start_wait = time.monotonic()\n        event = self._robot_events.on_input_state_updated if is_input else self._robot_events.on_output_state_updated\n        while not self.IsDesiredIoState(bank_id, is_input, *expected_states):\n            try:\n                event.wait(timeout=0.01)\n            except TimeoutException as e:\n                # Check final timeout\n                elapsed_ms = time.monotonic() - start_wait\n                if elapsed_ms > timeout:\n                    raise e\n            event.clear()\n\n    def WaitRecoveryMode(self, activated: bool, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if activated:\n            self._robot_events.on_activate_recovery_mode.wait(timeout=timeout)\n        else:\n            self._robot_events.on_deactivate_recovery_mode.wait(timeout=timeout)\n\n    def WaitForError(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_error.wait(timeout=timeout)\n\n    def WaitErrorReset(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_error_reset.wait(timeout=timeout)\n\n    def WaitPStop2ResetDeprecated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_pstop2_reset.wait(timeout=timeout)\n\n    def WaitPStop2ResettableDeprecated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_pstop2_resettable.wait(timeout=timeout)\n\n    def WaitEStopResetDeprecated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_estop_reset.wait(timeout=timeout)\n\n    def WaitEStopResettableDeprecated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_estop_resettable.wait(timeout=timeout)\n\n    def WaitSafetyStopReset(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_safety_stop_reset.wait(timeout=timeout)\n\n    def WaitSafetyStopResettable(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_safety_stop_resettable.wait(timeout=timeout)\n\n    def WaitSafetyStopStateChange(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n\n        self._robot_events.on_safety_stop_state_change.clear()\n        self._robot_events.on_safety_stop_state_change.wait(timeout=timeout)\n\n    def WaitMotionResumed(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_motion_resumed.wait(timeout=timeout)\n\n    def WaitMotionPaused(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_motion_paused.wait(timeout=timeout)\n\n    def WaitMotionCleared(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_motion_cleared.wait(timeout=timeout)\n\n    def WaitEndOfCycle(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._robot_events.on_end_of_cycle.is_set():\n            self._robot_events.on_end_of_cycle.clear()\n\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = 2\n        self._robot_events.on_end_of_cycle.wait(timeout=timeout)\n\n    def WaitIdle(self, timeout: float = None, wait_rt_data=False):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            # Can't wait if robot is in error (already \"idle\")\n            if self._robot_status.error_status:\n                raise InterruptException('Robot is in error')\n        checkpoint = self._set_checkpoint_internal()\n\n        start_time = time.monotonic()\n        checkpoint.wait(timeout=timeout)\n        end_time = time.monotonic()\n\n        if timeout:\n            remaining_timeout = timeout - (end_time - start_time)\n        else:\n            remaining_timeout = None\n\n        if remaining_timeout is None or remaining_timeout > 0:\n            self._robot_events.on_end_of_block.wait(timeout=remaining_timeout)\n        if wait_rt_data:\n            self.WaitEndOfCycle()\n\n    def ResetError(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('ResetError')\n\n        if self._enable_synchronous_mode:\n            self._robot_events.on_error_reset.wait(timeout=self.default_timeout)\n\n    def ResetPStop2Deprecated(self, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if self._robot_info.version.is_at_least(9, 2):\n                self._send_command('ResetPStop2')\n            else:\n                # Use legacy command name on older robots\n                self._send_command('ResetPStop')\n\n        if self._enable_synchronous_mode:\n            # Use appropriate default timeout if not specified\n            if timeout is None:\n                timeout = 2\n            self._robot_events.on_motion_resumed.wait(timeout)\n\n    def Delay(self, t: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if not self._robot_events.on_homed.is_set():\n                raise InvalidStateError('This command requires robot to be homed.')\n            self._send_command('Delay', [t])\n            if self._enable_synchronous_mode:\n                checkpoint = self._set_checkpoint_internal()\n\n        if self._enable_synchronous_mode:\n            checkpoint.wait()\n\n    def VacuumGripReleaseImmediate(self, release: bool):\n        \"\"\"See VacuumGrip_Immediate/VacuumRelease_Immediate\"\"\"\n        expected_vacuum_on = False if release else True\n        if self._enable_synchronous_mode and self._vacuum_state.vacuum_on == expected_vacuum_on:\n            # Already desired state (and sync mode).\n            # In sync mode we send one command at the time so we're sure that no state change is pending. So if already\n            # in desired state we don't need to send the command. We actually DON'T want to send the command because\n            # there would be no state change reported by on_vacuum_state_updated and this would timeout\n            return\n        else:\n            if release:\n                self._send_immediate_command('VacuumRelease_Immediate', None,\n                                             self._robot_events.on_vacuum_state_updated)\n            else:\n                self._send_immediate_command('VacuumGrip_Immediate', None, self._robot_events.on_vacuum_state_updated)\n            if self._enable_synchronous_mode:\n                # Wait until reached desired state (or timeout)\n                start_wait = time.monotonic()\n                while self._vacuum_state.vacuum_on != expected_vacuum_on:\n                    try:\n                        self._robot_events.on_vacuum_state_updated.wait(timeout=self.default_timeout)\n                    except TimeoutException as e:\n                        # Check final timeout\n                        elapsed_sec = time.monotonic() - start_wait\n                        if elapsed_sec > self.default_timeout:\n                            raise e\n                    self._robot_events.on_vacuum_state_updated.clear()\n\n    def StartProgram(self, n: int | str, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('StartProgram', [n])\n\n        if self._enable_synchronous_mode:\n            try:\n                self._robot_events.on_offline_program_started.wait(timeout=timeout)\n            except InterruptException as e:\n                raise InvalidStateError(str(e)) from e\n\n    def _sending_StartProgram(self, args: list[str]):\n        \"\"\" This function updates internal states when sending StartProgram command to the robot \"\"\"\n        self._robot_events.on_offline_program_started.clear()\n\n    def ListFiles(self, timeout: float = None) -> dict:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = OFFLINE_PROGRAM_OP_DEFAULT_TIMEOUT\n\n        with self._main_lock:\n            self._check_internal_states()\n            if self._robot_info.version.is_at_least(11, 1, 3):\n                self._send_command('ListFiles')\n            else:\n                self._send_command('ListPrograms')\n        try:\n            response = self._robot_events.on_file_op_done.wait(timeout=timeout)\n        except InterruptException as e:\n            raise InvalidStateError(str(e)) from e\n        data = response.json_data.get(MX_JSON_KEY_DATA, {})\n        if \"programs\" in data:\n            return data[\"programs\"]\n        elif \"files\" in data:\n            return data[\"files\"]\n        else:\n            return {}\n\n    def _sending_ListFiles(self, args: list[str]):\n        \"\"\" This function updates internal states when sending ListFiles command to the robot \"\"\"\n        self._robot_events.on_file_op_done.clear()\n\n    def LoadFile(self, name: str, timeout: float = None) -> dict:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = OFFLINE_PROGRAM_OP_DEFAULT_TIMEOUT\n\n        with self._main_lock:\n            self._check_internal_states()\n            self._robot_events.on_file_op_done.clear()\n\n            json_data = {\"name\": name}\n            if self._robot_info.version.is_at_least(11, 1, 3):\n                self._send_json_command('LoadFile', json_data)\n            else:\n                self._send_json_command('LoadProgram', json_data)\n        try:\n            response = self._robot_events.on_file_op_done.wait(timeout=timeout)\n        except InterruptException as e:\n            raise InvalidStateError(str(e)) from e\n        return response.json_data.get(MX_JSON_KEY_DATA, {})\n\n    def _sending_LoadFile(self, args: list[str]):\n        \"\"\" This function updates internal states when sending LoadFile command to the robot \"\"\"\n        self._robot_events.on_file_op_done.clear()\n\n    def SaveFile(self, name: str, content: str, timeout: float = None, allow_invalid=False, overwrite=False):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = OFFLINE_PROGRAM_OP_DEFAULT_TIMEOUT\n\n        with self._main_lock:\n            self._check_internal_states()\n            self._robot_events.on_file_op_done.clear()\n\n            if self._robot_info.version.is_at_least(11, 1, 3):\n                json_data = {\"name\": name, \"content\": content, \"allowInvalid\": allow_invalid, \"overwrite\": overwrite}\n                self._send_json_command('SaveFile', json_data)\n            else:\n                json_data = {\"name\": name, \"program\": content, \"allowInvalid\": allow_invalid, \"overwrite\": overwrite}\n                self._send_json_command('SaveProgram', json_data)\n\n        try:\n            self._robot_events.on_file_op_done.wait(timeout=timeout)\n        except InterruptException as e:\n            raise InvalidStateError(str(e)) from e\n\n    def _sending_SaveFile(self, args: list[str]):\n        \"\"\" This function updates internal states when sending SaveFile command to the robot \"\"\"\n        self._robot_events.on_file_op_done.clear()\n\n    def DeleteFile(self, name: str, timeout: float = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = OFFLINE_PROGRAM_OP_DEFAULT_TIMEOUT\n\n        with self._main_lock:\n            self._check_internal_states()\n            json_data = {\"name\": name}\n            if self._robot_info.version.is_at_least(11, 1, 3):\n                self._send_json_command('DeleteFile', json_data)\n            else:\n                self._send_json_command('DeleteProgram', json_data)\n\n        try:\n            self._robot_events.on_file_op_done.wait(timeout=timeout)\n        except InterruptException as e:\n            raise InvalidStateError(str(e)) from e\n\n    def _sending_DeleteFile(self, args: list[str]):\n        \"\"\" This function updates internal states when sending DeleteFile command to the robot \"\"\"\n        self._robot_events.on_file_op_done.clear()\n\n    def GetRtExtToolStatus(self,\n                           include_timestamp: bool = False,\n                           synchronous_update: bool = False,\n                           timeout: float = None) -> ExtToolStatus:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetRtExtToolStatus', None, self._robot_events.on_external_tool_status_updated,\n                                    timeout)\n\n        with self._main_lock:\n            if include_timestamp:\n                return copy.deepcopy(self._robot_rt_data.rt_external_tool_status)\n            else:\n                return copy.deepcopy(self._external_tool_status)\n\n    def GetNetworkCfg(self, synchronous_update: bool = False, timeout: float = None) -> NetworkConfig:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            # Note: Use legacy GetNetworkConfig (instead of GetNetworkCfg) for compatibility with older robot versions\n            self._send_sync_command('GetNetworkConfig', None, self._robot_events.on_network_config_updated, timeout)\n\n        with self._main_lock:\n            return copy.deepcopy(self._network_config)\n\n    def GetRtIoStatus(self,\n                      bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                      include_timestamp: bool = False,\n                      synchronous_update: bool = False,\n                      timeout: float = None) -> IoStatus:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command(f'GetRtIoStatus({bank_id})', None, self._robot_events.on_io_status_updated, timeout)\n\n        with self._main_lock:\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                if include_timestamp:\n                    return copy.deepcopy(self._robot_rt_data.rt_io_module_status)\n                else:\n                    return copy.deepcopy(self._io_module_status)\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                if include_timestamp:\n                    return copy.deepcopy(self._robot_rt_data.rt_sig_gen_status)\n                else:\n                    return copy.deepcopy(self._sig_gen_status)\n            else:\n                raise MecademicException(\"Argument Error in Command : GetRtIoStatus\")\n\n    def GetRtGripperState(self,\n                          include_timestamp: bool = False,\n                          synchronous_update: bool = False,\n                          timeout: float = None) -> GripperState:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetRtGripperState', None, self._robot_events.on_gripper_state_updated, timeout)\n\n        with self._main_lock:\n            if include_timestamp:\n                return copy.deepcopy(self._robot_rt_data.rt_gripper_state)\n            else:\n                return copy.deepcopy(self._gripper_state)\n\n    def GetRtValveState(self,\n                        include_timestamp: bool = False,\n                        synchronous_update: bool = False,\n                        timeout: float = None) -> ValveState:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetRtValveState', None, self._robot_events.on_valve_state_updated, timeout)\n\n        with self._main_lock:\n            if include_timestamp:\n                return copy.deepcopy(self._robot_rt_data.rt_valve_state)\n            else:\n                return copy.deepcopy(self._valve_state)\n\n    def GetRtOutputState(self,\n                         bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                         synchronous_update: bool = False,\n                         timeout: float = None) -> TimestampedData:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command(f'GetRtOutputState({bank_id})', None, self._robot_events.on_output_state_updated,\n                                    timeout)\n\n        with self._main_lock:\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                return copy.deepcopy(self._robot_rt_data.rt_io_module_outputs)\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                return copy.deepcopy(self._robot_rt_data.rt_sig_gen_outputs)\n            else:\n                return TimestampedData.zeros(0, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_UNAVAILABLE)\n\n    def GetRtInputState(self,\n                        bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                        synchronous_update: bool = False,\n                        timeout: float = None) -> TimestampedData:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command(f'GetRtInputState({bank_id})', None, self._robot_events.on_input_state_updated,\n                                    timeout)\n\n        with self._main_lock:\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                return copy.deepcopy(self._robot_rt_data.rt_io_module_inputs)\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                return copy.deepcopy(self._robot_rt_data.rt_sig_gen_inputs)\n            else:\n                return TimestampedData.zeros(0, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_UNAVAILABLE)\n\n    def GetRtVacuumState(self,\n                         include_timestamp: bool = False,\n                         synchronous_update: bool = False,\n                         timeout: float = None) -> VacuumState:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command(f'GetRtVacuumState()', None, self._robot_events.on_vacuum_state_updated, timeout)\n\n        with self._main_lock:\n            if include_timestamp:\n                return copy.deepcopy(self._robot_rt_data.rt_vacuum_state)\n            else:\n                return copy.deepcopy(self._vacuum_state)\n\n    def GetRtTargetJointPos(self,\n                            include_timestamp: bool = False,\n                            synchronous_update: bool = False,\n                            timeout: float = None) -> TimestampedData:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            if self._robot_info.rt_message_capable:\n                self._send_sync_command('GetRtTargetJointPos', None, self._robot_events.on_joints_updated, timeout)\n            else:\n                # This robot does not have GetRtTargetJointPos, use legacy GetJoints (but won't get timestamp)\n                self._send_sync_command('GetJoints', None, self._robot_events.on_joints_updated, timeout)\n\n            # Wait until response is received (this will throw TimeoutException if appropriate)\n            self._robot_events.on_joints_updated.wait(timeout=timeout)\n\n        with self._main_lock:\n            if include_timestamp:\n                if not self._robot_info.rt_message_capable:\n                    raise InvalidStateError('Cannot provide timestamp with current robot firmware or model.')\n                else:\n                    return copy.deepcopy(self._robot_rt_data.rt_target_joint_pos)\n\n            return copy.deepcopy(self._robot_rt_data.rt_target_joint_pos.data)\n\n    def GetRtTargetCartPos(self,\n                           include_timestamp: bool = False,\n                           synchronous_update: bool = False,\n                           timeout: float = None) -> TimestampedData:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            if self._robot_info.rt_message_capable:\n                self._send_sync_command('GetRtTargetCartPos', None, self._robot_events.on_pose_updated, timeout)\n            else:\n                # This robot does not have GetRtTargetCartPos, use legacy GetPose (but won't get timestamp)\n                self._send_sync_command('GetPose', None, self._robot_events.on_pose_updated, timeout)\n\n        with self._main_lock:\n            if include_timestamp:\n                if not self._robot_info.rt_message_capable:\n                    raise InvalidStateError('Cannot provide timestamp with current robot firmware or model.')\n                else:\n                    return copy.deepcopy(self._robot_rt_data.rt_target_cart_pos)\n\n            return copy.deepcopy(self._robot_rt_data.rt_target_cart_pos.data)\n\n    def SetMonitoringInterval(self, t: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._set_monitoring_interval_internal(t)\n            self._monitoring_interval_to_restore = t\n\n    def SetRealTimeMonitoring(self, *events: tuple):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if isinstance(events, tuple):\n                event_list = list(events)\n            else:\n                event_list = events\n            self._send_command('SetRealTimeMonitoring', event_list)\n\n    def SetRtc(self, t: int):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('SetRtc', [t])\n\n    def ActivateSim(self, mode: Optional[MxRobotSimulationMode] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if mode is None:\n                self._send_command(f'ActivateSim()')\n            else:\n                self._send_command(f'ActivateSim({int(mode)})')\n        if self._enable_synchronous_mode:\n            self._robot_events.on_activate_sim.wait(timeout=self.default_timeout)\n\n    def DeactivateSim(self):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('DeactivateSim')\n        if self._enable_synchronous_mode:\n            self._robot_events.on_deactivate_sim.wait(timeout=self.default_timeout)\n\n    def SetExtToolSim(self, sim_ext_tool_type: int = MxExtToolType.MX_EXT_TOOL_MEGP25_SHORT):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Firmware version 8.4 and older only support 1 as tool type\n        if sim_ext_tool_type != MxExtToolType.MX_EXT_TOOL_NONE and not self._robot_info.gripper_pos_ctrl_capable:\n            sim_ext_tool_type = 1\n\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('SetExtToolSim', [sim_ext_tool_type])\n\n        if self._enable_synchronous_mode:\n            if sim_ext_tool_type == MxExtToolType.MX_EXT_TOOL_NONE:\n                self.WaitExtToolSimDeactivated()\n            else:\n                self.WaitExtToolSimActivated()\n\n    def SetIoSim(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, enable: bool = True):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('SetIoSim', [bank_id, 1 if enable else 0])\n\n        if self._enable_synchronous_mode:\n            if enable:\n                self.WaitIoSimEnabled(bank_id)\n            else:\n                self.WaitIoSimDisabled(bank_id)\n\n    def SetRecoveryMode(self, activated: bool = True):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('SetRecoveryMode', f'{1 if activated else 0}')\n\n        if self._enable_synchronous_mode:\n            if activated:\n                self._robot_events.on_activate_recovery_mode.wait(timeout=self.default_timeout)\n            else:\n                self._robot_events.on_deactivate_recovery_mode.wait(timeout=self.default_timeout)\n\n    def SetTimeScaling(self, p: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command('SetTimeScaling', [p])\n\n        if self._enable_synchronous_mode:\n            self._robot_events.on_time_scaling_changed.wait(timeout=self.default_timeout)\n\n    def _sending_SetTimeScaling(self, args: list[str]):\n        \"\"\" This function updates internal states when sending SetTimeScaling command to the robot \"\"\"\n        self._robot_events.on_time_scaling_changed.clear()\n\n    def SetJointLimitsCfg(self, e: bool = True):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetJointLimitsCfg({1 if e else 0})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_JOINT_LIMITS_CFG, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetJointLimitsCfg\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetJointLimitsCfg', f\"{1 if e else 0}\")\n\n    def SetJointLimits(self, n: int, lower_limit: float, upper_limit: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetJointLimits({n},{lower_limit},{upper_limit})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_JOINT_LIMITS, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetJointLimits\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetJointLimits', f\"{n},{lower_limit},{upper_limit}\")\n\n    def SetWorkZoneCfg(self,\n                       severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR,\n                       mode: MxWorkZoneMode = MxWorkZoneMode.MX_WORK_ZONE_MODE_FCP_IN_WORK_ZONE):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetWorkZoneCfg({severity},{mode})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_WORK_ZONE_CFG, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetWorkZoneCfg\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetWorkZoneCfg', f\"{severity},{mode}\")\n\n    def SetWorkZoneLimits(self, x_min: float, y_min: float, z_min: float, x_max: float, y_max: float, z_max: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetWorkZoneLimits({x_min}, {y_min}, {z_min}, {x_max}, {y_max}, {z_max})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_WORK_ZONE_LIMITS, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetWorkZoneLimits\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetWorkZoneLimits', [x_min, y_min, z_min, x_max, y_max, z_max])\n\n    def SetCollisionCfg(self, severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetCollisionCfg({severity})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_COLLISION_CFG, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetCollisionCfg\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetCollisionCfg', f\"{severity}\")\n\n    def SetToolSphere(self, x: float, y: float, z: float, r: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetToolSphere({x}, {y}, {z}, {r})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_TOOL_SPHERE, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetToolSphere\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetToolSphere', [x, y, z, r])\n\n    def SetTorqueLimitsCfg(\n            self,\n            severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR,\n            skip_acceleration: MxTorqueLimitsMode = MxTorqueLimitsMode.MX_TORQUE_LIMITS_MODE_DELTA_WITH_EXPECTED):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if isinstance(severity, str):\n            severity_int = TORQUE_LIMIT_SEVERITIES[severity]\n        else:\n            severity_int = severity\n        skip_acceleration_int = 1 if skip_acceleration else 0\n        self._send_motion_command('SetTorqueLimitsCfg', [severity_int, skip_acceleration_int])\n\n    def SetTorqueLimits(self, *args: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        expect_count = self._robot_info.num_joints\n        if len(args) != expect_count:\n            raise ValueError(\n                f'SetTorqueLimits: Incorrect number of joints sent {len(args)}, command. expecting: {expect_count}.')\n\n        self._send_motion_command('SetTorqueLimits', args)\n\n    def SetPStop2Cfg(self, severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_CLEAR_MOTION):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetPStop2Cfg({severity})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_PSTOP2_CFG, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetPStop2Cfg\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetPStop2Cfg', f\"{severity}\")\n\n    def SetSimModeCfg(self, default_sim_mode=MxRobotSimulationMode.MX_SIM_MODE_REAL_TIME):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode:\n            response_event = self._send_custom_command(\n                f'SetSimModeCfg({default_sim_mode})',\n                expected_responses=[MxRobotStatusCode.MX_ST_SET_SIM_MODE_CFG, MxRobotStatusCode.MX_ST_CMD_FAILED])\n            if response_event.wait(timeout=DEFAULT_WAIT_TIMEOUT).id == MxRobotStatusCode.MX_ST_CMD_FAILED:\n                raise MecademicException(\"Argument Error in Command : SetSimModeCfg\")\n        else:\n            with self._main_lock:\n                self._check_internal_states()\n                self._send_command('SetSimModeCfg', f\"{default_sim_mode}\")\n\n    def SetPayload(self, mass: float, x: float, y: float, z: float):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        self._send_motion_command('SetPayload', [mass, x, y, z])\n\n    def ActivateBrakes(self, activated: bool = True):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            if activated:\n                self._send_command('BrakesOn')\n            else:\n                self._send_command('BrakesOff')\n\n        if self._enable_synchronous_mode:\n            if activated:\n                self._robot_events.on_brakes_activated.wait(timeout=self.default_timeout)\n            else:\n                self._robot_events.on_brakes_deactivated.wait(timeout=self.default_timeout)\n\n    def GetRobotInfo(self) -> RobotInfo:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            return copy.deepcopy(self._robot_info)\n\n    def GetRobotRtData(self, synchronous_update: bool = False, timeout: float = None) -> RobotRtData:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if synchronous_update:\n            self.WaitEndOfCycle(timeout)\n\n        with self._main_lock:\n            return copy.deepcopy(self._robot_rt_data_stable)\n\n    def GetStatusRobot(self, synchronous_update: bool = False, timeout: float = None) -> RobotStatus:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            if self._using_legacy_json_api:\n                with self._main_lock:\n                    self._send_command('GetMotionStatus')\n            self._send_sync_command('GetStatusRobot', None, self._robot_events.on_status_updated, timeout)\n\n        with self._main_lock:\n            return copy.deepcopy(self._robot_status)\n\n    def GetSafetyStatus(self, synchronous_update: bool = False, timeout: float = None) -> RobotSafetyStatus:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetStatusRobot', None, self._robot_events.on_status_updated, timeout)\n\n        with self._main_lock:\n            return copy.deepcopy(self._robot_safety_status)\n\n    def GetSidecarStatus(self,\n                         idx: Optional[int] = None,\n                         synchronous_update: bool = False,\n                         timeout: float = None) -> Optional[RobotSidecarStatus]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            # Not yet implemented, we receive that on monitoring port only for now\n            #self._send_sync_command('GetSidecarStatus', None, self._robot_events.on_status_updated, timeout)\n            pass\n\n        with self._main_lock:\n            if idx is None:\n                # No specific index requested -> Return embedded sidecar instance, else the first instance.\n                for sidecar_status in self._sidecar_status:\n                    if sidecar_status.embedded:\n                        return copy.deepcopy(sidecar_status)\n                if len(self._sidecar_status) > 0:\n                    return copy.deepcopy(self._sidecar_status[0])\n            elif idx < len(self._sidecar_status):\n                return copy.deepcopy(self._sidecar_status[idx])\n\n            return None\n\n    def GetPowerSupplyInputs(self, synchronous_update: bool = False, timeout: float = None) -> RobotPowerSupplyInputs:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        if synchronous_update:\n            self._send_sync_command('GetStatusRobot', None, self._robot_events.on_status_updated, timeout)\n\n        with self._main_lock:\n            return copy.deepcopy(self._robot_psu_inputs)\n\n    def GetCollisionStatus(self, timeout: float = None) -> CollisionStatus:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n\n        with self._main_lock:\n            return copy.deepcopy(self._robot_collision_status)\n\n    def GetGripperRange(self, timeout: float = None) -> Tuple[float, float]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n\n        response = self._send_custom_command('GetGripperRange',\n                                             expected_responses=[MxRobotStatusCode.MX_ST_GET_GRIPPER_RANGE],\n                                             timeout=self.default_timeout)\n        if isinstance(response, Message):\n            positions = string_to_numbers(response.data)\n            assert len(positions) == 2\n            return positions[0], positions[1]\n        return 0, 0\n\n    def LogTrace(self, trace: str, level: Optional[int] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        self._log_trace_common(trace, level)\n\n    def _log_trace_common(self,\n                          trace: str,\n                          level: Optional[int] = None,\n                          trace_id=MxUserTrace.MX_USER_TRACE_USER_LOG_TRACE):\n        \"\"\" Common to LogTrace and other similar functions \"\"\"\n        # Remove any \" in the provided string\n        trace = trace.replace('\"', \"\")\n        if level is not None:\n            self.logger.log(level, f'{trace}\\033[39m')\n        if self.IsConnected():\n            if self._robot_info.version.is_at_least(9, 2):\n                if trace_id == MxUserTrace.MX_USER_TRACE_USER_LOG_TRACE:\n                    # Plain log trace\n                    self._send_custom_command(f'-LogTrace(\"{trace}\")')\n                else:\n                    # Use JSON format\n                    log_args = {MX_JSON_KEY_USER_LOG_TRACE_STR: trace, MX_JSON_KEY_USER_LOG_TRACE_ID: trace_id}\n                    if level == logging.ERROR:\n                        log_args[MX_JSON_KEY_USER_LOG_TRACE_LVL] = -2\n                    self._send_json_command('-LogTrace', log_args)\n            else:\n                self._send_custom_command(f'LogTrace(\"{trace}\")')\n\n    def StartLogging(self,\n                     monitoringInterval: float,\n                     file_name: str = None,\n                     file_path: str = None,\n                     fields: list = None,\n                     record_time: bool = True):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._file_logger is not None:\n            raise InvalidStateError('Another file logging operation is in progress.')\n\n        self._set_monitoring_interval_internal(monitoringInterval)\n        if self._robot_info.rt_message_capable:\n            if fields is None:\n                self.SetRealTimeMonitoring('all')\n            else:\n                self.SetRealTimeMonitoring(*fields)\n\n            # Use a synchronous \"GetRealTimeMonitoring\" to ensure that we've started receiving data for all the\n            # requested real-time monitoring fields we just enabled\n            self._send_custom_command('GetRealTimeMonitoring',\n                                      expected_responses=[MxRobotStatusCode.MX_ST_GET_REAL_TIME_MONITORING],\n                                      timeout=self.default_timeout,\n                                      skip_internal_check=True)\n            if not self._robot_info.rt_on_ctrl_port_capable:\n                # Older version -> can't be sure that monitoring and control port are in sync, let's wait few\n                self.WaitEndOfCycle()\n                time.sleep(0.01)\n                self.WaitEndOfCycle()\n\n        # pylint: disable=protected-access\n        self._file_logger = mx_traj._RobotTrajectoryLogger(self._robot_info,\n                                                           self._robot_rt_data,\n                                                           fields,\n                                                           file_name=file_name,\n                                                           file_path=file_path,\n                                                           record_time=record_time,\n                                                           monitoring_interval=monitoringInterval)\n\n    def EndLogging(self, keep_captured_trajectory: bool = False) -> str:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._file_logger is None:\n            raise InvalidStateError('No existing logger to stop.')\n\n        # Deactivate logging to avoid logging the following SetMonitoringInterval\n        self._file_logger.stop_logging_commands()\n\n        if self._robot_info.rt_message_capable:\n            if self._monitoring_interval_to_restore != self._monitoring_interval:\n                # Restore default slower monitoring interval\n                self._set_monitoring_interval_internal(self._monitoring_interval_to_restore)\n\n            # Send a synchronous command to ensure we've received all monitoring data for this test\n            self._send_custom_command('GetRealTimeMonitoring',\n                                      expected_responses=[MxRobotStatusCode.MX_ST_GET_REAL_TIME_MONITORING],\n                                      timeout=self.default_timeout,\n                                      skip_internal_check=True)\n\n        if keep_captured_trajectory:\n            self._captured_trajectory = self._file_logger.robot_trajectories\n\n        file_name = self._file_logger.end_log()\n        self._file_logger = None\n\n        return file_name\n\n    def GetCapturedTrajectory(self) -> RobotTrajectories:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        return self._captured_trajectory\n\n    def UpdateRobot(self, firmware: Union[str, pathlib.Path], timeout: float = _UPDATE_TIMEOUT):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if not self.IsConnected():\n            raise InvalidStateError('Not connected to the robot. Please call \"Connect\" before calling \"UpdateRobot\".')\n        try:\n            self._update_robot(firmware, timeout)\n        except Exception as e:\n            raise e\n        finally:\n            self._reset_fw_update_status()\n\n    def CreateVariable(self,\n                       name: str,\n                       value: any,\n                       cyclic_id: Optional[int] = None,\n                       override: bool = False,\n                       timeout: float = None) -> bool:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode and timeout is None:\n            timeout = self.default_timeout\n\n        expected_responses: list[MxRobotStatusCode] = None\n        if timeout is not None:\n            expected_responses = [MxRobotStatusCode.MX_ST_CREATE_VARIABLE, MxRobotStatusCode.MX_ST_CREATE_VARIABLE_ERR]\n\n        # Create the variable on the robot\n        json_data: dict = {\n            MX_JSON_KEY_VAR_NAME: name,\n            MX_JSON_KEY_VAR_VAL: value,\n            MX_JSON_KEY_VAR_CYCLIC_ID: cyclic_id,\n            MX_JSON_KEY_VAR_OVERRIDE: override\n        }\n        response = self._send_json_command(command='CreateVariable',\n                                           json_data=json_data,\n                                           expected_responses=expected_responses,\n                                           timeout=timeout)\n        if expected_responses is not None:\n            if response.id == MxRobotStatusCode.MX_ST_CREATE_VARIABLE_ERR:\n                raise ArgErrorException(f'Robot refused CreateVariable: {response.data}')\n\n    def DeleteVariable(self, name: str, timeout: Optional[float] = None) -> Optional[rsc.RegisteredVariable]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        if self._enable_synchronous_mode and timeout is None:\n            timeout = self.default_timeout\n\n        expected_responses: list[MxRobotStatusCode] = None\n        if timeout is not None:\n            expected_responses = [MxRobotStatusCode.MX_ST_DELETE_VARIABLE, MxRobotStatusCode.MX_ST_DELETE_VARIABLE_ERR]\n\n        # Create the variable on the robot\n        json_data: dict = {MX_JSON_KEY_VAR_NAME: name}\n        response = self._send_json_command(command='DeleteVariable',\n                                           json_data=json_data,\n                                           expected_responses=expected_responses,\n                                           timeout=timeout)\n        if expected_responses is not None:\n            if response.id == MxRobotStatusCode.MX_ST_DELETE_VARIABLE_ERR:\n                raise ArgErrorException(f'Robot refused DeleteVariable: {response.data}')\n\n    def SetVariable(self, name: str, value: any, timeout: Optional[float] = None):\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        # Make sure to get the nested value if object is type RegisteredVariable\n        if isinstance(value, rsc.RegisteredVariable):\n            value = value.get_value()\n\n        if self._enable_synchronous_mode and timeout is None:\n            timeout = self.default_timeout\n\n        expected_responses: list[MxRobotStatusCode] = None\n        if timeout is not None:\n            expected_responses = [MxRobotStatusCode.MX_ST_SET_VARIABLE, MxRobotStatusCode.MX_ST_SET_VARIABLE_ERR]\n\n        # Set the variable on the robot\n        json_data: dict = {\n            MX_JSON_KEY_VAR_NAME: name,\n            MX_JSON_KEY_VAR_VAL: value,\n        }\n        response = self._send_json_command('SetVariable',\n                                           json_data,\n                                           expected_responses=expected_responses,\n                                           timeout=timeout)\n        if expected_responses is not None:\n            if response.id == mx_st.MX_ST_SET_VARIABLE_ERR:\n                raise ArgErrorException(response.data)\n\n    def GetVariable(self, name: str) -> Optional[rsc.RegisteredVariable]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        return self.vars.get(name)\n\n    def GetVariableByCyclicId(self, cyclic_id: int) -> Optional[rsc.RegisteredVariable]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        fct_or_var = self._registered_cyclic_id.get(cyclic_id, None)\n        if isinstance(fct_or_var, rsc.RegisteredVariable):\n            return fct_or_var\n        return None\n\n    def ListVariables(self) -> list[str]:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        return list(self._registered_vars_by_name.keys())\n\n    #####################################################################################\n    # Private methods.\n    #####################################################################################\n\n    def _update_robot(self, firmware: Union[str, pathlib.Path], timeout: float = _UPDATE_TIMEOUT):\n        \"\"\"See documentation of UpdateRobot in robot.py\"\"\"\n\n        if isinstance(firmware, pathlib.Path):\n            firmware_file: pathlib.Path = firmware\n        elif isinstance(firmware, str):\n            firmware_file = pathlib.Path(firmware)\n        else:\n            raise ArgumentError(None,\n                                f'Unsupported firmware type. received: {type(firmware)}, expecting pathlib or str')\n\n        firmware_file_version = RobotVersion(firmware_file.name)\n\n        address = self._address\n        address_port = f'{address}:{self._port}'\n\n        # Making sure we can send command to robot\n        if not self.IsConnected():\n            self._Connect(address=address)\n        elif self._monitor_mode:\n            self.logger.info(f'Connected to robot in monitoring mode only, attempting connection in command mode'\n                             'to deactivate robot')\n            self._Connect(address=address)\n\n        # Make sure that the robot is not in EStop\n        if robot_model_is_meca500(\n                self.GetRobotInfo().robot_model) and self.GetSafetyStatus(synchronous_update=True).estop_state:\n            raise MecademicException(\n                f'Firmware update failed: Robot is in ESTOP. Please clear the ESTOP condition before updating.')\n\n        # Check if we must use legacy mode\n        use_legacy_update = not self.GetRobotInfo().version.is_at_least(9, 3, 0)\n\n        # Make sure that the robot is deactivated\n        if self.GetStatusRobot().activation_state:\n            self.logger.info(f'Robot is activated, will attempt to deactivate before updating firmware')\n            self.DeactivateRobot()\n            self.WaitDeactivated()\n        if self._enable_synchronous_mode is None:\n            current_synchronous_mode = False\n        else:\n            current_synchronous_mode = self._enable_synchronous_mode\n\n        initial_disconnect_on_exception = self._disconnect_on_exception\n        self.Disconnect()\n\n        if not use_legacy_update:\n            # Reconnect to the robot using the JSON API\n            self._Connect(address=f'{address}:{MX_ROBOT_TCP_PORT_CONTROL_JSON}')\n\n        self.logger.info(f\"Installing firmware: {firmware_file.resolve()}\")\n\n        with open(str(firmware_file), 'rb') as firmware_stream:\n            firmware_data = firmware_stream.read()\n            firmware_data_size = str(len(firmware_data))\n\n        headers = {\n            'Connection': 'keep-alive',\n            'Content-type': 'application/x-gzip',\n            'Content-Length': firmware_data_size\n        }\n\n        if use_legacy_update:\n            self.logger.info(f\"Uploading firmware (legacy mode)...\")\n            robot_url = f\"http://{address}/\"\n        else:\n            self.logger.info(f\"Uploading firmware...\")\n            robot_url = f\"http://{address}/fw-update/{firmware_file.name}\"\n\n        request_post = requests.post(robot_url, data=firmware_data, headers=headers, timeout=60.0)\n        try:\n            request_post.raise_for_status()\n        except Exception as e:\n            self.logger.error(f\"Upgrade post request error: {e}\")\n            raise\n\n        if not request_post.ok:\n            error_message = f\"Firmware upload request failed\"\n            raise RuntimeError(error_message)\n\n        self.logger.info(f\"Starting the firmware update...\")\n\n        if not use_legacy_update:\n            # Send the 'StartFwUpdate' command\n            self._fw_update_status.in_progress = True  # Set once here, but the will be updated from robot update status\n            self._send_custom_command(f'StartFwUpdate({firmware_file.name})')\n\n        # Clear the previous update status (we'll now receive new update status)\n        self._reset_fw_update_status()\n\n        # Follow update status\n        start_time = time.monotonic()\n        while True:\n            if use_legacy_update:\n                self._check_update_progress_legacy(robot_url)\n            else:\n                self._check_update_progress(address)\n\n            # Check if complete, failed or timeout\n            if self._fw_update_status.error:\n                raise MecademicException(f'Firmware update failed: {self._fw_update_status.error_msg}')\n            if self._fw_update_status.complete:\n                self.logger.info(f\"Firmware update done\")\n                break\n            if time.monotonic() > start_time + timeout:\n                error_message = f\"Timeout while waiting for update done response, after {timeout} seconds\"\n                raise TimeoutError(error_message)\n\n        if use_legacy_update:\n            # need to wait to make sure the robot shutdown before attempting to ping it.\n            time.sleep(15)\n            # Try to ping the robot until it's responding (or until default timeout)\n            ping_robot(address)\n            # Now that robot responds to ping, wait until it accepts new connections\n            self._Connect(address_port,\n                          timeout=60,\n                          enable_synchronous_mode=current_synchronous_mode,\n                          disconnect_on_exception=initial_disconnect_on_exception)\n        else:\n            end_time = time.monotonic() + 30\n            while True:\n                if time.monotonic() > end_time:\n                    raise TimeoutError('Timeout while attempting to reconnect in control mode')\n                try:\n                    # Reconnect in control mode\n                    self.Disconnect()\n                    if self._fw_update_status.complete and not self._fw_update_reboot_done:\n                        # A firmware update without a reboot is reserved for special cases (Mecademic internal use).\n                        # In these cases, let's wait a bit before reconnecting to the robot\n                        self.logger.info(f\"Waiting before reconnecting to robot...\")\n                        time.sleep(11)\n\n                    # (shorter timeout here, we know we're already connected so it should not be long)\n                    self._Connect(address_port,\n                                  timeout=10,\n                                  enable_synchronous_mode=current_synchronous_mode,\n                                  disconnect_on_exception=initial_disconnect_on_exception)\n                    break\n                except Exception as e:\n                    error_message = str(e)\n                    if 'id=3002,' in error_message:\n                        time.sleep(1)\n                        continue\n                    raise\n\n        if self.GetRobotInfo().version.is_at_least(8.0):\n            current_version = self.GetRobotInfo().version.get_str(build=True, extra=False)\n            expected_version = firmware_file_version.full_version\n        else:\n            current_version = self.GetRobotInfo().version\n            expected_version = firmware_file_version.short_version\n\n        if str(current_version) not in expected_version:\n            error_msg = (f\"Fail to install robot properly. current version {current_version}, \"\n                         f\"expecting: {expected_version}\")\n            self.logger.error(error_msg)\n            raise AssertionError(error_msg)\n\n        robot_status = self.GetStatusRobot(synchronous_update=True)\n        if robot_status.error_status:\n            error_msg = f\"Robot is in error on version {current_version}\"\n            self.logger.error(error_msg)\n            raise InvalidStateError(error_msg)\n\n        self.logger.info(f\"Installation of {current_version} successfully completed\")\n\n    def _normalize_cart_cmd_args(self, alpha: float = None, beta: float = None, gamma: float = None) -> list[float]:\n        \"\"\"Normalize alpha, beta and gamma arguments for Cartesian commands which accept alpha/beta\n        arguments to be omitted\"\"\"\n        if self.GetRobotInfo().num_joints == 6:\n            if alpha is None or beta is None or gamma is None:\n                raise ValueError('Missing argument (on this robot Cartesian positions require 6 values)')\n            else:\n                return [alpha, beta, gamma]\n        else:\n            # Only 2 valid ways of passing Cartesian arguments on 4 axes robots: Pass all, or pass only gamma\n            if alpha is not None and beta is not None and gamma is not None:\n                # Fine, all were passed\n                return [alpha, beta, gamma]\n            elif alpha is not None and beta is None and gamma is None:\n                # Only alpha was passed, probably by positional argument, assume it's the \"gamma\" value\n                return [0, 0, alpha]\n            elif alpha is None and beta is None and gamma is not None:\n                # Only gamma was passed, assume 0 for the others\n                return [0, 0, gamma]\n\n            raise ValueError('Wrong number of argument (on this robot Cartesian positions require 4 values)')\n\n    def _normalize_conf_cmd_args(self, shoulder: int = None, elbow: int = None, wrist: int = None) -> list[int]:\n        \"\"\"Normalize shoulder, elbow and wrist \"conf\" arguments for commands which accept to omit shoulder and\n           wrist (for 4 axes robots which only have elbow conf)\"\"\"\n        if self.GetRobotInfo().num_joints == 6:\n            if shoulder is None or elbow is None or wrist is None:\n                raise ValueError('Missing argument (on this robot configuration requires 3 values)')\n            else:\n                return [shoulder, elbow, wrist]\n        else:\n            # Only 2 valid ways of passing Cartesian arguments on 4 axes robots: Pass all, or pass only elbow\n            if shoulder is not None and elbow is not None and wrist is not None:\n                # Fine, all were passed\n                return [shoulder, elbow, wrist]\n            elif shoulder is not None and elbow is None and wrist is None:\n                # Only shoulder was passed, probably by positional argument, assume it's the \"elbow\" value\n                return [0, shoulder, 0]\n            elif shoulder is None and elbow is not None and wrist is None:\n                # Only elbow was passed, assume 0 for the others\n                return [0, elbow, 0]\n\n            raise ValueError('Wrong number of arguments (on this robot configuration require 1 value)')\n\n    def _get_reboot_duration(self):\n        \"\"\" Get the average expected reboot duration for current robot model \"\"\"\n        if self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCS500_R1:\n            return MX_FW_UPDATE_REBOOT_DURATION_SEC_MCS500\n        elif self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCA250_R1:\n            return MX_FW_UPDATE_REBOOT_DURATION_SEC_MCA250\n        elif self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCA1000_R1:\n            return MX_FW_UPDATE_REBOOT_DURATION_SEC_MCA1000\n        else:\n            return MX_FW_UPDATE_REBOOT_DURATION_SEC_MECA500\n\n    def _get_fw_update_duration(self):\n        \"\"\" Get the average expected firmware update duration for current robot model \"\"\"\n        if self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCS500_R1:\n            return MX_FW_UPDATE_AVG_DURATION_SEC_MCS500\n        elif self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCA250_R1:\n            return MX_FW_UPDATE_AVG_DURATION_SEC_MCA250\n        elif self.GetRobotInfo().robot_model == MxRobotModel.MX_ROBOT_MODEL_MCA1000_R1:\n            return MX_FW_UPDATE_AVG_DURATION_SEC_MCA1000\n        else:\n            return MX_FW_UPDATE_AVG_DURATION_SEC_MECA500\n\n    def _check_update_progress(self, address: str):\n        \"\"\"\n        Check progress of firmware update (new implementation using JSON API).\n\n        Parameters\n        ----------\n        address: string\n            Robot IP address/port\n        \"\"\"\n        time.sleep(0.1)\n        # Update status is updated in background by _handle_fw_update_progress until robot reboots at the end of the\n        # update, at which time the code below will periodically print progress for convenience\n        if not self.IsConnected():\n            # During update, we'll get disconnected. Try reconnecting in monitoring mode to follow update progress\n            try:\n                if self._monitor_mode and self._fw_update_status.in_progress and self._fw_update_reboot_timestamp == 0:\n                    # Got disconnected -> Consider we're awaiting for the robot to reboot\n                    self._fw_update_reboot_timestamp = time.monotonic()\n                self._Connect(address=f'{address}:{MX_ROBOT_TCP_PORT_FEED_JSON}', monitor_mode=True, timeout=1.0)\n                # Reconnected in monitoring mode, therefore update is started\n                self._fw_update_started = True\n            # pylint: disable=broad-exception-caught\n            except Exception:\n                # In case we're updating to an older package (<9.3) we won't be able to connect to JSON port.\n                # So let's try to connect to standard port.\n                try:\n                    self._Connect(address=f'{address}', monitor_mode=True, timeout=0.1)\n                    # Successfully connected to legacy port. Validate that we're connected to older version\n                    if self.GetRobotInfo().version.is_at_least(9, 3):\n                        # Recent version, we should be able to connect to JSON port,\n                        # so let's close here and retry JSON above (next loop)\n                        self.Disconnect()\n                    else:\n                        # Older version. No JSON port exists so let's assume that the update is complete\n                        self._fw_update_status.complete = True\n                # pylint: disable=broad-exception-caught\n                except Exception:\n                    # Robot is probably still rebooting\n                    # Update the update percentage based on estimated reboot time\n                    if self._fw_update_reboot_timestamp == 0:\n                        reboot_pct = 0\n                    else:\n                        reboot_elapsed_ms = 1000 * (time.monotonic() - self._fw_update_reboot_timestamp)\n                        reboot_pct = 100 * (reboot_elapsed_ms / (1000 * self._get_reboot_duration()))\n                        if reboot_pct > 100:\n                            reboot_pct = 100\n\n                    # Print status while awaiting for robot to reboot\n                    # pylint: disable=protected-access\n                    if time.monotonic() - self._fw_update_status._last_print_timestamp > 5.0:\n                        self._print_fw_update_status(int(reboot_pct))\n\n    def _check_update_progress_legacy(self, robot_url: str):\n        \"\"\"\n        Check progress of firmware update (legacy version with old web portal).\n\n        Parameters\n        ----------\n        robot_url: string\n            Robot URL\n\n        \"\"\"\n        time.sleep(2)\n        self._fw_update_status.complete = False\n        request_get = requests.get(robot_url, 'update', timeout=10)\n        try:\n            request_get.raise_for_status()\n        except Exception as e:\n            self.logger.error(f'Upgrade get request error: {e}')\n            raise e\n\n        # get only correct answer (http code 200)\n        if request_get.status_code == 200:\n            request_response = request_get.text\n        else:\n            request_response = None\n        # while the json file is note created, get function will return 0\n        if request_response is None or request_response == '0':\n            return\n\n        try:\n            request_answer = json.loads(request_response)\n        # pylint: disable=broad-exception-caught\n        except Exception as e:\n            self.logger.info(f'Error retrieving json from request_response: {e}')\n            return\n\n        if not request_answer:\n            self.logger.info(f'Answer is empty')\n            return\n\n        status_code = -1\n        status_msg = \"\"\n        if request_answer['STATUS']:\n            status_code = int(request_answer['STATUS']['Code'])\n            status_msg = request_answer['STATUS']['MSG']\n\n        if status_code in [0, 1]:\n            keys = sorted(request_answer['LOG'].keys())\n            if keys:\n                previous_progress = self._fw_update_status.progress_str\n                self._fw_update_status.progress_str = request_answer['LOG'][keys[-1]]\n                new_progress = self._fw_update_status.progress_str.replace(previous_progress, '')\n                if ':' in new_progress:\n                    self.logger.info(new_progress)\n                elif '100%' in new_progress:\n                    self.logger.info(new_progress)\n                else:\n                    self.logger.debug(new_progress)\n            if status_code == 0:\n                self.logger.info(f'status_msg {status_msg}')\n                self._fw_update_status.complete = True\n                return\n        else:\n            error_message = f'error while updating: {status_msg}'\n            self.logger.error(error_message)\n            raise RuntimeError(error_message)\n\n    def _check_monitor_threads(self):\n        \"\"\"Check that the threads which handle robot monitor messages are alive.\n\n        Attempt to disconnect from the robot if not.\n\n        \"\"\"\n        if self._robot_info.rt_on_ctrl_port_capable:\n            # We're not using monitoring port. No need to check here.\n            return\n\n        if not (self._monitor_rx_handler_thread and self._monitor_rx_handler_thread.is_alive()):\n            raise InvalidStateError('Monitor response handler thread has unexpectedly terminated.')\n\n        if self._offline_mode:  # Do not check rx threads in offline mode.\n            return\n\n        if not (self._monitor_rx_thread and self._monitor_rx_thread.is_alive()):\n            raise InvalidStateError('Monitor rx thread has unexpectedly terminated.')\n\n    def _check_command_threads(self):\n        \"\"\"Check that the threads which handle robot command messages are alive.\n\n        Attempt to disconnect from the robot if not.\n\n        \"\"\"\n\n        if not (self._rx_handler_thread and self._rx_handler_thread.is_alive()):\n            raise DisconnectError('Socket was closed')\n\n        if self._offline_mode:  # Do not check rx threads in offline mode.\n            return\n\n        if not (self._rx_thread and self._rx_thread.is_alive()):\n            raise DisconnectError('Socket was closed')\n\n        if not (self._tx_thread and self._tx_thread.is_alive()):\n            raise DisconnectError('Socket was closed')\n\n    def _check_internal_states(self, refresh_monitoring_mode=False):\n        \"\"\"Check that the threads which handle robot messages are alive.\n\n        Attempt to disconnect from the robot if not.\n\n        Parameters\n        ----------\n        refresh_monitoring_mode : boolean\n            Refresh internal states even in monitoring mode when True, raise an exception otherwise.\n        \"\"\"\n        try:\n            if self._monitor_mode:\n                if not refresh_monitoring_mode:\n                    raise InvalidStateError('Cannot send command while in monitoring mode.')\n            else:\n                # Check if the commands handling thread is alive (unless it's ourself)\n                thread_ident = threading.get_ident()\n                rx_thread_ident = self._rx_thread.ident if self._rx_thread is not None else None\n                cmd_thread_ident = (self._rx_handler_thread.ident if self._rx_handler_thread is not None else None)\n                if (thread_ident != rx_thread_ident and thread_ident != cmd_thread_ident):\n                    self._check_command_threads()\n\n            self._check_monitor_threads()\n\n            # Consider we're disconnected if we've not recently received a message from the robot\n            if self._monitor_timeout_used and self._rx_timestamp != 0:\n                elapsedMs = 1000 * (time.monotonic() - self._rx_timestamp)\n                if elapsedMs > _MONITORING_TIMEOUT_MS:\n                    raise TimeoutError(f'Timeout: No message received from the robot in the last {elapsedMs}ms. '\n                                       f'Assuming we are disconnected from the robot.')\n        except Exception:\n            # An error was detected while validating internal states. Disconnect from robot.\n            self._disconnect()\n            raise\n\n    def _split_command_args(self, command: str, args: Union[str, list, tuple] = None) -> list[str, Optional[list[str]]]:\n        \"\"\"In the case the arguments are passed in the command argument, this function will split the command name\n           and arguments.\n\n        Parameters\n        ----------\n        command : str\n            String that contains the command name and possibly the arguments too\n        args : Union[str, list, tuple], optional\n            Arguments for the command, as a string, a list or a tuple, by default None\n\n        Returns\n        -------\n        list[str, Optional[list[str]]]\n            Command name (without arguments), arguments (normalized as list of strings)\n        \"\"\"\n        if args is None:\n            # Split command from args by searching for opening parenthesis\n            split_result = command.split('(', 1)\n            if len(split_result) == 2:\n                # Strip command name (just in case there were spaces around it)\n                command = split_result[0]\n                # Remove trailing parenthesis from arguments\n                args = split_result[1].rstrip(\")\")\n\n        # Normalize arguments as a list of strings\n        args_string: Optional[list[str]] = None\n        if args is not None:\n            if isinstance(args, tuple):\n                args = list(args)\n            elif isinstance(args, list):\n                pass\n            else:\n                args = [args]\n            args_string: list[str] = []\n            for arg in args:\n                if isinstance(arg, IntEnum):\n                    args_string.append(str(arg.value))\n                else:\n                    args_string.append(str(arg))\n\n        # Strip command name (just in case there were spaces around it)\n        command = command.strip()\n        return [command, args_string]\n\n    def _send_json_command(self,\n                           command: str,\n                           json_data: dict,\n                           meta_data: Optional[dict] = None,\n                           expected_responses: list[MxRobotStatusCode] = None,\n                           timeout: Optional[float] = None) -> Optional[Message]:\n        \"\"\"Send a JSON command to the robot\n\n        Args:\n            command (str): Command name\n            json_data (dict): JSON data for this command (as a dict, will be formatted as JSON string by this function)\n            meta_data (Optional[dict], optional): Meta-data dictionary for this command. Defaults to None.\n            expected_responses (list[MxRobotStatusCode], optional):\n                Optional list of responses to wait for.\n                This function will block until one of the responses in this list is received, or until timeout.\n                If None, the function is non-blocking\n                Defaults to None.\n            timeout (Optional[float]):\n                Timeout for waiting for response among expected_responses.\n                If None, a default timeout will be used (that may not be suitable for all type of commands).\n                Defaults to None.\n                Ignored if expected_responses is None.\n        Raises\n        ------\n        TimeoutException\n            If response was not received before timeout\n        Returns\n        -------\n        Optional[Message]\n            The response received from the robot (or None if expected_responses is None)\n        \"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        with self._main_lock:\n            if expected_responses:\n                # Prepare an interruptable event waiting for any response in the provided list\n                event_with_data = InterruptableEvent(data=expected_responses)\n                self._custom_response_events.append(weakref.ref(event_with_data))\n\n            # Send the JSON request to the robot\n            msg_dict = {MX_JSON_KEY_DATA: json_data, MX_JSON_KEY_META_DATA: meta_data}\n            self._send_command(command, f'{json.dumps(msg_dict)}')\n\n        if expected_responses:\n            # Wait for the response\n            response = event_with_data.wait(timeout)\n            return response\n        return None\n\n    def _send_command(self, command: str, args: Union[str, list, tuple] = None):\n        \"\"\"Assembles and sends the command string to the Mecademic robot.\n\n        Parameters\n        ----------\n        command : string\n            Command name to send to the Mecademic robot.\n        args : list or str\n            List of arguments the command requires.\n\n        \"\"\"\n\n        # Make sure that command and args are split\n        command, args = self._split_command_args(command, args)\n        command_trimmed = command.replace('-', '').lower()\n        if command_trimmed in self._send_cmd_handlers:\n            self._send_cmd_handlers[command_trimmed](args)\n\n        # Assemble arguments into a string and concatenate to end of command.\n        if args:\n            command += f'({args_to_string(args)})'\n\n        # Put command into tx queue.\n        self._command_tx_queue.put(command)\n\n        # If logging is enabled, send command to logger.\n        if self._file_logger and self._file_logger.logging_commands:\n            self._file_logger.command_queue.put(command)\n\n    def _send_sync_command(self,\n                           command: Optional[str],\n                           args: Optional[Union[str, list, tuple]] = None,\n                           event: Optional[InterruptableEvent] = None,\n                           timeout: Optional[float] = None):\n        \"\"\"Send a command and wait for corresponding response\n           (this function handles well-known commands which have their corresponding 'wait' event in this class,\n            use _send_custom_command to perform synchronous operations on other commands)\n\n        Parameters\n        ----------\n        command : string\n            Name of the command to send (example: GetStatusGripper)\n        args : list or str\n            List of arguments the command requires.\n        event : InterruptableEvent\n            Event that will be set (unblocked) once the corresponding response is received\n        timeout : float\n            Maximum time to wait for the event to be set (i.e. response received)\n\n\n        Raises\n        ------\n        TimeoutException\n            If response was not received before timeout\n        \"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n        with self._main_lock:\n            self._check_internal_states()\n            if self._robot_info.rt_on_ctrl_port_capable:\n                # Send a \"SyncCmdQueue\" request so we know when we get the response to this get (and not an earlier one)\n                self._tx_sync += 1\n                self._tx_sync_pending = self._tx_sync\n                self._is_sync.clear()\n                self._send_command('SyncCmdQueue', f'{self._tx_sync}')\n            if event is not None and event.is_set():\n                event.clear()\n            if command is not None:\n                self._send_command(command, args)\n\n        # Wait until response is received (this will throw TimeoutException if appropriate)\n        if event is not None:\n            event.wait(timeout=timeout)\n        else:\n            # No specific event to await for. Just await until we're sync\n            self._is_sync.wait(timeout=timeout)\n\n    def _send_custom_command(self,\n                             command: str,\n                             expected_responses: list[MxRobotStatusCode] = None,\n                             timeout: float = None,\n                             skip_internal_check: bool = False) -> InterruptableEvent | Message:\n        \"\"\"Internal version of SendCustomCommand with option to skip internal state check (so it can be used\n           during connection)\n        \"\"\"\n        with self._main_lock:\n            if not skip_internal_check:\n                self._check_internal_states()\n\n            if expected_responses:\n                event_with_data = InterruptableEvent(data=expected_responses)\n                self._custom_response_events.append(weakref.ref(event_with_data))\n\n            self._send_command(command)\n\n        if expected_responses:\n            if timeout is None:\n                return event_with_data\n            else:\n                response = event_with_data.wait(timeout)\n                return response\n        default_event = InterruptableEvent(None, None)\n        default_event.set()\n        return default_event\n\n    def GetInterruptableEvent(self,\n                              codes: list[Union[MxRobotStatusCode, Message]],\n                              abort_on_error=False,\n                              abort_on_clear_motion=False) -> InterruptableEvent:\n        \"\"\"See documentation in equivalent function in robot.py\"\"\"\n        with self._main_lock:\n            event_with_data = InterruptableEvent(data=codes,\n                                                 abort_on_error=abort_on_error,\n                                                 abort_on_clear_motion=abort_on_clear_motion)\n            self._custom_response_events.append(weakref.ref(event_with_data))\n            # Check if the event must be interrupted already\n            if abort_on_error and self._robot_status.error_status:\n                event_with_data.abort('Robot is in error')\n            if abort_on_clear_motion:\n                if not self._robot_status.activation_state:\n                    event_with_data.abort('Robot was deactivated')\n                if self._robot_safety_status.pstop2_state != MxStopState.MX_STOP_STATE_RESET:\n                    event_with_data.abort('Robot is in PSTOP2 condition')\n            return event_with_data\n\n    def _launch_thread(self, *, target, args) -> threading.Thread:\n        \"\"\"Establish the threads responsible for reading/sending messages using the sockets.\n\n        Parameters\n        ----------\n        func : function handle\n            Function to run using new thread.\n        args : argument list\n            Arguments to be passed to func.\n\n        Return\n        ------\n        thread handle\n            Handle for newly-launched thread.\n\n        \"\"\"\n        thread = threading.Thread(target=target, args=args)\n        thread.daemon = True  # Make sure thread does not prevent application from quitting\n        thread.start()\n        return thread\n\n    def _initialize_command_socket(self, timeout=1.0):\n        \"\"\"Establish the command socket and the associated thread.\n\n        \"\"\"\n        if self._offline_mode:\n            return\n\n        if self._command_socket is not None:\n            raise InvalidStateError('Cannot connect since existing command socket exists.')\n\n        self._command_socket = self._connect_socket(self.logger, self._address, self._port, timeout)\n        self.logger.debug(f'Connected to {self._address}:{self._port} (control mode)')\n\n        if self._sidecar_mode:\n            self._command_socket.sendall((f'{MX_ROBOT_SIDECAR_MODE_STRING}\\0').encode('ascii'))\n            pass\n        else:\n            # Send an empty command to the connection so it knows we're not a WebSocket and does not wait a timeout\n            # before proceeding (this will speedup the connection process)\n            self._command_socket.sendall(('\\0').encode('ascii'))\n\n        if self._command_socket is None:\n            raise CommunicationError('Command socket could not be created. Is the IP address correct?')\n\n        # Create rx thread for command socket communication.\n        self._rx_thread = self._launch_thread(target=self._rx_thread_fct,\n                                              args=(\n                                                  self._command_socket,\n                                                  self._command_rx_queue,\n                                              ))\n\n        # Create tx thread for command socket communication.\n        self._tx_thread = self._launch_thread(target=self._tx_thread_fct,\n                                              args=(self._command_socket, self._command_tx_queue))\n\n    def _initialize_monitoring_socket(self, timeout):\n        \"\"\"Establish the monitoring socket and the associated thread.\n\n        \"\"\"\n        if self._offline_mode:\n            return\n\n        if self._monitor_socket is not None:\n            raise InvalidStateError('Cannot connect since existing monitor socket exists.')\n\n        port = self._port if self._monitor_mode else MX_ROBOT_TCP_PORT_FEED\n        self._monitor_socket = self._connect_socket(self.logger, self._address, port, timeout)\n        self.logger.debug(f'Connected to {self._address}:{port} (monitoring mode)')\n\n        # Send an empty command to the connection so it knows we're not a WebSocket and does not wait a timeout\n        # before proceeding (this will speedup the connection process)\n        self._monitor_socket.sendall(('\\0').encode('ascii'))\n\n        if self._monitor_socket is None:\n            raise CommunicationError('Monitor socket could not be created. Is the IP address correct?')\n\n        # Create rx thread for monitor socket communication.\n        self._monitor_rx_thread = self._launch_thread(target=self._rx_thread_fct,\n                                                      args=(self._monitor_socket, self._monitor_rx_queue))\n\n    def _receive_welcome_message(self, message_queue: queue.Queue, from_command_port: bool):\n        \"\"\"Receive and parse a welcome message in order to set _robot_info and _robot_rt_data.\n\n        Parameters\n        ----------\n        message_queue : queue\n            The welcome message will be fetched from this queue.\n        \"\"\"\n\n        # Wait for connection string (mx_st.MX_ST_CONNECTED).\n        # Alternatively, wait for status robot (mx_st.MX_ST_GET_STATUS_ROBOT) since older robots will not post the\n        # connection string on the monitoring port\n        start = time.monotonic()\n        while True:\n            try:\n                response: Message = message_queue.get(block=True, timeout=self.default_timeout)\n            except queue.Empty as e:\n                self.logger.error('No response received within timeout interval.')\n                raise CommunicationError('No response received within timeout interval.') from e\n            except BaseException as e:\n                raise e\n\n            if response.id == mx_st.MX_ST_CONNECTED or response.id == mx_st.MX_ST_GET_STATUS_ROBOT:\n                break\n\n            if from_command_port:\n                break\n\n            if (time.monotonic() - start) > self.default_timeout:\n                self.logger.error('No connect message received within timeout interval.')\n                break\n\n        if response.id == mx_st.MX_ST_CONNECTED:\n            # Attempt to parse robot return data.\n            self._robot_info = self._parse_welcome_message(response.data)\n        elif response.id == mx_st.MX_ST_GET_STATUS_ROBOT:\n            # This means we're connected to a Legacy robot that does not send mx_st.MX_ST_CONNECTED on monitoring port.\n            # We will not be able to deduce robot version. Assume some 8.x version\n            self._robot_info = RobotInfo(model='Meca500', revision=3, version='8.0.0.0-unknown-version')\n        else:\n            raise CommunicationError(f'Connection error: {response}')\n\n        self._robot_rt_data = RobotRtData(self._robot_info.num_joints)\n        self._robot_rt_data_stable = RobotRtData(self._robot_info.num_joints)\n\n    def _parse_welcome_message(self, message: str) -> RobotInfo:\n        \"\"\"Parse the robot's connection 'welcome' message and build RobotInfo from it\n           (identify robot model, version, etc.)\n\n        Parameters\n        ----------\n        message : str\n            Welcome string received from the robot\n\n        Returns\n        -------\n        RobotInfo\n            Robot information class built from the received welcome message\n        \"\"\"\n        return RobotInfo.from_command_response_string(message)\n\n    def _initialize_command_connection(self):\n        \"\"\"Attempt to connect to the command port of the Mecademic Robot.\n\n        \"\"\"\n        self._receive_welcome_message(self._command_rx_queue, True)\n\n        self._rx_handler_thread = self._launch_thread(target=self._rx_handler_fct, args=())\n\n    def _initialize_monitoring_connection(self):\n        \"\"\"Attempt to connect to the monitor port of the Mecademic Robot.\"\"\"\n\n        if self._monitor_mode:\n            self._receive_welcome_message(self._monitor_rx_queue, False)\n\n        self._monitor_rx_handler_thread = self._launch_thread(target=self._monitor_rx_handler, args=())\n\n        return\n\n    def _shut_down_queue_threads(self):\n        \"\"\"Attempt to gracefully shut down threads which read from queues.\n\n        \"\"\"\n        # Join threads which wait on a queue by sending terminate to the queue.\n        # Don't acquire _main_lock since these threads require _main_lock to finish processing.\n        if self._tx_thread is not None:\n            try:\n                self._command_tx_queue.put(_TERMINATE)\n            # pylint: disable=broad-exception-caught\n            except Exception as e:\n                self.logger.error(f'Error shutting down tx thread: {e}')\n            self._tx_thread.join(timeout=self.default_timeout)\n            self._tx_thread = None\n\n        if self._rx_handler_thread is not None and self._rx_handler_thread != threading.current_thread():\n            try:\n                self._command_rx_queue.put(_TERMINATE)\n            # pylint: disable=broad-exception-caught\n            except Exception as e:\n                self.logger.error(f'Error shutting down command response handler thread: {e}')\n            self._rx_handler_thread.join(timeout=self.default_timeout)\n            self._rx_handler_thread = None\n\n        if self._monitor_rx_handler_thread is not None and self._rx_handler_thread != threading.current_thread():\n            try:\n                self._monitor_rx_queue.put(_TERMINATE)\n            # pylint: disable=broad-exception-caught\n            except Exception as e:\n                self.logger.error(f'Error shutting down monitor handler thread: {e}')\n            self._monitor_rx_handler_thread.join(timeout=self.default_timeout)\n            self._monitor_rx_handler_thread = None\n\n    def _shut_down_socket_threads(self):\n        \"\"\"Attempt to gracefully shut down threads which read from sockets.\n\n        \"\"\"\n        with self._main_lock:\n            # Shutdown socket to terminate the rx threads.\n            if self._command_socket is not None:\n                try:\n                    self._command_socket.shutdown(socket.SHUT_RDWR)\n                    self._command_socket.close()  # This will unblock the call to read()\n                # pylint: disable=broad-exception-caught\n                except Exception:\n                    #self.logger.error(f'Error shutting down command socket: {e}')\n                    pass\n\n            if self._monitor_socket is not None:\n                try:\n                    self._monitor_socket.shutdown(socket.SHUT_RDWR)\n                    self._monitor_socket.close()  # This will unblock the call to read()\n            # pylint: disable=broad-exception-caught\n                except Exception:\n                    #self.logger.error('Error shutting down monitor socket. ' + str(e))\n                    pass\n\n            # Join threads which wait on a socket.\n            if self._rx_thread is not None:\n                self._rx_thread.join(timeout=self.default_timeout)\n                self._rx_thread = None\n\n            if self._monitor_rx_thread is not None:\n                self._monitor_rx_thread.join(timeout=self.default_timeout)\n                self._monitor_rx_thread = None\n\n    def _set_checkpoint_internal(self) -> InterruptableEvent:\n        \"\"\"Set a checkpoint for internal use using the next available internal id.\n\n        Return\n        ------\n        Checkpoint object\n            Object to use to wait for the checkpoint.\n\n        \"\"\"\n        with self._main_lock:\n            checkpoint_id = self._internal_checkpoint_counter\n\n            # Increment internal checkpoint counter.\n            self._internal_checkpoint_counter += 1\n            if self._internal_checkpoint_counter > _CHECKPOINT_ID_MAX_PRIVATE:\n                self._internal_checkpoint_counter = MX_CHECKPOINT_ID_MAX + 1\n\n            return self._set_checkpoint_impl(checkpoint_id)\n\n    def _set_checkpoint_impl(self, n, send_to_robot=True) -> InterruptableEvent:\n        \"\"\"Create a checkpoint object which can be used to wait for the checkpoint id to be received from the robot.\n\n        Checkpoints are implemented as a dictionary of lists, to support repeated checkpoints (which are discouraged),\n        and also to support expecting external checkpoints. Particularly so that ExpectExternalCheckpoints could be\n        called in any arbitrary order.\n\n        Returning an event object for the user to wait on also prevents activated checkpoints from being 'missed' by the\n        API, and prevents issues around waiting for checkpoints which may never arrive.\n\n        Parameters\n        ----------\n        n : int\n            Id of checkpoint.\n        send_to_robot : bool\n            If true, send the SetCheckpoint command to the robot.\n\n        Return\n        ------\n        Checkpoint object\n            Object to use to wait for the checkpoint.\n\n        \"\"\"\n        with self._main_lock:\n            if not isinstance(n, int):\n                raise TypeError('Please provide an integer checkpoint id.')\n\n            # Find the correct dictionary to store checkpoint.\n            if MX_CHECKPOINT_ID_MIN <= n <= MX_CHECKPOINT_ID_MAX:\n                checkpoints_dict = self._user_checkpoints\n            elif MX_CHECKPOINT_ID_MAX < n <= _CHECKPOINT_ID_MAX_PRIVATE:\n                checkpoints_dict = self._internal_checkpoints\n            else:\n                raise ValueError\n\n            self.logger.debug(f'Setting checkpoint {n}')\n\n            if n not in checkpoints_dict:\n                checkpoints_dict[n] = list()\n            event = InterruptableEvent(n)\n            checkpoints_dict[n].append(event)\n\n            if send_to_robot:\n                self._send_command('SetCheckpoint', [n])\n\n            return event\n\n    def _invalidate_checkpoints(self, message, forced: bool):\n        \"\"\"Unblock all waiting checkpoints and have them throw InterruptException\n\n        Args:\n            message (str): Message for the user that describes why the checkpoint was discarded.\n            forced (bool): True  -> Force discarding checkpoints\n                           False -> Discard only if robot has older version not supporting MX_ST_CHECKPOINT_DISCARDED\n        \"\"\"\n        if not forced and self._robot_info.supports_checkpoint_discarded:\n            # Don't discard, the robot supports MX_ST_CHECKPOINT_DISCARDED and will tell us which to discard\n            return\n\n        for checkpoints_dict in [self._internal_checkpoints, self._user_checkpoints]:\n            for checkpoints_list in checkpoints_dict.values():\n                for event in checkpoints_list:\n                    event.abort(message)\n            checkpoints_dict.clear()\n\n        self._internal_checkpoint_counter = MX_CHECKPOINT_ID_MAX + 1\n\n    def _send_motion_command(self, command: str, args: Union[str, list, tuple] = None):\n        \"\"\"Send generic motion command with support for synchronous mode and locking.\n\n        Parameters\n        ----------\n        command : string\n            The command to send.\n        args : list\n            List of arguments to be sent.\n\n        \"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            self._send_command(command, args)\n            if self._enable_synchronous_mode:\n                checkpoint = self._set_checkpoint_internal()\n\n        if self._enable_synchronous_mode:\n            checkpoint.wait()\n\n    def _send_immediate_command(self, command: str, args: Optional[Union[str, list, tuple]],\n                                event: Optional[InterruptableEvent]):\n        \"\"\"Send generic 'immediate' command with support for synchronous mode and locking.\n\n        Parameters\n        ----------\n        command : string\n            The command to send.\n        args : list\n            List of arguments to be sent.\n\n        \"\"\"\n        if self._enable_synchronous_mode:\n            self._send_sync_command(command, args, event, timeout=self.default_timeout)\n        else:\n            with self._main_lock:\n                self._send_command(command, args)\n\n    def _monitor_rx_handler(self):\n        \"\"\"Handle messages from the monitoring port of the robot.\n\n        \"\"\"\n\n        while True:\n            # Wait for a message in the queue.\n            response: Message = self._monitor_rx_queue.get(block=True)\n\n            # Terminate thread if requested.\n            if response == _TERMINATE:\n                break\n\n            self._callback_queue.put('on_monitor_message', response)\n\n            queue_size = self._monitor_rx_queue.qsize()\n            if queue_size > self._robot_rt_data.max_queue_size:\n                self._robot_rt_data.max_queue_size = queue_size\n\n            with self._main_lock:\n\n                self._handle_common_messages(message=response)\n\n                # On non-rt monitoring capable platforms, no CYCLE_END event is sent, so use system time.\n                # GET_JOINTS and GET_POSE is still sent every cycle, so log RobotRtData upon GET_POSE.\n                if not self._robot_info.rt_message_capable and response.id == mx_st.MX_ST_GET_POSE:\n                    # On non rt_monitoring platforms, we will consider this moment to be the end of cycle\n                    self._robot_events.on_end_of_cycle.set()\n                    self._callback_queue.put('on_end_of_cycle')\n\n                    if self._file_logger:\n                        # Log time in microseconds to be consistent with real-time logging timestamp.\n                        self._file_logger.write_fields(time.time_ns() / 1000, self._robot_rt_data)\n                    self._make_stable_rt_data()\n\n            self._invalidate_interruptable_events(message=\"Monitoring socket disconnected\")\n\n    def _make_stable_rt_data(self):\n        \"\"\"We have to create stable copy of rt_data, with consistent timestamp values for all attributes.\n        This consistent copy is used by GetRobotRtData()\n        \"\"\"\n\n        self._robot_rt_data_stable = copy.deepcopy(self._robot_rt_data)\n\n        # Make sure to not report values that are outdated\n        self._robot_rt_data_stable.clear_if_outdated()\n\n        # Make sure not to report values that are not enabled in real-time monitoring\n        #pylint: disable=protected-access\n        self._robot_rt_data_stable.clear_if_disabled()\n\n    def _cleanup_custom_response_events(self):\n        \"\"\"Remove from custom response event list any event that is no more referenced by anyone\n           (this is a list of weakref so they get destroyed automatically when no external code is holding a ref to\n           that interruptable event, so as cleanup here we simply remove the weakref object from the list)\"\"\"\n        # Build list of weakref objects to remove from the list (but don't delete yet, it would break the iteration)\n        events_to_delete = []\n        for event_weakref in self._custom_response_events:\n            if event_weakref() is None:\n                events_to_delete.append(event_weakref)\n        # Now remove all appropriate items from the list\n        for event_weakref in events_to_delete:\n            self._custom_response_events.remove(event_weakref)\n\n    def _awake_custom_response_events(self, response: Message):\n        \"\"\" Awake waitable events created by _send_custom_command calls that match a received response \"\"\"\n        # Find any matching custom events (but don't remove yet from the list, this would break the iteration)\n        matched_events = []\n        for event_weakref in self._custom_response_events:\n            for to_match in event_weakref().data:\n                if isinstance(to_match, Message):\n                    if response.id == to_match.id and response.data == to_match.data:\n                        matched_events.append(event_weakref)\n                else:\n                    if response.id == to_match:\n                        matched_events.append(event_weakref)\n        # Now set (awake) and remove from the list any matching event\n        for event_weakref in matched_events:\n            event_weakref().set(data=response)\n            self._custom_response_events.remove(event_weakref)\n\n    def _invalidate_interruptable_events(self, message=\"\"):\n        \"\"\" Unblock all appropriate interruptable events and have them throw InterruptException.\"\"\"\n        for event_weakref in self._custom_response_events:\n            event: InterruptableEvent = event_weakref()\n            if event:\n                event.abort(message)\n\n    def _invalidate_interruptable_events_on_error(self, message=\"\"):\n        \"\"\"Following robot entering error state, unblock all appropriate interruptable events and have them\n        throw InterruptException.\"\"\"\n        for event_weakref in self._custom_response_events:\n            event: InterruptableEvent = event_weakref()\n            #pylint: disable=protected-access\n            if event and event._abort_on_error:\n                event.abort(message)\n\n    def _invalidate_interruptable_events_on_clear_motion(self, message=\"\"):\n        \"\"\"Following robot motion cleared, unblock all appropriate interruptable events and have them\n        throw InterruptException.\"\"\"\n        for event_weakref in self._custom_response_events:\n            event: InterruptableEvent = event_weakref()\n            #pylint: disable=protected-access\n            if event and event._abort_on_clear_motion:\n                event.abort(message)\n\n    def _rx_handler_fct(self):\n        \"\"\"Handle received messages on the command socket.\n\n        \"\"\"\n        while True:\n            # Wait for a response to be available from the queue.\n            response = self._command_rx_queue.get(block=True)\n\n            # Terminate thread if requested.\n            if response == _TERMINATE:\n                break\n\n            self._callback_queue.put('on_command_message', response)\n\n            with self._main_lock:\n                self._cleanup_custom_response_events()\n                self._awake_custom_response_events(response)\n\n                self._handle_common_messages(response)\n\n        message = \"Control socket disconnected\"\n        self._invalidate_checkpoints(message, forced=True)\n        self._invalidate_interruptable_events(message)\n\n    def _handle_common_messages(self, message: Message):\n        \"\"\"Handle messages which are received on the command and monitor port, and are processed the same way.\n\n        Parameters\n        ----------\n        message : Message object\n\n        \"\"\"\n        # Remember the last time we've received a message from the robot\n        self._rx_timestamp = time.monotonic()\n\n        # Print error trace if this is an error code\n        if message.id in robot_status_code_info:\n            code_info = robot_status_code_info[message.id]\n            if code_info.is_error:\n                self.logger.error(f'Received robot error {code_info.code} ({code_info.name}): {message.data}')\n        else:\n            self.logger.debug(f'Received unknown robot status code {message.id}')\n\n        #\n        # Handle various messages/events that we're interested into\n        #\n        callback = self._messages_handlers.get(message.id)\n        if callback:\n            callback(message)\n        else:\n            #self.logger.warning(f\"No handler for message id {message.id}\")\n            pass\n\n    def _parse_response_bool(self, response: Message) -> list[bool]:\n        \"\"\" Parse standard robot response, returns array of boolean values\n        \"\"\"\n        if response.data.strip() == '':\n            return []\n        else:\n            return [bool(int(x)) for x in response.data.split(',')]\n\n    def _parse_response_int(self, response: Message) -> list[int]:\n        \"\"\" Parse standard robot response, returns array of integer values\n        \"\"\"\n        if response.data.strip() == '':\n            return []\n        else:\n            return [int(x) for x in response.data.split(',')]\n\n    def _set_activated(self, activated: bool):\n        \"\"\"Update the \"activated\" state of the robot\n\n        Parameters\n        ----------\n        activated : bool\n            Robot is activated or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.activation_state != activated:\n            if activated:\n                if self._first_robot_status_received and self._robot_status.activation_state != activated:\n                    self.logger.info(f'Robot is activated.')\n                self._robot_events.on_deactivated.clear()\n                self._robot_events.on_activated.set()\n                self._set_brakes_engaged(False)\n                self._callback_queue.put('on_activated')\n\n                if self._robot_info.version.is_at_least(10, 0):\n                    pass  # In this version, we rely on robot status to determine paused state\n                else:\n                    self._set_paused(False)\n            else:\n                if self._first_robot_status_received and self._robot_status.activation_state != activated:\n                    self.logger.info(f'Robot is deactivated.')\n                self._robot_events.on_activated.clear()\n                self._robot_events.on_deactivated.set()\n                self._set_brakes_engaged(True)\n                self._callback_queue.put('on_deactivated')\n                # Invalidate checkpoints and appropriate interruptable events\n                message = 'Robot was deactivated'\n                self._invalidate_checkpoints(message, forced=False)\n                self._invalidate_interruptable_events_on_clear_motion(message)\n            self._robot_status.activation_state = activated\n\n    def _set_homed(self, homed: bool):\n        \"\"\"Update the \"homed\" state of the robot\n\n        Parameters\n        ----------\n        homed : bool\n            Robot is homed or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.homing_state != homed:\n            if homed:\n                self._robot_events.on_homed.set()\n                self._callback_queue.put('on_homed')\n            else:\n                self._robot_events.on_homed.clear()\n            self._robot_status.homing_state = homed\n\n    def _set_sim_mode(self, sim_mode: MxRobotSimulationMode):\n        \"\"\"Update the \"sim_mode\" state of the robot\n\n        Parameters\n        ----------\n        sim_mode : MxRobotSimulationMode\n            Robot simulation mode\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.simulation_mode != sim_mode:\n            if sim_mode == MxRobotSimulationMode.MX_SIM_MODE_DISABLED:\n                self._robot_events.on_activate_sim.clear()\n                self._robot_events.on_deactivate_sim.set()\n                self._callback_queue.put('on_deactivate_sim')\n            else:\n                self._robot_events.on_deactivate_sim.clear()\n                self._robot_events.on_activate_sim.set()\n                self._callback_queue.put('on_activate_sim')\n            self._robot_status.simulation_mode = sim_mode\n            if (self._robot_events.on_activate_ext_tool_sim.is_set()\n                    and self._robot_status.simulation_mode == MxRobotSimulationMode.MX_SIM_MODE_DISABLED):\n                # Sim mode was just disabled -> Also means external tool sim has been disabled\n                self._handle_ext_tool_sim_status(self._external_tool_status.sim_tool_type)\n\n    def _set_recovery_mode(self, recovery_mode: bool):\n        \"\"\"Update the \"recovery_mode\" state of the robot\n\n        Parameters\n        ----------\n        recovery_mode : bool\n            Robot is in recovery mode or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.recovery_mode != recovery_mode:\n            if recovery_mode:\n                self._robot_events.on_deactivate_recovery_mode.clear()\n                self._robot_events.on_activate_recovery_mode.set()\n                self._callback_queue.put('on_activate_recovery_mode')\n            else:\n                self._robot_events.on_activate_recovery_mode.clear()\n                self._robot_events.on_deactivate_recovery_mode.set()\n                self._callback_queue.put('on_deactivate_recovery_mode')\n            self._robot_status.recovery_mode = recovery_mode\n\n    def _set_error_status(self, error_status: bool, error_code: Optional[int] = None):\n        \"\"\"Update the \"error\" state of the robot\n\n        Parameters\n        ----------\n        error_status : bool\n            Robot is in error or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.error_status != error_status:\n            if error_status:\n                message = \"robot is in error\"\n                self._invalidate_checkpoints(message, forced=False)\n                self._invalidate_interruptable_events_on_error(message)\n                self._robot_events.on_error.set()\n                self._robot_events.abort_all_on_error(message)\n                self._robot_events.on_error_reset.clear()\n                self._callback_queue.put('on_error')\n                # Always consider the robot paused when entering error state\n                self._set_paused(True)\n            else:\n                self._robot_events.clear_abort_all()\n                self._robot_events.on_error.clear()\n                self._robot_events.on_error_reset.set()\n                self._callback_queue.put('on_error_reset')\n            self._robot_status.error_status = error_status\n\n        self._robot_status.error_code = error_code\n\n    def _set_paused(self, paused: bool):\n        \"\"\"Update the \"paused\" state of the robot\n\n        Parameters\n        ----------\n        paused : bool\n            Robot is paused or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.pause_motion_status != paused:\n            if paused:\n                self._robot_events.on_motion_resumed.clear()\n                self._robot_events.on_motion_paused.set()\n                self._callback_queue.put('on_motion_paused')\n            else:\n                self._robot_events.on_motion_paused.clear()\n                self._robot_events.on_motion_resumed.set()\n                self._callback_queue.put('on_motion_resumed')\n            self._robot_status.pause_motion_status = paused\n        self._check_motion_clear_done()\n\n    def _set_eob(self, eob: bool):\n        \"\"\"Update the \"eob\" state of the robot\n\n        Parameters\n        ----------\n        eob : bool\n            Robot is end-of-block or not\n        \"\"\"\n        if not self._first_robot_status_received or self._robot_status.end_of_block_status != eob:\n            if eob:\n                self._robot_events.on_end_of_block.set()\n            else:\n                self._robot_events.on_end_of_block.clear()\n            self._robot_status.end_of_block_status = eob\n        self._check_motion_clear_done()\n\n    def _set_brakes_engaged(self, brakes_engaged: bool):\n        \"\"\"Update the \"brakes_engaged\" state of the robot\n\n        Parameters\n        ----------\n        brakes_engaged : bool\n            Robot brakes are engaged or not\n        \"\"\"\n        self._robot_status.brakes_engaged = brakes_engaged\n        if brakes_engaged:\n            self._robot_events.on_brakes_deactivated.clear()\n            self._robot_events.on_brakes_activated.set()\n        else:\n            self._robot_events.on_brakes_activated.clear()\n            self._robot_events.on_brakes_deactivated.set()\n\n    def _set_connection_watchdog_enabled(self, enabled: bool):\n        self._robot_status.connection_watchdog_enabled = enabled\n\n    def _set_robot_operation_mode(self, robot_operation_mode: MxRobotOperationMode):\n        \"\"\"Update the \"robot_operation_mode\" from robot safety status\n\n        Parameters\n        ----------\n        robot_operation_mode : MxRobotOperationMode\n            New robot operation mode to set in robot state\n        \"\"\"\n        self._robot_safety_status.robot_operation_mode = robot_operation_mode\n        # Notify that some change occurred in safety stop state\n        self._callback_queue.put('on_safety_stop_state_change')\n\n    def _set_reset_ready(self, reset_ready: bool):\n        \"\"\"Update the \"reset_ready\" from robot safety status\n\n        Parameters\n        ----------\n        reset_ready : bool\n            New flag to set in robot state\n        \"\"\"\n        self._robot_safety_status.reset_ready = reset_ready\n        # Notify that some change occurred in safety stop state\n        self._callback_queue.put('on_safety_stop_state_change')\n\n    def _check_motion_clear_done(self):\n        \"\"\"This function will set (unblock) on_motion_cleared once motion clear is confirmed, i.e. once no more\n           ClearMotion response is pending and once EOB is confirmed.\"\"\"\n        wait_for_eob = self.GetRobotInfo().version.is_at_least(9, 3, 0)\n        if not self._robot_events.on_motion_cleared.is_set():\n            if self._clear_motion_requests == 0:\n                if not wait_for_eob or (self._robot_status.end_of_block_status\n                                        and self._robot_status.pause_motion_status):\n                    self._robot_events.on_motion_cleared.set()\n\n    def _handle_get_joints_legacy(self, response: Message):\n        if self._robot_info.rt_message_capable:\n            # Temporarily save data if rt messages will be available to add timestamps.\n            self._tmp_rt_joint_pos = string_to_numbers(response.data)\n        else:  # not self._robot_info.rt_message_capable\n            # Legacy robot, it won't send MX_ST_RT_TARGET_JOINT_POS, let's use this response instead\n            self._robot_rt_data.rt_target_joint_pos.data = string_to_numbers(response.data)\n            self._robot_rt_data.rt_target_joint_pos.enabled = True\n            if self._is_in_sync():\n                self._robot_events.on_joints_updated.set()\n\n    def _handle_get_pose_legacy(self, response: Message):\n        if self._robot_info.rt_message_capable:\n            # Temporarily save data if rt messages will be available to add timestamps.\n            self._tmp_rt_cart_pos = string_to_numbers(response.data)\n        else:  # not self._robot_info.rt_message_capable\n            # Legacy robot, it won't send MX_ST_RT_TARGET_CART_POS, let's use this response instead\n            self._robot_rt_data.rt_target_cart_pos.data = string_to_numbers(response.data)\n            self._robot_rt_data.rt_target_cart_pos.enabled = True\n            if self._is_in_sync():\n                self._robot_events.on_pose_updated.set()\n\n    def _handle_get_conf_legacy(self, response: Message):\n        if not self._robot_info.rt_message_capable:\n            # Legacy robot, it won't send MX_ST_RT_TARGET_CONF, let's use this response instead\n            self._robot_rt_data.rt_target_conf.data = string_to_numbers(response.data)\n            self._robot_rt_data.rt_target_conf.enabled = True\n\n    def _handle_get_conf_turn_legacy(self, response: Message):\n        if not self._robot_info.rt_message_capable:\n            # Legacy robot, it won't send MX_ST_RT_TARGET_CONF_TURN, let's use this response instead\n            self._robot_rt_data.rt_target_conf_turn.data = string_to_numbers(response.data)\n            self._robot_rt_data.rt_target_conf_turn.enabled = True\n\n    def _handle_cycle_end(self, response: Message):\n        \"\"\"Handle a robot message of type mx_st.MX_ST_RT_CYCLE_END\"\"\"\n        self._robot_rt_data.cycle_count += 1\n        if not self._robot_info.rt_message_capable:\n            self._robot_info.rt_message_capable = True\n        timestamp = int(response.data)\n\n        # Useful to detect end of cycle for logging, to start logging on more consistent moment\n        self._robot_events.on_end_of_cycle.set()\n        self._callback_queue.put('on_end_of_cycle')\n\n        # Update joint and pose with legacy messages from current cycle plus the timestamps we just received\n        if self._tmp_rt_joint_pos:\n            self._robot_rt_data.rt_target_joint_pos.update_from_data(timestamp, self._tmp_rt_joint_pos)\n            self._tmp_rt_joint_pos = None\n        if self._tmp_rt_cart_pos:\n            self._robot_rt_data.rt_target_cart_pos.update_from_data(timestamp, self._tmp_rt_cart_pos)\n            self._tmp_rt_cart_pos = None\n\n        # If logging is active, log the current state.\n        if self._file_logger:\n            self._file_logger.write_fields(timestamp, self._robot_rt_data)\n        self._make_stable_rt_data()\n        self._refresh_auto_connection_watchdog()\n\n    def _refresh_auto_connection_watchdog(self, force=False):\n        \"\"\"Send a connection watchdog refresh to the robot using appropriate timeout\n\n        Args:\n            force (bool, optional): Force sending refresh now even if minimum elapsed time is not yet elapsed.\n        \"\"\"\n        if not self._auto_connection_watchdog:\n            return\n        # Use 4x monitoring interval by default\n        now = time.monotonic()\n        # Max every 10ms\n        if force or now - self._auto_connection_watchdog_last > 0.01:\n            self._auto_connection_watchdog_last = now\n            timeout = self._monitoring_interval * 4\n            # But make sure not to use a timer that's exaggeratedly small (Python is not THAT real time!)\n            if timeout < 0.25:\n                timeout = 0.25\n            self.ConnectionWatchdog(timeout)\n\n    def _handle_robot_status_response(self, response: Message):\n        \"\"\"Parse robot status response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_STATUS_ROBOT\n        if response.json_data:\n            # JSON format.\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n            json_robot_status: Optional[dict] = None\n            json_motion_status: Optional[dict] = None\n            json_safety_status: Optional[dict] = None\n            if MX_JSON_KEY_ROBOT_STATUS in json_data and isinstance(json_data[MX_JSON_KEY_ROBOT_STATUS], dict):\n                json_robot_status = json_data[MX_JSON_KEY_ROBOT_STATUS]\n            if MX_JSON_KEY_MOTION_STATUS in json_data and isinstance(json_data[MX_JSON_KEY_MOTION_STATUS], dict):\n                json_motion_status = json_data[MX_JSON_KEY_MOTION_STATUS]\n            if MX_JSON_KEY_SAFETY_STATUS in json_data and isinstance(json_data[MX_JSON_KEY_SAFETY_STATUS], dict):\n                json_safety_status = json_data[MX_JSON_KEY_SAFETY_STATUS]\n\n            if json_robot_status is None:\n                # Legacy JSON format\n                json_robot_status = json_data\n\n            if json_robot_status is not None:\n                # Read some states only from JSON (only those that don't have a distinct status event)\n                self._set_activated(\n                    json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_STATE, 0) >= MxRobotState.MX_ROBOT_STATE_ACTIVATED)\n                self._set_homed(\n                    json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_STATE, 0) == MxRobotState.MX_ROBOT_STATE_RUN)\n                self._set_sim_mode(MxRobotSimulationMode(json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_SIM, 0)))\n                self._set_recovery_mode(bool(json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_RECOVERY, False)))\n                error_code = int(json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_ERR, 0))\n                self._set_error_status(error_status=error_code != 0, error_code=error_code)\n                self._set_brakes_engaged(bool(json_robot_status.get(MX_JSON_KEY_STATUS_ROBOT_BRAKES, False)))\n            if json_motion_status is not None:\n                self._set_paused(bool(json_motion_status.get(MX_JSON_KEY_MOTION_STATUS_HOLD, False)))\n                self._set_eob(bool(json_motion_status.get(MX_JSON_KEY_MOTION_STATUS_EOB, False)))\n            if json_safety_status is not None:\n                self._set_reset_ready(bool(json_safety_status.get(MX_JSON_KEY_SAFETY_STATUS_RESET_READY, False)))\n                if (MX_JSON_KEY_SAFETY_STOP in json_safety_status\n                        and isinstance(json_safety_status[MX_JSON_KEY_SAFETY_STOP], dict)):\n                    json_safety_stop: dict = json_safety_status[MX_JSON_KEY_SAFETY_STOP]\n                    self._robot_psu_inputs.set_psu_input_mask(\n                        int(json_safety_stop.get(MX_JSON_KEY_SAFETY_PSU_INPUTS_MASK, 0)))\n                if (MX_JSON_KEY_SAFETY_STOP_STATIC_MASKS in json_safety_status\n                        and isinstance(json_safety_status[MX_JSON_KEY_SAFETY_STOP_STATIC_MASKS], dict)):\n                    json_stop_masks: dict = json_safety_status[MX_JSON_KEY_SAFETY_STOP_STATIC_MASKS]\n                    self._robot_safety_status.static_masks.clearedByPsu = int(\n                        json_stop_masks.get(MX_JSON_KEY_MASK_CLEARED_BY_PSU, 0))\n                    self._robot_safety_status.static_masks.withVmOff = int(\n                        json_stop_masks.get(MX_JSON_KEY_MASK_WITH_VM_OFF, 0))\n                    if MX_JSON_KEY_MASK_MANUAL_MODE in json_stop_masks:\n                        self._robot_safety_status.static_masks.maskedInManualMode = int(\n                            json_stop_masks.get(MX_JSON_KEY_MASK_MANUAL_MODE, 0))\n                    else:\n                        # Legacy robot version, let's use hard-coded value that was used by the robot on that build\n                        self._robot_safety_status.static_masks.maskedInManualMode = int(\n                            MxSafeStopCategory.MX_SAFE_STOP_PSTOP1) | int(MxSafeStopCategory.MX_SAFE_STOP_PSTOP2)\n        else:\n            # Legacy format.\n            status_flags = self._parse_response_bool(response)\n\n            self._set_activated(status_flags[0])\n            self._set_homed(status_flags[1])\n            self._set_sim_mode(MxRobotSimulationMode(status_flags[2]))\n            self._set_error_status(status_flags[3])\n            self._set_paused(status_flags[4])\n            self._set_eob(status_flags[5])\n            #eom(status_flag[6])\n\n        self._first_robot_status_received = True\n\n        if self._is_in_sync():\n            self._robot_events.on_status_updated.set()\n        self._callback_queue.put('on_status_updated')\n\n    def _handle_collision_status_response(self, response: Message):\n        \"\"\"Parse robot collision status response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_COLLISION_STATUS\n        parsed_response = self._parse_response_int(response)\n        status = self._robot_collision_status.self_collision_status\n        status.set_from_response(parsed_response)\n\n    def _handle_work_zone_status_response(self, response: Message):\n        \"\"\"Parse robot work zone status response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_WORK_ZONE_STATUS\n        parsed_response = self._parse_response_int(response)\n        status = self._robot_collision_status.work_zone_status\n        status.set_from_response(parsed_response)\n\n    def _handle_robot_get_robot_serial_response(self, response: Message):\n        \"\"\"Parse get robot serial response and robot info.\n\n        Parameters\n        ----------\n        response : Message object\n            GetRobotSerial response to parse and save.\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_ROBOT_SERIAL\n\n        self._robot_info.serial = response.data\n\n    def _handle_gripper_status_response(self, response: Message):\n        \"\"\"Parse gripper status response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Gripper status response to parse and handle.\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_STATUS_GRIPPER\n        status_flags = self._parse_response_bool(response)\n\n        self._gripper_status.present = status_flags[0]\n        self._gripper_status.homing_state = status_flags[1]\n        self._gripper_status.holding_part = status_flags[2]\n        self._gripper_status.target_pos_reached = status_flags[3]\n        self._gripper_status.error_status = status_flags[4]\n        self._gripper_status.overload_error = status_flags[5]\n\n        if self._is_in_sync():\n            self._robot_events.on_status_gripper_updated.set()\n            self._callback_queue.put('on_status_gripper_updated')\n\n    def _handle_ext_tool_sim_status(self, tool_type: int):\n        \"\"\"Handle gripper sim mode status change event.\n\n        Parameters\n        ----------\n        tool_type : int\n            New simulated external tool type. `MxExtToolType.MX_EXT_TOOL_NONE` when simulation is off.\n\n        \"\"\"\n        if tool_type != MxExtToolType.MX_EXT_TOOL_NONE:\n            self._robot_events.on_deactivate_ext_tool_sim.clear()\n            self._robot_events.on_activate_ext_tool_sim.set()\n            self._callback_queue.put('on_activate_ext_tool_sim')\n\n        else:\n            self._robot_events.on_activate_ext_tool_sim.clear()\n            self._robot_events.on_deactivate_ext_tool_sim.set()\n            self._callback_queue.put('on_deactivate_ext_tool_sim')\n\n    def _handle_recovery_mode_status(self, enabled: bool):\n        \"\"\"Handle recovery mode status change event.\n\n        Parameters\n        ----------\n        enabled : bool\n            Recovery mode enabled or not.\n\n        \"\"\"\n        self._set_recovery_mode(enabled)\n\n    def _handle_safety_stop_common(self):\n        \"\"\"Code called after state of any safety stop signal has changed\"\"\"\n        active_safety_stops = self._robot_safety_status.stop_mask & ~self._robot_safety_status.stop_resettable_mask\n\n        if active_safety_stops != 0:\n            # There are active safety stop signals (non-resettable)\n            if self._robot_events.on_safety_stop_reset.is_set():\n                # First safety stop event occurring -> Call appropriate callback\n                self._callback_queue.put('on_safety_stop')\n            self._robot_events.on_safety_stop_reset.clear()\n            self._robot_events.on_safety_stop_resettable.clear()\n        elif self._robot_safety_status.stop_resettable_mask != 0 and active_safety_stops == 0:\n            # There are safety stop signals that are ready to be reset\n            self._robot_events.on_safety_stop_reset.clear()\n            self._robot_events.on_safety_stop_resettable.set()\n            self._callback_queue.put('on_safety_stop_resettable')\n        elif active_safety_stops == 0:\n            # There are no safety stop signals\n            self._robot_events.on_safety_stop_reset.set()\n            self._robot_events.on_safety_stop_resettable.set()\n            self._callback_queue.put('on_safety_stop_reset')\n\n        # Awake any thread awaiting on WaitSafetyStopStateChange\n        self._robot_events.on_safety_stop_state_change.set()\n\n        # Notify that some change occurred in safety stop state\n        self._callback_queue.put('on_safety_stop_state_change')\n\n    def _handle_estop_state(self, response: Message):\n        \"\"\"Handle EStop state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_estop_state(self._parse_response_int(response)[0])\n        # Keep legacy field up-to-date\n        self._robot_status.estopState = self._robot_safety_status.estop_state\n\n        # Call deprecated callbacks\n        if self._robot_safety_status.estop_state == MxStopState.MX_STOP_STATE_ACTIVE:\n            self._robot_events.on_estop.set()\n            self._robot_events.on_estop_reset.clear()\n            self._robot_events.on_estop_resettable.clear()\n            self._callback_queue.put('on_estop')\n        elif self._robot_safety_status.estop_state == MxStopState.MX_STOP_STATE_RESETTABLE:\n            self._robot_events.on_estop.set()\n            self._robot_events.on_estop_reset.clear()\n            self._robot_events.on_estop_resettable.set()\n            self._callback_queue.put('on_estop_resettable')\n        else:\n            self._robot_events.on_estop.clear()\n            self._robot_events.on_estop_reset.set()\n            self._robot_events.on_estop_resettable.set()\n            self._callback_queue.put('on_estop_reset')\n\n        self._handle_safety_stop_common()\n\n    def _handle_pstop1_state(self, response: Message):\n        \"\"\"Handle PStop1 state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_pstop1_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()\n\n    def _handle_pstop2_state(self, response: Message):\n        \"\"\"Handle PStop2 state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_pstop2_state(self._parse_response_int(response)[0])\n        # Keep legacy field up-to-date\n        self._robot_status.pstop2State = self._robot_safety_status.pstop2_state\n\n        if self._robot_safety_status.pstop2_state == MxStopState.MX_STOP_STATE_ACTIVE:\n            # Invalidate checkpoints and appropriate interruptable events\n            message = 'Robot is in PSTOP2 condition'\n            self._invalidate_checkpoints(message, forced=False)\n            self._invalidate_interruptable_events_on_clear_motion(message)\n\n        # Call deprecated callbacks\n        if self._robot_safety_status.pstop2_state == MxStopState.MX_STOP_STATE_ACTIVE:\n            self._robot_events.on_pstop2.set()\n            self._robot_events.on_pstop2_reset.clear()\n            self._robot_events.on_pstop2_resettable.clear()\n            self._callback_queue.put('on_pstop2')\n        elif self._robot_safety_status.pstop2_state == MxStopState.MX_STOP_STATE_RESETTABLE:\n            self._robot_events.on_pstop2.set()\n            self._robot_events.on_pstop2_reset.clear()\n            self._robot_events.on_pstop2_resettable.set()\n            self._callback_queue.put('on_pstop2_resettable')\n        else:\n            self._robot_events.on_pstop2.clear()\n            self._robot_events.on_pstop2_reset.set()\n            self._robot_events.on_pstop2_resettable.set()\n            self._callback_queue.put('on_pstop2_reset')\n\n        self._handle_safety_stop_common()\n\n    def _handle_operation_mode_stop_state(self, response: Message):\n        \"\"\"Handle an operation mode safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_operation_mode_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()\n\n    def _handle_enabling_device_released_stop_state(self, response: Message):\n        \"\"\"Handle an enabling device released safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_enabling_device_released_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()\n\n    def _handle_voltage_fluctuation_stop_state(self, response: Message):\n        \"\"\"Handle an voltage fluctuation safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_voltage_fluctuation_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()\n\n    def _handle_reboot_stop_state(self, response: Message):\n        \"\"\"Handle a \"robot just rebooted\" safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_reboot_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()\n\n    def _handle_redundancy_fault_stop_state(self, response: Message):\n        \"\"\"Handle a \"redundancy fault\" safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_redundancy_fault_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()\n\n    def _handle_standstill_fault_stop_state(self, response: Message):\n        \"\"\"Handle a \"standstill fault\" safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_standstill_fault_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()\n\n    def _handle_connection_dropped_stop_state(self, response: Message):\n        \"\"\"Handle a \"connection dropped\" safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_connection_dropped_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()\n\n    def _handle_minor_error_stop_state(self, response: Message):\n        \"\"\"Handle a \"minor error\" safety stop state change.\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        self._robot_safety_status.set_minor_error_stop_state(self._parse_response_int(response)[0])\n        self._handle_safety_stop_common()\n\n    def _handle_get_time_scaling_response(self, response: Message):\n        \"\"\"Handle a time scaling changes.\n\n        Parameters\n        ----------\n        response : Message object\n                    \"\"\"\n        assert response.id == mx_st.MX_ST_TIME_SCALING\n        self._robot_events.on_time_scaling_changed.set()\n\n    def _handle_effective_time_scaling_data(self, response: Message):\n        \"\"\"Handle an effective time scaling rt data.\n\n        Parameters\n        ----------\n        response : Message object\n                    \"\"\"\n        assert response.id == mx_st.MX_ST_RT_EFFECTIVE_TIME_SCALING\n        self._robot_rt_data.rt_effective_time_scaling.update_from_csv(response.data)\n\n    def _handle_rt_vm(self, response: Message):\n        \"\"\"Handle an real-time motor voltage data\n        Parameters\n        ----------\n        response : Message object\n                    \"\"\"\n        assert response.id == mx_st.MX_ST_RT_VM\n        self._robot_rt_data.rt_vm.update_from_csv(response.data)\n\n    def _handle_rt_current(self, response: Message):\n        \"\"\"Handle an real-time motor current data\n        Parameters\n        ----------\n        response : Message object\n                    \"\"\"\n        assert response.id == mx_st.MX_ST_RT_CURRENT\n        self._robot_rt_data.rt_current.update_from_csv(response.data)\n\n    def _handle_ext_tool_fw_version(self, response: Message):\n        \"\"\"Parse external tool firmware version\"\"\"\n        self._robot_info.ext_tool_version.update_version(response.data)\n\n    def _handle_external_tool_status_response(self, response: Message):\n        \"\"\"Parse external tool status response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            External tool status response to parse and handle.\n\n        \"\"\"\n\n        assert response.id == mx_st.MX_ST_RT_EXTTOOL_STATUS\n        if response.json_data:\n            # JSON format.\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n            self._robot_rt_data.rt_external_tool_status.timestamp = int(\n                response.json_data.get(MX_JSON_KEY_TIMESTAMP_US, 0))\n            status_flags = self._robot_rt_data.rt_external_tool_status.data\n            status_flags[0] = int(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_SIM_TYPE, 0))\n            status_flags[1] = int(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_PHYSICAL_TYPE, 0))\n            status_flags[2] = int(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_HOMED, 0))\n            status_flags[3] = int(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_ERROR, 0))\n            status_flags[4] = int(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_OVERHEAT, 0))\n            self._external_tool_status.comm_err_warning = bool(json_data.get(MX_JSON_KEY_EXTTOOL_STATUS_COMM_ERR,\n                                                                             False))\n        else:\n            self._robot_rt_data.rt_external_tool_status.update_from_csv(response.data)\n            status_flags = self._robot_rt_data.rt_external_tool_status.data\n\n        try:\n            self._external_tool_status.sim_tool_type = MxExtToolType(status_flags[0])\n        except ValueError:\n            # Unknown enum value, let's store as an integer\n            self._external_tool_status.sim_tool_type = status_flags[0]\n\n        try:\n            self._external_tool_status.physical_tool_type = MxExtToolType(status_flags[1])\n        except ValueError:\n            # Unknown enum value, let's store as an integer\n            self._external_tool_status.physical_tool_type = status_flags[1]\n\n        self._external_tool_status.homing_state = status_flags[2] != 0\n        self._external_tool_status.error_status = status_flags[3] != 0\n        self._external_tool_status.overload_error = status_flags[4] != 0\n\n        if self._is_in_sync():\n            self._robot_events.on_external_tool_status_updated.set()\n            self._callback_queue.put('on_external_tool_status_updated')\n\n    def _handle_get_network_cfg_response(self, response: Message):\n        \"\"\" Handle robot response to GetNetworkCfg command \"\"\"\n\n        assert response.id == mx_st.MX_ST_GET_NETWORK_CFG\n        if response.json_data:\n            # JSON format.\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n\n            self._network_config.dhcp = bool(json_data.get(MX_JSON_KEY_NETWORK_CFG_DHCP, False))\n\n            self._network_config.ip = str(json_data.get(MX_JSON_KEY_NETWORK_CFG_IP, \"\"))\n            self._network_config.mask = str(json_data.get(MX_JSON_KEY_NETWORK_CFG_MASK, \"\"))\n            self._network_config.gateway = str(json_data.get(MX_JSON_KEY_NETWORK_CFG_GATEWAY, \"\"))\n            self._network_config.mac = str(json_data.get(MX_JSON_KEY_NETWORK_CFG_MAC, \"\"))\n            self._network_config.name = str(json_data.get(MX_JSON_KEY_NETWORK_CFG_ROBOT_NAME, \"\"))\n\n        if self._is_in_sync():\n            self._robot_events.on_network_config_updated.set()\n\n    def _handle_gripper_state_response(self, response: Message):\n        \"\"\"Parse gripper state response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Gripper state response to parse and handle.\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_GRIPPER_STATE\n        self._robot_rt_data.rt_gripper_state.update_from_csv(response.data)\n        status_flags = self._robot_rt_data.rt_gripper_state.data\n\n        self._gripper_state.holding_part = bool(status_flags[0])\n        self._gripper_state.target_pos_reached = bool(status_flags[1])\n        if len(status_flags) > 2:\n            self._gripper_state.closed = bool(status_flags[2])\n            self._gripper_state.opened = bool(status_flags[3])\n\n        if self._is_in_sync():\n            self._robot_events.on_gripper_state_updated.set()\n            self._callback_queue.put('on_gripper_state_updated')\n            if self._gripper_state.holding_part:\n                self._robot_events.on_holding_part.set()\n                self._robot_events.on_released_part.clear()\n            else:\n                self._robot_events.on_holding_part.clear()\n                self._robot_events.on_released_part.set()\n\n    def _handle_gripper_force_response(self, response: Message):\n        self._robot_rt_data.rt_gripper_force.update_from_csv(response.data)\n\n    def _handle_gripper_pos_response(self, response: Message):\n        self._robot_rt_data.rt_gripper_pos.update_from_csv(response.data)\n\n    def _handle_valve_state_response(self, response: Message):\n        \"\"\"Parse pneumatic valve state response and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Pneumatic valve state response to parse and handle.\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_VALVE_STATE\n        self._robot_rt_data.rt_valve_state.update_from_csv(response.data)\n\n        self._valve_state.valve_opened = self._robot_rt_data.rt_valve_state.data\n\n        if self._is_in_sync():\n            self._robot_events.on_valve_state_updated.set()\n            self._callback_queue.put('on_valve_state_updated')\n\n    def _handle_io_status(self, response: Message):\n        \"\"\"Parse IO status and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Io state to parse and handle.\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_IO_STATUS\n\n        # Extract the Bank id\n        bank_id = MxIoBankId.MX_IO_BANK_ID_UNDEFINED\n        values = []\n        if response.json_data:\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n            bank_id = MxIoBankId(json_data.get(MX_JSON_KEY_IO_STATUS_BANK_ID, 0))\n        else:\n            values = tools.string_to_numbers(response.data)\n            bank_id = values[1]\n\n        new_io_status = IoStatus()\n        new_io_status_ts = TimestampedData.zeros(4, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n        if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n            new_io_status = self._io_module_status\n        elif bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n            new_io_status = self._sig_gen_status\n        else:\n            return\n        new_io_status.bank_id = bank_id\n        prev_sim_mode = new_io_status.sim_mode\n\n        if response.json_data:\n            # JSON format. Convert into timestamped data\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n\n            # Extract JSON data\n            new_io_status.present = bool(json_data.get(MX_JSON_KEY_IO_STATUS_PRESENT, False))\n            new_io_status.nb_inputs = int(json_data.get(MX_JSON_KEY_IO_STATUS_NB_INPUTS, 0))\n            new_io_status.nb_outputs = int(json_data.get(MX_JSON_KEY_IO_STATUS_NB_OUTPUTS, 0))\n            new_io_status.sim_mode = bool(json_data.get(MX_JSON_KEY_IO_STATUS_SIM_MODE, False))\n            new_io_status.error = int(json_data.get(MX_JSON_KEY_IO_STATUS_ERROR, 0))\n            new_io_status.timestamp = int(response.json_data.get(MX_JSON_KEY_TIMESTAMP_US, 0))\n            # Convert into timestamped data (equivalent to text API)\n            new_io_status_ts.timestamp = new_io_status.timestamp\n            new_io_status_ts.data[0] = new_io_status.bank_id\n            new_io_status_ts.data[1] = 1 if new_io_status.present else 0\n            new_io_status_ts.data[2] = 1 if new_io_status.sim_mode else 0\n            new_io_status_ts.data[3] = new_io_status.error\n        else:\n            # Extract API values\n            new_io_status_ts.update_from_csv(response.data)\n            new_io_status.timestamp = values[0]\n            new_io_status.present = True if values[2] != 0 else False\n            new_io_status.sim_mode = True if values[3] != 0 else False\n            new_io_status.error = values[4]\n            # Note: nb_inputs and nb_outputs is updated by _handle_input_state / _handle_output_state\n\n        # Store back into our context\n        if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n            self._io_module_status = new_io_status\n            self._robot_rt_data.rt_io_module_status = new_io_status_ts\n        elif bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n            self._sig_gen_status = new_io_status\n            self._robot_rt_data.rt_sig_gen_status = new_io_status_ts\n\n        # Update events/callbacks\n        if not self._first_robot_status_received or prev_sim_mode != new_io_status.sim_mode:\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                if new_io_status.sim_mode:\n                    self._robot_events.on_io_sim_enabled.set()\n                    self._robot_events.on_io_sim_disabled.clear()\n                    self._callback_queue.put('on_io_sim_enabled')\n                else:\n                    self._robot_events.on_io_sim_enabled.clear()\n                    self._robot_events.on_io_sim_disabled.set()\n                    self._callback_queue.put('on_io_sim_disabled')\n\n        if self._is_in_sync():\n            self._robot_events.on_io_status_updated.set()\n\n    def _handle_output_state(self, response: Message):\n        \"\"\"Parse digital output state and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Digital output state to parse and handle.\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_OUTPUT_STATE\n        values = tools.string_to_numbers(response.data)\n        changed = False\n        if len(values) > 1:\n            timestamp = values[0]\n            bank_id = values[1]\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                changed = True\n                self._robot_rt_data.rt_io_module_outputs.update_from_data(timestamp, values[2:])\n                self._io_module_status.nb_outputs = len(self._robot_rt_data.rt_io_module_outputs.data)\n            elif bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                changed = True\n                self._robot_rt_data.rt_sig_gen_outputs.update_from_data(timestamp, values[2:])\n                self._sig_gen_status.nb_outputs = len(self._robot_rt_data.rt_sig_gen_outputs.data)\n\n        if changed and self._is_in_sync():\n            self._robot_events.on_output_state_updated.set()\n            self._callback_queue.put('on_output_state_updated')\n\n    def _handle_input_state(self, response: Message):\n        \"\"\"Parse digital input state and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Digital input state to parse and handle.\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_INPUT_STATE\n        values = tools.string_to_numbers(response.data)\n        changed = False\n        if len(values) > 1:\n            timestamp = values[0]\n            bank_id = values[1]\n            if bank_id == MxIoBankId.MX_IO_BANK_ID_IO_MODULE:\n                changed = True\n                self._robot_rt_data.rt_io_module_inputs.update_from_data(timestamp, values[2:])\n                self._io_module_status.nb_inputs = len(self._robot_rt_data.rt_io_module_inputs.data)\n            elif bank_id == MxIoBankId.MX_IO_BANK_ID_SIG_GEN:\n                changed = True\n                self._robot_rt_data.rt_sig_gen_inputs.update_from_data(timestamp, values[2:])\n                self._sig_gen_status.nb_inputs = len(self._robot_rt_data.rt_sig_gen_inputs.data)\n\n        if changed and self._is_in_sync():\n            self._robot_events.on_input_state_updated.set()\n            self._callback_queue.put('on_input_state_updated')\n\n    def _handle_vacuum_state(self, response: Message):\n        \"\"\"Parse vacuum state and update status fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Vacuum grip state to parse and handle.\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_VACUUM_STATE\n        self._robot_rt_data.rt_vacuum_state.update_from_csv(response.data)\n\n        self._vacuum_state.bank_id = MxIoBankId.MX_IO_BANK_ID_IO_MODULE  #todo, this member doesn't exist\n        self._vacuum_state.timestamp = self._robot_rt_data.rt_vacuum_state.timestamp\n        self._vacuum_state.vacuum_on = bool(self._robot_rt_data.rt_vacuum_state.data[0])\n        self._vacuum_state.purge_on = bool(self._robot_rt_data.rt_vacuum_state.data[1])\n        self._vacuum_state.holding_part = bool(self._robot_rt_data.rt_vacuum_state.data[2])\n\n        if self._is_in_sync():\n            self._robot_events.on_vacuum_state_updated.set()\n            self._callback_queue.put('on_vacuum_state_updated')\n            if self._vacuum_state.holding_part:\n                self._robot_events.on_holding_part.set()\n                self._robot_events.on_released_part.clear()\n            elif not self._vacuum_state.purge_on:\n                self._robot_events.on_holding_part.clear()\n                self._robot_events.on_released_part.set()\n            if self._vacuum_state.purge_on:\n                self._robot_events.on_vacuum_purge_done.clear()\n            else:\n                self._robot_events.on_vacuum_purge_done.set()\n\n    def _handle_vacuum_pressure(self, response: Message):\n        \"\"\"Parse vacuum pressure and update fields and events.\n\n        Parameters\n        ----------\n        response : Message object\n            Vacuum pressure to parse and handle.\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_RT_VACUUM_PRESSURE\n        self._robot_rt_data.rt_vacuum_pressure.update_from_csv(response.data)\n\n    def _handle_ext_tool_sim_status_legacy(self, response: Message):\n        if not str(response.data).isdigit():\n            self._handle_ext_tool_sim_status(MxExtToolType.MX_EXT_TOOL_MEGP25_SHORT)\n        else:\n            self._handle_ext_tool_sim_status(int(response.data))\n\n    def _handle_ext_tool_sim_status_off(self, response: Message):\n        self._handle_ext_tool_sim_status(MxExtToolType.MX_EXT_TOOL_NONE)\n\n    def _handle_get_operation_mode(self, response: Message):\n        robot_operation_mode = self._parse_response_int(response)[0]\n        self._set_robot_operation_mode(robot_operation_mode)\n\n    def _handle_torque_limit_status(self, response: Message):\n        torque_exceeded = self._parse_response_int(response)[0]\n        if torque_exceeded:\n            self.logger.info(\n                f'Torque limit exceeded. Current torque: {args_to_string(self._robot_rt_data.rt_joint_torq.data)}')\n\n    def _handle_target_joint_pos(self, response: Message):\n        self._robot_rt_data.rt_target_joint_pos.update_from_csv(response.data)\n        if self._is_in_sync():\n            self._robot_events.on_joints_updated.set()\n\n    def _handle_target_cart_pos(self, response: Message):\n        self._robot_rt_data.rt_target_cart_pos.update_from_csv(response.data, allowed_nb_val=[4, 6])\n        if self._is_in_sync():\n            self._robot_events.on_pose_updated.set()\n\n    def _handle_target_joint_vel(self, response: Message):\n        self._robot_rt_data.rt_target_joint_vel.update_from_csv(response.data)\n\n    def _handle_target_cart_vel(self, response: Message):\n        self._robot_rt_data.rt_target_cart_vel.update_from_csv(response.data, allowed_nb_val=[4, 6])\n\n    def _handle_target_joint_torq(self, response: Message):\n        self._robot_rt_data.rt_target_joint_torq.update_from_csv(response.data)\n\n    def _handle_target_conf(self, response: Message):\n        self._robot_rt_data.rt_target_conf.update_from_csv(response.data)\n\n    def _handle_target_conf_turn(self, response: Message):\n        self._robot_rt_data.rt_target_conf_turn.update_from_csv(response.data)\n\n    def _handle_joint_pos(self, response: Message):\n        self._robot_rt_data.rt_joint_pos.update_from_csv(response.data)\n\n    def _handle_cart_pos(self, response: Message):\n        self._robot_rt_data.rt_cart_pos.update_from_csv(response.data, allowed_nb_val=[4, 6])\n\n    def _handle_joint_vel(self, response: Message):\n        self._robot_rt_data.rt_joint_vel.update_from_csv(response.data)\n\n    def _handle_joint_torq(self, response: Message):\n        self._robot_rt_data.rt_joint_torq.update_from_csv(response.data)\n\n    def _handle_cart_vel(self, response: Message):\n        self._robot_rt_data.rt_cart_vel.update_from_csv(response.data, allowed_nb_val=[4, 6])\n\n    def _handle_conf(self, response: Message):\n        self._robot_rt_data.rt_conf.update_from_csv(response.data)\n\n    def _handle_conf_turn(self, response: Message):\n        self._robot_rt_data.rt_conf_turn.update_from_csv(response.data)\n\n    def _handle_accelerometer(self, response: Message):\n        timestamp, index, *measurements = string_to_numbers(response.data)\n        if index not in self._robot_rt_data.rt_accelerometer:\n            self._robot_rt_data.rt_accelerometer[index] = TimestampedData(\n                timestamp, measurements, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)\n            self._robot_rt_data.rt_accelerometer[index].enabled = True\n        if timestamp > self._robot_rt_data.rt_accelerometer[index].timestamp:\n            self._robot_rt_data.rt_accelerometer[index].timestamp = timestamp\n            self._robot_rt_data.rt_accelerometer[index].data = measurements\n\n    def _handle_abs_joint_pos(self, response: Message):\n        self._robot_rt_data.rt_abs_joint_pos.update_from_csv(response.data)\n\n    def _handle_wrf(self, response: Message):\n        self._robot_rt_data.rt_wrf.update_from_csv(response.data, allowed_nb_val=[4, 6])\n\n    def _handle_trf(self, response: Message):\n        self._robot_rt_data.rt_trf.update_from_csv(response.data, allowed_nb_val=[4, 6])\n\n    def _handle_rt_checkpoint(self, response: Message):\n        self._robot_rt_data.rt_checkpoint.update_from_csv(response.data)\n\n    def _handle_impossible_reset_err(self, response: Message):\n        self.logger.error(response.data)\n\n    def _handle_activation_err(self, response: Message):\n        self._robot_events.on_activated.abort('Activation error')\n        self._robot_events.on_homed.abort('Activation error')\n\n    def _handle_homing_err(self, response: Message):\n        self._robot_events.on_homed.abort('Homing error')\n\n    # Methods to handle specific responses\n    def _handle_pause_motion(self, response: Message):\n        if self._robot_info.version.is_at_least(10, 0):\n            pass  # In this version, we rely on robot status to determine paused state\n        else:\n            self._set_paused(True)\n\n    def _handle_resume_motion(self, response: Message):\n        if self._robot_info.version.is_at_least(10, 0):\n            pass  # In this version, we rely on robot status to determine paused state\n        else:\n            self._set_paused(False)\n\n    def _handle_clear_motion(self, response: Message):\n        if self._clear_motion_requests <= 1:\n            self._clear_motion_requests = 0\n            self._callback_queue.put('on_motion_cleared')\n            if self._robot_info.version.is_at_least(10, 0):\n                pass  # In this version, we rely on robot status to determine paused state\n            else:\n                self._set_paused(True)\n        else:\n            self._clear_motion_requests -= 1\n\n        self._check_motion_clear_done()\n\n    def _handle_eob(self, response: Message):\n        if self._robot_info.version.is_at_least(10, 0):\n            pass  # In this version, we rely on robot status to determine paused state\n        else:\n            self._set_eob(True)\n\n    def _handle_offline_start(self, response: Message):\n        self._robot_events.on_offline_program_started.set()\n        self._callback_queue.put('on_offline_program_state')\n\n    def _handle_offline_program_error(self, response: Message):\n        self._robot_events.on_offline_program_started.abort(f\"Failed to start program: {response.data}\")\n\n    def _handle_file_op_done(self, response: Message):\n        self._robot_events.on_file_op_done.set(response)\n\n    def _handle_load_file_err(self, response: Message):\n        self._robot_events.on_file_op_done.abort(f\"Failed to load file: {response.data}\")\n\n    def _handle_save_file_err(self, response: Message):\n        self._robot_events.on_file_op_done.abort(f\"Failed to save file: {response.data}\")\n\n    def _handle_delete_file_err(self, response: Message):\n        self._robot_events.on_file_op_done.abort(f\"Failed to delete file: {response.data}\")\n\n    def _handle_checkpoint(self, response: Message, discarded: bool):\n        \"\"\"Handle the checkpoint reached message from the robot, set the appropriate events, etc.\n\n        Parameters\n        ----------\n        response : Message object\n            Response message which includes the received checkpoint id.\n        discarded : bool\n            Tells if the checkpoint has been discarded or reached.\n\n        \"\"\"\n        assert (response.id == mx_st.MX_ST_CHECKPOINT_REACHED or response.id == mx_st.MX_ST_CHECKPOINT_DISCARDED)\n        checkpoint_id = int(response.data)\n\n        self.logger.debug(f'Checkpoint {checkpoint_id} {\"discarded\"if discarded else \"reached\"}')\n\n        # Check user checkpoints.\n        abort_msg = 'Checkpoint discarded by the robot'\n        if checkpoint_id in self._user_checkpoints and self._user_checkpoints[checkpoint_id]:\n            if discarded:\n                self._user_checkpoints[checkpoint_id].pop(0).abort(abort_msg)\n            else:\n                self._user_checkpoints[checkpoint_id].pop(0).set()\n            # If list corresponding to checkpoint id is empty, remove the key from the dict.\n            if not self._user_checkpoints[checkpoint_id]:\n                self._user_checkpoints.pop(checkpoint_id)\n            # If there are events are waiting on 'any checkpoint', set them all.\n            if '*' in self._internal_checkpoints and self._internal_checkpoints['*']:\n                for event in self._internal_checkpoints.pop('*'):\n                    if discarded:\n                        event.abort(abort_msg)\n                    else:\n                        event.set()\n\n            if discarded:\n                # Enqueue the on_checkpoint_discarded callback.\n                self._callback_queue.put('on_checkpoint_discarded', checkpoint_id)\n            else:\n                # Enqueue the on_checkpoint_reached callback.\n                self._callback_queue.put('on_checkpoint_reached', checkpoint_id)\n\n        # Check internal checkpoints.\n        elif checkpoint_id in self._internal_checkpoints and self._internal_checkpoints[checkpoint_id]:\n            if discarded:\n                self._internal_checkpoints[checkpoint_id].pop(0).abort(abort_msg)\n            else:\n                self._internal_checkpoints[checkpoint_id].pop(0).set()\n            # If list corresponding to checkpoint id is empty, remove the key from the dict.\n            if not self._internal_checkpoints[checkpoint_id]:\n                self._internal_checkpoints.pop(checkpoint_id)\n        elif not self._sidecar_mode:\n            self.logger.warning(\n                f'Received un-tracked checkpoint {checkpoint_id}. Please use ExpectExternalCheckpoint() to track.')\n\n    def _handle_get_realtime_monitoring_response(self, response: Message):\n        \"\"\"Parse robot response to \"get\" or \"set\" real-time monitoring.\n           This function identifies which real-time events are expected, and which are not enabled.\n\n\n        Parameters\n        ----------\n        response : Message object\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_GET_REAL_TIME_MONITORING\n\n        # Clear all \"enabled\" bits in real-time data\n        #pylint: disable=protected-access\n        self._robot_rt_data._reset_enabled()\n\n        # Following RT data are always accessible in the Python API even if not always sent by the robot, because this\n        # Python API will construct them from mx_st.MX_ST_GET_JOINTS / mx_st.MX_ST_GET_POSE if necessary\n        self._robot_rt_data.rt_target_joint_pos.enabled = True\n        self._robot_rt_data.rt_target_cart_pos.enabled = True\n        # Following RT data are always sent by the robot\n        if self._robot_info.version.is_at_least(9, 0):\n            self._robot_rt_data.rt_target_conf.enabled = True\n            self._robot_rt_data.rt_target_conf_turn.enabled = True\n            self._robot_rt_data.rt_wrf.enabled = True\n            self._robot_rt_data.rt_trf.enabled = True\n        if self._robot_info.version.is_at_least(9, 2):\n            self._robot_rt_data.rt_external_tool_status.enabled = True\n            self._robot_rt_data.rt_valve_state.enabled = True\n            self._robot_rt_data.rt_gripper_state.enabled = True\n        if self._robot_info.version.is_at_least(9, 4):\n            self._robot_rt_data.rt_io_module_status.enabled = True\n            self._robot_rt_data.rt_io_module_outputs.enabled = True\n            self._robot_rt_data.rt_io_module_inputs.enabled = True\n            self._robot_rt_data.rt_vacuum_state.enabled = True\n            self._robot_rt_data.rt_sig_gen_status.enabled = True\n            self._robot_rt_data.rt_sig_gen_outputs.enabled = True\n            self._robot_rt_data.rt_sig_gen_inputs.enabled = True\n        if self._robot_info.version.is_at_least(10, 1, 2):\n            self._robot_rt_data.rt_checkpoint.enabled = True\n\n        # Parse the response to identify which are \"enabled\"\n        enabled_event_ids = self._parse_response_int(response)\n        for event_id in enabled_event_ids:\n            if event_id == mx_st.MX_ST_RT_TARGET_JOINT_POS:\n                self._robot_rt_data.rt_target_joint_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_CART_POS:\n                self._robot_rt_data.rt_target_cart_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_JOINT_VEL:\n                self._robot_rt_data.rt_target_joint_vel.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_CART_VEL:\n                self._robot_rt_data.rt_target_cart_vel.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_JOINT_TORQ:\n                self._robot_rt_data.rt_target_joint_torq.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_CONF:\n                self._robot_rt_data.rt_target_conf.enabled = True\n            if event_id == mx_st.MX_ST_RT_TARGET_CONF_TURN:\n                self._robot_rt_data.rt_target_conf_turn.enabled = True\n            if event_id == mx_st.MX_ST_RT_JOINT_POS:\n                self._robot_rt_data.rt_joint_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_CART_POS:\n                self._robot_rt_data.rt_cart_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_JOINT_VEL:\n                self._robot_rt_data.rt_joint_vel.enabled = True\n            if event_id == mx_st.MX_ST_RT_JOINT_TORQ:\n                self._robot_rt_data.rt_joint_torq.enabled = True\n            if event_id == mx_st.MX_ST_RT_CART_VEL:\n                self._robot_rt_data.rt_cart_vel.enabled = True\n            if event_id == mx_st.MX_ST_RT_CONF:\n                self._robot_rt_data.rt_conf.enabled = True\n            if event_id == mx_st.MX_ST_RT_CONF_TURN:\n                self._robot_rt_data.rt_conf_turn.enabled = True\n            if event_id == mx_st.MX_ST_RT_EFFECTIVE_TIME_SCALING:\n                self._robot_rt_data.rt_effective_time_scaling.enable = True\n            if event_id == mx_st.MX_ST_RT_VM:\n                self._robot_rt_data.rt_vm.enable = True\n            if event_id == mx_st.MX_ST_RT_CURRENT:\n                self._robot_rt_data.rt_current.enable = True\n            if event_id == mx_st.MX_ST_RT_WRF:\n                self._robot_rt_data.rt_wrf.enabled = True\n            if event_id == mx_st.MX_ST_RT_TRF:\n                self._robot_rt_data.rt_trf.enabled = True\n            if event_id == mx_st.MX_ST_RT_CHECKPOINT:\n                self._robot_rt_data.rt_checkpoint.enabled = True\n            if event_id == mx_st.MX_ST_RT_ACCELEROMETER:\n                for accelerometer in self._robot_rt_data.rt_accelerometer.values():\n                    accelerometer.enabled = True\n            if event_id == mx_st.MX_ST_RT_ABS_JOINT_POS:\n                self._robot_rt_data.rt_abs_joint_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_EXTTOOL_STATUS:\n                self._robot_rt_data.rt_external_tool_status.enabled = True\n            if event_id == mx_st.MX_ST_RT_VALVE_STATE:\n                self._robot_rt_data.rt_valve_state.enabled = True\n            if event_id == mx_st.MX_ST_RT_GRIPPER_FORCE:\n                self._robot_rt_data.rt_gripper_force.enabled = True\n            if event_id == mx_st.MX_ST_RT_GRIPPER_POS:\n                self._robot_rt_data.rt_gripper_pos.enabled = True\n            if event_id == mx_st.MX_ST_RT_IO_STATUS:\n                self._robot_rt_data.rt_io_module_status.enabled = True\n                self._robot_rt_data.rt_sig_gen_status.enabled = True\n            if event_id == mx_st.MX_ST_RT_OUTPUT_STATE:\n                self._robot_rt_data.rt_io_module_outputs.enabled = True\n                self._robot_rt_data.rt_sig_gen_outputs.enabled = True\n            if event_id == mx_st.MX_ST_RT_INPUT_STATE:\n                self._robot_rt_data.rt_io_module_inputs.enabled = True\n                self._robot_rt_data.rt_sig_gen_inputs.enabled = True\n            if event_id == mx_st.MX_ST_RT_VACUUM_STATE:\n                self._robot_rt_data.rt_vacuum_state.enabled = True\n            if event_id == mx_st.MX_ST_RT_VACUUM_PRESSURE:\n                self._robot_rt_data.rt_vacuum_pressure.enabled = True\n\n        # Make sure to clear values that we should no more received\n        #pylint: disable=protected-access\n        self._robot_rt_data.clear_if_disabled()\n\n    def _print_fw_update_status(self, reboot_pct: float = 0):\n        \"\"\" Print a trace that summarize current firmware update status (progression) \"\"\"\n        if (not self._fw_update_status.progress and not self._fw_update_status.complete\n                and not self._fw_update_status.error):\n            # Not in progress, not completed, not in error => Nothing to print\n            return\n\n        reboot_ratio = self._get_reboot_duration() / self._get_fw_update_duration()\n\n        total_pct = ((1 - reboot_ratio) * self._fw_update_status.progress) + (reboot_ratio * reboot_pct)\n\n        if self._fw_update_status.error:\n            # Print as 'debug' trace (error trace will be printed by UpdateRobot function anyways)\n            self.logger.debug(f'Firmware update failed: {self._fw_update_status.error_msg}')\n        elif self._fw_update_status.complete:\n            # Print as 'debug' trace (info trace will be printed by UpdateRobot function anyways)\n            self.logger.debug(f'Firmware update complete')\n        else:\n            self.logger.info(f'Firmware update progress: {int(total_pct)}% ({self._fw_update_status.step})')\n        #pylint: disable=protected-access\n        self._fw_update_status._last_print_timestamp = time.monotonic()\n\n    def _handle_fw_update_progress(self, event: Message):\n        \"\"\"Parse robot firmware update progress message\n\n        Parameters\n        ----------\n        event : Message object\n            The event message to parse.\n\n        \"\"\"\n        assert event.id == mx_st.MX_ST_FW_UPDATE_PROGRESS\n        if event.json_data:\n            json_data: dict = event.json_data.get(MX_JSON_KEY_DATA, {})\n\n            # Parse JSON message\n            new_updating = bool(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_UPDATING, False))\n            new_version = str(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_VERSION, \"\"))\n            new_error = bool(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_ERROR, False))\n            new_error_msg = str(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_ERROR_MSG, \"\"))\n            new_progress_pct = float(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_PCT, 0))\n            new_step = str(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_STEP, \"\"))\n            reboot_done = bool(json_data.get(MX_JSON_KEY_FW_UPDATE_PROGRESS_REBOOT_DONE, False))\n\n            # Check if it's time to print update progress\n            print_now = False\n            #pylint: disable=protected-access\n            last_print_timestamp = self._fw_update_status._last_print_timestamp\n            if self._fw_update_reboot_timestamp != 0:\n                print_now = False  # In this case progress is printed by _check_update_progress\n            if new_step != self._fw_update_status.step:\n                print_now = True\n            elif time.monotonic() - last_print_timestamp > 5.0:\n                print_now = True\n\n            self._fw_update_status.in_progress = new_updating\n            self._fw_update_status.complete = self._fw_update_started and not new_updating\n            self._fw_update_status.version = new_version\n            self._fw_update_status.error = new_error\n            self._fw_update_status.error_msg = new_error_msg\n            self._fw_update_status.progress = new_progress_pct\n            self._fw_update_status.step = new_step\n            if reboot_done:\n                self._fw_update_reboot_done = True\n\n            if print_now:\n                reboot_pct = 100 if reboot_done else 0\n                self._print_fw_update_status(reboot_pct)\n\n    def _handle_sync_response(self, response: Message):\n        \"\"\"Parse robot response to \"SyncCmdQueue\" request\n           This class uses the \"SyncCmdQueue\" request/response to ensure synchronous \"Get\" operations have received the\n           expected response from the robot (and not a response/event sent by the robot prior to our \"Get\" request).\n\n        Parameters\n        ----------\n        response : Message object\n            Sync response to parse and handle.\n\n        \"\"\"\n        assert response.id == mx_st.MX_ST_SYNC_CMD_QUEUE\n\n        if self._tx_sync_pending:\n            self._rx_sync = string_to_numbers(response.data)[0]\n            if self._is_in_sync():\n                self._tx_sync_pending = 0\n                self._is_sync.set()\n\n    def _is_in_sync(self) -> bool:\n        \"\"\"Tells if we're in sync with the latest \"get\" operation (i.e. we've received the response to the most recent\n           \"SyncCmdQueue\" request to the robot, meaning that the \"get\" response we just got is up-to-date)\n\n        Returns\n        -------\n        bool\n            True if \"in sync\" (\"get\" response we just received matches the \"get\" request we've just made)\n        \"\"\"\n        return self._rx_sync == self._tx_sync\n\n    def _sidecar_get_registered_functions(self, module_name: Optional[str] = None) -> list[Tuple[str, str]]:\n        \"\"\" Get a list of registered functions for the specified module, or all modules\n\n        Args:\n            module (Optional[str], optional):   Module to get registered functions too.\n                                                If none, will return registered functions in all modules.\n                                                Defaults to None.\n\n        Returns:\n            list[Tuple[str, str]]: List of tuple [module_name, function_name]\n        \"\"\"\n        registered_functions: list[Tuple[str, str]] = []\n        for function_name, function in self._sidecar_registered_functions.items():\n            if module_name is None or module_name == function.module_name:\n                registered_functions.append((function.module_name, function_name))\n        return registered_functions\n\n    def _sidecar_get_registered_function(self, function_name: str) -> Optional[rsc.RegisteredFunction]:\n        \"\"\"Get the definition of a registered sidecar function\n\n        Args:\n            function_name (str): Name of the function to get\n\n        Returns:\n            Optional[rsc.RegisteredFunction]: Registered function (or None if not found)\n        \"\"\"\n        if function_name in self._sidecar_registered_functions:\n            return self._sidecar_registered_functions[function_name]\n        return None\n\n    def _sidecar_call_registered_function(self, function_name, *args, **kwargs):\n        \"\"\" Call a sidecar registered function by name \"\"\"\n        if function_name not in self._sidecar_registered_functions:\n            user_msg = f'Failed to call sidecar function {function_name}, it is not registered'\n            self.LogTrace(user_msg, logging.ERROR)\n            raise NotFoundException(user_msg)\n        self._sidecar_registered_functions[function_name].function(*args, **kwargs)\n\n    def _sidecar_get_registered_attr(self, attr_name: str) -> any:\n        \"\"\" Callback for getting an attribute from local namespace \"\"\"\n        return getattr(_Robot, attr_name, None)\n\n    def _sidecar_set_registered_attr(self, attr_name: str, attr_val: any):\n        \"\"\" Callback for setting an attribute into local namespace \"\"\"\n        setattr(_Robot, attr_name, attr_val)\n\n    def _sidecar_del_registered_attr(self, attr_name: str):\n        \"\"\" Callback for deleting an attribute from local namespace \"\"\"\n        delattr(_Robot, attr_name)\n\n    def _sidecar_register_function(self,\n                                   function: rsc.RegisteredFunction,\n                                   original_function: Optional[callable] = None):\n        \"\"\" Common code for registering a function in our namespace.\n        This function is called in the following cases:\n        1. We're sidecar\n            1.1 We're registering a new function\n            1.2 We're overriding an existing function from this \"Robot\" class\n        2. We're not a sidecar (we're a normal Python application) and we've received an indication from the robot\n           that a sidecar has registered a custom function that we should make available in our namespace so it can\n           be called.\n\n        Args:\n            function (rsc.RegisteredFunction): The function to register\n            original_function (Optional[callable]): The original class method we're overriding. We need to store it so\n                                                    we can restore it later when unregistering the overriding one.\n\n        Raises:\n            PermissionError: Trying to register a function that's already registered\n        \"\"\"\n        # Make sure it does not already exist in among registered functions\n        if function.name in self._sidecar_registered_functions:\n            raise PermissionError((f'Cannot register function {function.name}, '\n                                   f'it is already registered by module '\n                                   f'{self._sidecar_registered_functions[function.name].module_name}'))\n        # Make sure it does not already exist in among cyclic IDs\n        if (function.cyclic_id is not None and function.cyclic_id > 0\n                and function.cyclic_id in self._registered_cyclic_id):\n            raise PermissionError((f'Cannot register function {function.name}, '\n                                   f'cyclic ID {function.cyclic_id} is already registered by '\n                                   f'{self._registered_cyclic_id[function.cyclic_id].name}'))\n\n        if self._sidecar_mode:\n            self._sidecar_register_to_robot(function)\n\n        # Define a wrapper that receives \"self\" and discard it before calling the registered function\n        def _registered_function_wrapper(*args: Tuple[any], **kwargs):\n            \"\"\" Function wrapper that retrieves the registered function from the dictionary, by name, and call it\n                with the provided arguments \"\"\"\n            #pylint: disable=protected-access\n            self._sidecar_call_registered_function(function.name, *args, **kwargs)\n\n        def _registered_function_wrapper_self(_, *args: Tuple[any], **kwargs):\n            \"\"\" Same as _registered_function_wrapper, but for cases where it's called from another method of this\n                class and thus receiving 'self' argument (which we discard here)\"\"\"\n            _registered_function_wrapper(*args, **kwargs)\n\n        # Decide if we must register the wrapper that receives \"self\" or not:\n        # - we will receive \"self\" when the function is registered as a member function of this robot class\n        # - we will not receive \"self\" when the function is registered as an attribute of a sub-member of the robot\n        #   class, thus when the function is registered with a prefix (like \"my_module.my_function\")\n        if \".\" in function.name:\n            nested_function = _registered_function_wrapper\n        else:\n            # We're registering directly as a class function, let's pass a wrapper because we'll receive \"self\" but\n            # the attached function does not expect it\n            nested_function = _registered_function_wrapper_self\n\n        # Add the function name to this class' namespace nested under prefix if appropriate\n        rsc.register_nested_function(function_full_name=function.name,\n                                     get_parent_attr=self._sidecar_get_registered_attr,\n                                     set_parent_attr=self._sidecar_set_registered_attr,\n                                     function=nested_function)\n\n        # Also attach as global function, allowing simple scripts to directly call the function\n        # like: my_module.my_function (instead of calling robot.my_module.my_function)\n        rgf.attach_global_function(_registered_function_wrapper, function.name)\n\n        # Insert into the hash of registered functions\n        self._sidecar_registered_functions[function.name] = function\n        if function.cyclic_id is not None and function.cyclic_id > 0:\n            self._registered_cyclic_id[function.cyclic_id] = function\n        if original_function is not None:\n            self._sidecar_overridden_functions[function.name] = original_function\n\n    def _sidecar_register_to_robot(self, function: rsc.RegisteredFunction):\n        \"\"\"Synchronously register a sidecar function with the robot (awaiting robot's response before continuing)\n\n        Args:\n            function (rsc.RegisteredFunction): The function to register\n\n        Raises:\n            TimeoutException: No robot response received\n            PermissionError: Robot refused the function registration (explanation found in exception message)\n        \"\"\"\n        failed = True\n        try:\n            # Send the register message to the robot, and wait the response\n            response = self._send_json_command(\n                '-SidecarRegisterFct',\n                function.to_dict(),\n                expected_responses=[mx_st.MX_ST_REGISTER_FCT_SUCCESS, mx_st.MX_ST_REGISTER_FCT_FAILURE],\n                timeout=2)\n        except TimeoutException as e:\n            failed = True\n            raise TimeoutException(\n                f'Failed to register function {function.name}: Timeout waiting for robot response') from e\n\n        # Analyze response\n        message = \"(unknown reason)\"\n        if response.json_data:\n            failed = response.id != mx_st.MX_ST_REGISTER_FCT_SUCCESS\n            json_data: dict = response.json_data.get(MX_JSON_KEY_DATA, {})\n            message = json_data.get(MX_JSON_KEY_SIDECAR_FCT_RSP_MSG, \"\")\n        if failed:\n            raise PermissionError(f'Failed to register function {function.name}: {message}')\n\n    def _sidecar_unregister_function(self, function_name: str):\n        \"\"\"Unregister a function that was previously registered\n        (unregister from robot class, and from global namespace robot_global_functions.py)\n\n        Args:\n            function_name (str): The name of the function to unregister\n        \"\"\"\n        if function_name not in self._sidecar_registered_functions:\n            return\n\n        # Use the helper to recursively unregister from our namespace (recursively because of prefixes)\n        rsc.unregister_nested_function(function_full_name=function_name,\n                                       get_parent_attr=self._sidecar_get_registered_attr,\n                                       del_parent_attr=self._sidecar_del_registered_attr)\n\n        # Remove from global namespace too\n        rgf.detach_global_function(function_name)\n\n        cyclic_id = self._sidecar_registered_functions[function_name].cyclic_id\n\n        # Remove from our dictionary of registered functions\n        del self._sidecar_registered_functions[function_name]\n        if function_name in self._sidecar_overridden_functions:\n            # Need to restore the original function that had been overridden but is no longer\n            self._sidecar_set_registered_attr(function_name, self._sidecar_overridden_functions[function_name])\n            del self._sidecar_overridden_functions[function_name]\n\n        # Remove from cyclic IDs\n        if cyclic_id is not None and cyclic_id > 0 and cyclic_id in self._registered_cyclic_id:\n            fct_or_var = self._registered_cyclic_id[cyclic_id]\n            if isinstance(fct_or_var, rsc.RegisteredFunction):\n                del self._registered_cyclic_id[cyclic_id]\n\n        if self._sidecar_mode and self.IsConnected():\n            # Notify the robot so the function is removed from the commands dictionary and no long available to users\n            self._sidecar_push_unregistered_fct_to_robot(function_name)\n\n    def _sidecar_push_unregistered_fct_to_robot(self, function_name: str):\n        \"\"\" Tell the robot about a registered function \"\"\"\n        self._send_json_command('-SidecarUnregisterFct', {\"name\": function_name})\n\n    def _register_variable(self, variable: rsc.RegisteredVariable):\n        \"\"\" Called when the robot reports an existing variable \"\"\"\n        self._registered_vars_by_name[variable.name] = variable\n        if variable.cyclic_id is not None and variable.cyclic_id > 0:\n            self._registered_cyclic_id[variable.cyclic_id] = variable\n\n        # Also register in the variables container\n        self.vars.register_attribute(variable.name, variable.name)\n\n    def _unregister_variable(self, name: str) -> any:\n        \"\"\"Delete a variable previously registered with RegisterVariable\n\n        Args:\n            name (str): Name of the variable to unregister\n\n        Returns:\n            any: The variable value before it gets deleted\n        \"\"\"\n        old_value = None\n        if name in self._registered_vars_by_name:\n            variable = self._registered_vars_by_name[name]\n            old_value = variable.get_value()\n\n            # Unregister from the variables container\n            self.vars.unregister_attribute(name)\n\n            # Unlink from this class\n            del self._registered_vars_by_name[name]\n\n            # Remove from map by cyclic ID\n            if variable.cyclic_id is not None and variable.cyclic_id > 0:\n                var = self.GetVariableByCyclicId(variable.cyclic_id)\n                if var:\n                    del self._registered_cyclic_id[variable.cyclic_id]\n\n        return old_value\n\n    def _get_variable(self, name: str) -> Optional[any]:\n        \"\"\" Attribute container callback used to get a variable value when someone calls robot.vars.X to access\n            variable X\"\"\"\n        if name not in self._registered_vars_by_name:\n            return None\n        return self._registered_vars_by_name[name]\n\n    def _set_variable(self, name: str, value: any) -> any:\n        \"\"\" Attribute container callback used to set a variable value when someone calls robot.vars.X=val to modify\n            variable X\"\"\"\n        # Make sure to get the nested value if object is type RegisteredVariable\n        if isinstance(value, rsc.RegisteredVariable):\n            value = value.get_value()\n\n        # Get a copy of the previous value\n        prev_val = copy.deepcopy(value)\n\n        # Perform a \"blocking\" SetVariable operation with the robot\n        self.SetVariable(name, value, self.default_timeout)\n\n        # Note: At this point our local copy of the variable will have been updated through _handle_variable_added\n        # that is called after the robot sent a confirmation event for modified variable.\n\n        return prev_val\n\n    def _register_robot_sidecar_cmd(self, function_name: str, cmd_def: dict):\n        \"\"\"Register into the current namespace a function that a remote sidecar just registered on the robot.\n            This way, this function can be called on the robot object in current application,\n            for example robot.some_sidecar_module.some_sidecar_function(some_args)\n\n        Args:\n            function_name (str): Name of the function to register\n            cmd_def (dict): Description of the function as provided by the robot's command dictionary API\n        \"\"\"\n        # Make sure it does not already exist in in the robot class\n        exists = hasattr(_Robot, function_name)\n        if exists:\n            self.logger.error(f'Trying to register function {function_name} but it already exists in Robot class')\n            return\n\n        # Define a wrapper that will call the robot's registered function whenever someone is calling that function\n        # in our namespace. The robot will then forward our request to the sidecar which registered it, that sidecar\n        # will execute the command with the arguments we're passing along.\n        def _sidecar_cmd_wrapper(*args, **kwargs):\n            # Combine positional and keyword arguments into a single dictionary\n            json_data: dict = {MX_JSON_KEY_SIDECAR_FCT_EXEC_ARGS: args, MX_JSON_KEY_SIDECAR_FCT_EXEC_KWARGS: kwargs}\n\n            self._send_json_command(function_name, json_data)\n\n        # Build a RegisteredFunction object from the command definition received from the robot for this command\n        # newly registered from a sidecar\n        function = rsc.RegisteredFunction.from_robot_cmd_def(function=_sidecar_cmd_wrapper,\n                                                             name=function_name,\n                                                             cmd_def=cmd_def)\n\n        # Insert the registered function into our namespace\n        self._sidecar_register_function(function)\n\n    def _handle_dict_cmd_added(self, message: Message):\n        \"\"\"Handle a message listing one API function available on the robot.\n\n        Parameters\n        ----------\n        message : Message object that describes the robot registered command\n\n        \"\"\"\n        if self._sidecar_mode:\n            # We are the sidecar, let's ignore this\n            return\n\n        if not message.json_data:\n            # Should not happen\n            return\n\n        # Get the function name from the JSON message\n        json_data: dict = message.json_data.get(MX_JSON_KEY_DATA, {})\n\n        # Register all new commands provided by the robot\n        for function_name, cmd_def in json_data.items():\n            sidecar_id: int = int(cmd_def.get(MX_JSON_KEY_SIDECAR_FCT_SIDECAR_ID, 0))\n\n            if sidecar_id != 0 and function_name not in self._sidecar_registered_functions:\n                self._register_robot_sidecar_cmd(function_name, cmd_def)\n\n    def _handle_dict_cmd_removed(self, message: Message):\n        \"\"\"Handle a message indicating that the robot no longer has the specified API function.\n\n        Parameters\n        ----------\n        message : Message object that contains the name of the functions to unregister\n\n        \"\"\"\n        if self._sidecar_mode:\n            # We are the sidecar, let's ignore this\n            return\n\n        if not message.json_data:\n            # Should not happen\n            return\n\n        # Get the function name from the JSON message\n        json_data: dict = message.json_data.get(MX_JSON_KEY_DATA, {})\n\n        # Unregister from our namespace all commands that are no longer available on the robot\n        for function_name, _ in json_data.items():\n            self._sidecar_unregister_function(function_name)\n\n    def _handle_sidecar_status(self, message: Message):\n        \"\"\"Handle the message that indicates the sidecar scripting engines status.\n\n        Parameters\n        ----------\n        message : Message object that contains the status of all connected scripting engines\n        \"\"\"\n        if not message.json_data:\n            # Should not happen\n            return\n\n        # Get the function name from the JSON message\n        json_data: dict[str, dict] = message.json_data.get(MX_JSON_KEY_DATA, {})\n\n        self._sidecar_status = []\n        for _, json_sidecar in json_data.items():\n            sidecar_status = RobotSidecarStatus()\n\n            sidecar_status.id = json_sidecar.get(MX_JSON_KEY_SIDECAR_STATUS_ID, None)\n            sidecar_status.embedded = bool(json_sidecar.get(MX_JSON_KEY_SIDECAR_STATUS_EMBEDDED, False))\n            sidecar_status.remote_ip = str(json_sidecar.get(MX_JSON_KEY_SIDECAR_STATUS_REMOTE_IP, \"\"))\n            if (MX_JSON_KEY_SIDECAR_STATUS_FUNCTIONS in json_sidecar\n                    and isinstance(json_sidecar[MX_JSON_KEY_SIDECAR_STATUS_FUNCTIONS], list)):\n                sidecar_status.registered_functions = json_sidecar[MX_JSON_KEY_SIDECAR_STATUS_FUNCTIONS]\n\n            self._sidecar_status.append(sidecar_status)\n\n    def _handle_variable_added(self, message: Message):\n        \"\"\"Handle a message indicating that variables were created or modified on the robot (also called as connection)\n\n        Parameters\n        ----------\n        message : Message object that describes all the variables that were created or modified\n\n        \"\"\"\n        if not message.json_data:\n            # Should not happen\n            return\n\n        json_data: dict = message.json_data.get(MX_JSON_KEY_DATA, {})\n\n        variables: dict[str, dict] = json_data.get(MX_JSON_KEY_VAR_LIST, {})\n        for name, var in variables.items():\n            value = var.get(MX_JSON_KEY_VAR_VAL)\n            cyclic_id = var.get(MX_JSON_KEY_VAR_CYCLIC_ID, None)\n            if name in self._registered_vars_by_name:\n                # Update the variable value\n                registered_var = self._registered_vars_by_name[name]\n                registered_var.set_value(value)\n\n                # Update the cyclic ID if appropriate\n                if registered_var.cyclic_id != cyclic_id:\n                    # Delete old cyclic ID from map\n                    if registered_var.cyclic_id is not None:\n                        var_cyclic = self.GetVariableByCyclicId(registered_var.cyclic_id)\n                        if var_cyclic:\n                            del self._registered_cyclic_id[registered_var.cyclic_id]\n\n                    # Update cyclic ID in variable\n                    registered_var.cyclic_id = cyclic_id\n\n                    # Insert the variable back into the cyclic ID map\n                    if cyclic_id is not None and cyclic_id > 0:\n                        self._registered_cyclic_id[cyclic_id] = registered_var\n            else:\n                # Register a new variable\n                variable = rsc.RegisteredVariable(name=name, default=value, cyclic_id=cyclic_id)\n                self._register_variable(variable)\n\n    def _handle_variable_removed(self, message: Message):\n        \"\"\"Handle a message indicating that variables were deleted on the robot\n\n        Parameters\n        ----------\n        message : Message object that describes all the variables that were removed\n\n        \"\"\"\n        if not message.json_data:\n            # Should not happen\n            return\n\n        json_data: dict = message.json_data.get(MX_JSON_KEY_DATA, {})\n\n        variables: dict[str, dict] = json_data.get(MX_JSON_KEY_VAR_LIST, {})\n        for name, _ in variables.items():\n            self._unregister_variable(name)",
    "span": [
      388,
      5949
    ],
    "start_byte": 14737,
    "end_byte": 274235,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/_robot_base.py",
    "name": "_Robot"
  }
]