[
  {
    "snippet": "import contextlib",
    "span": [
      10,
      10
    ],
    "start_byte": 330,
    "end_byte": 347,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "import pathlib",
    "span": [
      11,
      11
    ],
    "start_byte": 348,
    "end_byte": 362,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "import sys",
    "span": [
      12,
      12
    ],
    "start_byte": 363,
    "end_byte": 373,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "from typing import Optional, Tuple, Union",
    "span": [
      13,
      13
    ],
    "start_byte": 374,
    "end_byte": 415,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "import deprecation",
    "span": [
      15,
      15
    ],
    "start_byte": 417,
    "end_byte": 435,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "import mecademicpy.robot_sidecar_classes as rsc",
    "span": [
      17,
      17
    ],
    "start_byte": 437,
    "end_byte": 484,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "from ._robot_base import _Robot, disconnect_on_exception_decorator",
    "span": [
      19,
      19
    ],
    "start_byte": 486,
    "end_byte": 552,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "from .mx_robot_def import *",
    "span": [
      20,
      20
    ],
    "start_byte": 553,
    "end_byte": 580,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "from .robot_classes import *",
    "span": [
      21,
      21
    ],
    "start_byte": 581,
    "end_byte": 609,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "from .robot_trajectory_files import RobotTrajectories",
    "span": [
      22,
      22
    ],
    "start_byte": 610,
    "end_byte": 663,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "from .tools import *",
    "span": [
      23,
      23
    ],
    "start_byte": 664,
    "end_byte": 684,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py"
  },
  {
    "snippet": "class Robot(_Robot):\n    \"\"\"Class for controlling a Mecademic robot.\n       See README.md for quick instructions on how to use this class.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        self._enable_synchronous_mode = False\n\n    def RegisterCallbacks(self, callbacks: RobotCallbacks, run_callbacks_in_separate_thread: bool):\n        \"\"\"Register callback functions to be executed when corresponding event occurs.\n           Callback functions are optional.\n           This function must be used before connecting to the robot.\n           To attach/detect individual callbacks after connecting to the robot, use RegisterCallback/UnregisterCallback\n\n        Parameters\n        ----------\n        callbacks : RobotCallbacks object\n            Object containing all callback functions.\n        run_callbacks_in_separate_thread : bool\n            If true, callbacks are run automatically in thread. If false, RunCallbacks must be used.\n            **Running callbacks in a separate thread means the user application MUST BE THREAD SAFE!**\n        \"\"\"\n        return super().RegisterCallbacks(callbacks, run_callbacks_in_separate_thread)\n\n    def RegisterCallback(self, callback_name: str, callback_method: Callable[[], None]):\n        \"\"\"Register one callback functions to be executed when corresponding event occurs.\n           Callback functions are optional.\n\n        Parameters\n        ----------\n        callback_name : Name of the callback to attach. Refer to class RobotCallbacks for available callbacks.\n        callback_method : Callback method to attach to the specified callback.\n        \"\"\"\n        return super().RegisterCallback(callback_name, callback_method)\n\n    def UnregisterCallbacks(self):\n        \"\"\"Unregister callback functions and terminate callback handler thread if applicable.\n\n        \"\"\"\n        return super().UnregisterCallbacks()\n\n    def UnregisterCallback(self, callback_name: str):\n        \"\"\"Unregister one callback functions.\n\n        Parameters\n        ----------\n        callback_name : Name of the callback to unregister. Refer to class RobotCallbacks for available callbacks.\n        \"\"\"\n        return super().UnregisterCallback(callback_name)\n\n    def RunCallbacks(self):\n        \"\"\"Run all triggered callback functions.\n           Calling this function is required only when RegisterCallback option run_callbacks_in_separate_thread\n           has been set to False (when True, callbacks are automatically called from a background thread).\n\n        \"\"\"\n        if self._callback_thread:\n            raise InvalidStateError(\n                'Cannot call RunCallbacks since callback handler is already running in separate thread.')\n\n        # Setting timeout=0 means we don't block on an empty queue.\n        self._handle_callbacks(polling=True)\n\n    def Connect(self,\n                address: str = MX_DEFAULT_ROBOT_IP,\n                enable_synchronous_mode: bool = False,\n                disconnect_on_exception: bool = True,\n                monitor_mode: bool = False,\n                timeout=1.0):\n        \"\"\"Attempt to connect to a Mecademic Robot.\n           This function is synchronous (awaits for success or timeout) even when using this class in asynchronous mode\n           (see enable_synchronous_mode below).\n\n        Parameters\n        ----------\n        address : string\n            The IP address associated to the Mecademic Robot.\n        enable_synchronous_mode : bool\n            Select synchronous or asynchronous mode for this class.\n            See SetSynchronousMode for details.\n        disconnect_on_exception : bool\n            If true, will attempt to disconnect from the robot on exception from api call.\n            Also note that the robot will automatically pause motion whenever a disconnection occurs.\n        monitor_mode : bool\n            If true, command connection will not be established, only monitoring connection.\n        timeout : float\n            Time allowed to try connecting to the robot before this function returns.\n\n        \"\"\"\n        return super()._Connect(address,\n                                enable_synchronous_mode,\n                                disconnect_on_exception,\n                                monitor_mode,\n                                offline_mode=False,\n                                timeout=timeout)\n\n    def Disconnect(self):\n        \"\"\"Disconnects Mecademic Robot object from the Mecademic robot.\n           This function is synchronous (awaits for disconnection or timeout) even when connected in asynchronous mode.\n\n        \"\"\"\n        return super().Disconnect()\n\n    def IsConnected(self) -> bool:\n        \"\"\"Tells if we're actually connected to the robot\"\"\"\n        return super().IsConnected()\n\n    def IsControlling(self) -> bool:\n        \"\"\"Tells if we're actually connected to the robot in 'control' mode \"\"\"\n        return super().IsControlling()\n\n    def IsSynchronousMode(self) -> bool:\n        \"\"\"Tells if we're actually connected to the robot in 'synchronous' mode\n            (see doc for method Connect for details) \"\"\"\n        return super().IsSynchronousMode()\n\n    # mx:export_to=robot_sidecar_globals.py\n    def IsAllowedToMove(self) -> bool:\n        \"\"\"Tells if the robot is currently allowed to be moved (i.e. homed, or activated in recovery mode)\"\"\"\n        can_move = False\n        with self._main_lock:\n            can_move = self._robot_status.homing_state or (self._robot_status.activation_state\n                                                           and self._robot_events.on_activate_recovery_mode.is_set())\n        return can_move\n\n    def SetSynchronousMode(self, sync_mode: bool = True):\n        \"\"\"Changes synchronous mode option.\n           If True, function calls in this class will be blocking until the robot has finished executing the\n           command. Note that no blending is possible in this mode.\n           If False, function calls in this class will post requests to the robot and return immediately before\n           the robot has received/processed the commands.\n           Method WaitIdle (among other things) can be used in that case to wait for robot to complete posted commands.\n\n           Note that disabling synchronous mode will not awake thread already awaiting on synchronous operations.\n\n        Parameters\n        ----------\n        sync_mode : bool, optional\n            Synchronous mode enabled (else asynchronous mode), by default True\n        \"\"\"\n        self._enable_synchronous_mode = sync_mode\n\n    def Sync(self):\n        \"\"\" Synchronize with the robot (send a request and await for the response).\n            This can be useful to make sure that no response from previous asynchronous requests are in the network\n            pipeline and would be received later.\n            Note: This Sync method is only valid for synchronization with commands that get an immediate response.\n                  It will not work with commands related to the motion queue because their response may be received\n                  asynchronously later (after the response to this \"Sync\")\n        \"\"\"\n        self._send_sync_command(command=None)  # Note: This will simply send the \"sync\" command\n\n    def ConnectionWatchdog(self, timeout: float, message: Optional[str] = None):\n        \"\"\"Enable, refresh or disable the connection watchdog.\n           This function is non-blocking.\n\n           To enable the connection watchdog, call this function with a non-zero timeout.\n           Then periodically call this function again with a non-zero timeout before expiry of previous timeout.\n           To disable the connection watchdog, call this function with a timeout of zero.\n\n           If the connection watchdog is enabled and the robot does not receive a refresh before the specified timeout,\n           it will close the socket connections with this application, raise MX_SAFE_STOP_CONNECTION_DROPPED safety\n           stop condition and pause motion (if robot is activated).\n\n           Note that if the connection watchdog is not enabled but the socket is closed while the robot is moving,\n           the robot will also raise the MX_SAFE_STOP_CONNECTION_DROPPED safety stop condition and pause motion.\n           But note that a socket may take a very long time to detect a dropped connection upon some type of network\n           failures and thus usage of the connection watchdog feature is recommended to ensure that the robot quickly\n           stops moving in all situations when the application can no longer communicate with it.\n\n           The application may validate that the connection watchdog is active on the robot using the watchdog state,\n           located in RobotStatus.connection_watchdog_active.\n\n        Args:\n            timeout (float): Connection watchdog timeout (in seconds) to enable/refresh (or 0 to disable the watchdog)\n            message (Optional[str]): Optional message to print in the robot log in case the connection times-out after\n                                     this call to ConnectionWatchdog. This can be used to help determine what the\n                                     application was doing when the connection has timed out.\n        \"\"\"\n        return super().ConnectionWatchdog(timeout, message)\n\n    def AutoConnectionWatchdog(self, enable: bool, timeout: float = 0, message: Optional[str] = None):\n        \"\"\"Enable automatic connection watchdog managed by this Robot class.\n           See method ConnectionWatchdog for detailed explanations about the connection watchdog.\n\n           The automatic connection watchdog is an alternative to ConnectionWatchdog which is simpler for the\n           application because it does not have to manage periodic calling of ConnectionWatchdog to refresh the timer.\n\n           When automatic connection watchdog is enabled, the Robot class will automatically enable then refresh the\n           connection watchdog by calling ConnectionWatchdog at appropriate intervals.\n           The connection timeout is automatically chosen based on monitoring interval (see SetMonitoringInterval).\n\n        Args:\n            enable (bool): Enable (else disable) the automatic connection watchdog refresh\n            timeout (float): Connection watchdog to set as a last call to the robot by this function.\n                             Default is 0 (connection watchdog is completely disabled).\n                             If non-zero, don't forget to call ConnectionWatchdog afterwards because the watchdog will\n                             still be active on the robot.\n            message (Optional[str]): See ConnectionWatchdog for details\n        \"\"\"\n        return super().AutoConnectionWatchdog(enable, timeout, message)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def ActivateRobot(self):\n        \"\"\"Activate the robot.\"\"\"\n        return super().ActivateRobot()\n\n    # mx:export_to=robot_sidecar_globals.py\n    def DeactivateRobot(self):\n        \"\"\"Deactivate the robot.\"\"\"\n        return super().DeactivateRobot()\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def Home(self):\n        \"\"\"Home the robot.\"\"\"\n        return super().Home()\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def ActivateAndHome(self):\n        \"\"\"Utility function that combines activate and home.\"\"\"\n        super().ActivateRobot()\n        super().Home()\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def PauseMotion(self):\n        \"\"\"Immediately pause robot motion. \"\"\"\n        return super().PauseMotion()\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def ResumeMotion(self):\n        \"\"\"Un-pause robot motion.\"\"\"\n        return super().ResumeMotion()\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def ClearMotion(self):\n        \"\"\"Clear the motion queue, includes implicit PauseMotion command.\"\"\"\n        return super().ClearMotion()\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MoveJoints(self, *args: float):\n        \"\"\"Move the robot by specifying each joint's target angular position.\n\n        Parameters\n        ----------\n        joint_1...joint_n : float\n            Desired joint angles in degrees.\n\n        \"\"\"\n        expect_count = self._robot_info.num_joints\n        if len(args) != expect_count:\n            raise ValueError(\n                f'MoveJoints: Incorrect number of joints sent {len(args)}, command. expecting: {expect_count}.')\n\n        self._send_motion_command('MoveJoints', args)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MoveJointsRel(self, *args: float):\n        \"\"\"Move the robot relative to current position by specifying each joint's offset angular position.\n\n        Parameters\n        ----------\n        joint_1...joint_n : float\n            Desired joint angles offsets in degrees.\n\n        \"\"\"\n        expect_count = self._robot_info.num_joints\n        if len(args) != expect_count:\n            raise ValueError(\n                f'MoveJointsRel: Incorrect number of joints sent {len(args)}, command. expecting: {expect_count}.')\n\n        self._send_motion_command('MoveJointsRel', args)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MoveJointsVel(self, *args: float):\n        \"\"\"Moves joints at desired velocities.\n\n        Parameters\n        ----------\n        joint_1...joint_n : float\n            Desired joint velocities in degrees per second.\n\n        \"\"\"\n        expect_count = self._robot_info.num_joints\n        if len(args) != expect_count:\n            raise ValueError(\n                f'MoveJointsVel: Incorrect number of joints sent {len(args)}, command. expecting: {expect_count}.')\n\n        self._send_motion_command('MoveJointsVel', args)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MovePose(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Move robot's tool to an absolute Cartesian position (non-linear move, but all joints arrive simultaneously).\n\n        Parameters\n        ----------\n        x, y, z : float\n            Desired end effector coordinates in mm.\n        alpha, beta, gamma\n            Desired end effector orientation in degrees.\n            On 4-axes robots (like Mcs500), alpha and beta values are not used and can be omitted.\n            Examples for 4-axes robots:\n                - MovePose(200, 10, 100, 45)\n                - MovePose(200, 10, 100, gamma=45)\n\n        \"\"\"\n        [alpha, beta, gamma] = self._normalize_cart_cmd_args(alpha, beta, gamma)\n        self._send_motion_command('MovePose', [x, y, z, alpha, beta, gamma])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MoveJump(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Move robot to desired position but performing an arch of specified height between start and end positions.\n        This command is similar to MovePose (i.e. using quickest non-linear path).\n        The jump height parameters are configured using SetMoveJumpHeight and SetMoveJumpApproachVel.\n        This command is very useful for 'pick-and-place' applications.\n\n        Parameters\n        ----------\n        x, y, z : float\n            Desired end effector coordinates in mm.\n        alpha, beta, gamma\n            Desired end effector orientation in degrees.\n            On 4-axes robots (like Mcs500), alpha and beta values are not used and can be omitted.\n            Examples for 4-axes robots:\n                - MoveJump(200, 10, 100, 45)\n                - MoveJump(200, 10, 100, gamma=45)\n\n        \"\"\"\n        [alpha, beta, gamma] = self._normalize_cart_cmd_args(alpha, beta, gamma)\n        self._send_motion_command('MoveJump', [x, y, z, alpha, beta, gamma])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MoveLin(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Linearly move robot's tool to an absolute Cartesian position.\n\n        Parameters\n        ----------\n        x, y, z : float\n            Desired end effector coordinates in mm.\n        alpha, beta, gamma\n            Desired end effector orientation in degrees.\n            On 4-axes robots (like Mcs500), alpha and beta values are not used and can be omitted.\n            Examples for 4-axes robots:\n                - MoveLin(200, 10, 100, 45)\n                - MoveLin(200, 10, 100, gamma=45)\n\n        \"\"\"\n        [alpha, beta, gamma] = self._normalize_cart_cmd_args(alpha, beta, gamma)\n        self._send_motion_command('MoveLin', [x, y, z, alpha, beta, gamma])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MoveLinRelTrf(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Linearly move robot's tool to a Cartesian position relative to current TRF position.\n\n        Parameters\n        ----------\n        x, y, z : float\n            Desired displacement in mm.\n        alpha, beta, gamma\n            Desired orientation change in deg.\n            On 4-axes robots (like Mcs500), alpha and beta values are not used and can be omitted.\n            Examples for 4-axes robots:\n                - MoveLinRelTrf(200, 10, 100, 45)\n                - MoveLinRelTrf(200, 10, 100, gamma=45)\n\n        \"\"\"\n        [alpha, beta, gamma] = self._normalize_cart_cmd_args(alpha, beta, gamma)\n        self._send_motion_command('MoveLinRelTrf', [x, y, z, alpha, beta, gamma])\n\n    @deprecation.deprecated(deprecated_in=\"1.2.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'MoveLinRelTrf' function instead\")\n    @disconnect_on_exception_decorator\n    def MoveLinRelTRF(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Deprecated use MoveLinRelTrf instead.\n        \"\"\"\n        self.MoveLinRelTrf(x, y, z, alpha, beta, gamma)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MoveLinRelWrf(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Linearly move robot's tool to a Cartesian position relative to a reference frame that has the same\n        orientation.\n\n        Parameters\n        ----------\n        x, y, z : float\n            Desired displacement in mm.\n        alpha, beta, gamma\n            Desired orientation change in deg.\n            On 4-axes robots (like Mcs500), alpha and beta values are not used and can be omitted.\n            Examples for 4-axes robots:\n                - MoveLinRelWrf(200, 10, 100, 45)\n                - MoveLinRelWrf(200, 10, 100, gamma=45)\n\n        \"\"\"\n        [alpha, beta, gamma] = self._normalize_cart_cmd_args(alpha, beta, gamma)\n        self._send_motion_command('MoveLinRelWrf', [x, y, z, alpha, beta, gamma])\n\n    @deprecation.deprecated(deprecated_in=\"1.2.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'MoveLinRelWrf' function instead\")\n    @disconnect_on_exception_decorator\n    def MoveLinRelWRF(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Deprecated use MoveLinRelWrf instead.\n        \"\"\"\n        self.MoveLinRelWrf(x, y, z, alpha, beta, gamma)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MoveLinVelTrf(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Move robot's by Cartesian velocity relative to the TRF.\n\n           Joints will move for a time controlled by velocity timeout (SetVelTimeout).\n\n        Parameters\n        ----------\n        x, y, z : float\n            Desired velocity in mm/s.\n        alpha, beta, gamma\n            Desired angular velocity in degrees/s.\n            On 4-axes robots (like Mcs500), alpha and beta values are not used and can be omitted.\n            Examples for 4-axes robots:\n                - MoveLinVelTrf(200, 10, 100, 45)\n                - MoveLinVelTrf(200, 10, 100, gamma=45)\n\n        \"\"\"\n        [alpha, beta, gamma] = self._normalize_cart_cmd_args(alpha, beta, gamma)\n        self._send_motion_command('MoveLinVelTrf', [x, y, z, alpha, beta, gamma])\n\n    @deprecation.deprecated(deprecated_in=\"1.2.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'MoveLinVelTrf' function instead\")\n    @disconnect_on_exception_decorator\n    def MoveLinVelTRF(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Deprecated use MoveLinVelTrf instead\n\n        \"\"\"\n        self.MoveLinVelTrf(x, y, z, alpha, beta, gamma)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MoveLinVelWrf(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Move robot's by Cartesian velocity relative to the WRF.\n\n           Joints will move for a time controlled by velocity timeout (SetVelTimeout).\n\n        Parameters\n        ----------\n        x, y, z : float\n            Desired velocity in mm/s.\n        alpha, beta, gamma\n            Desired angular velocity in degrees/s.\n            On 4-axes robots (like Mcs500), alpha and beta values are not used and can be omitted.\n            Examples for 4-axes robots:\n                - MoveLinVelWrf(200, 10, 100, 45)\n                - MoveLinVelWrf(200, 10, 100, gamma=45)\n\n        \"\"\"\n        [alpha, beta, gamma] = self._normalize_cart_cmd_args(alpha, beta, gamma)\n        self._send_motion_command('MoveLinVelWrf', [x, y, z, alpha, beta, gamma])\n\n    @deprecation.deprecated(deprecated_in=\"1.2.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'MoveLinVelWrf' function instead\")\n    @disconnect_on_exception_decorator\n    def MoveLinVelWRF(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Deprecated use MoveLinVelWrf instead\n\n        \"\"\"\n        self.MoveLinVelWrf(x, y, z, alpha, beta, gamma)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetVelTimeout(self, t: float):\n        \"\"\"Maximum time the robot will continue to move after a velocity move command was sent.\n\n        (Can be stopped earlier by sending a velocity command with 0 velocity values.)\n\n        Parameters\n        ----------\n        t : float\n            Desired duration for velocity-mode motion commands.\n\n        \"\"\"\n        self._send_motion_command('SetVelTimeout', [t])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetConf(self, shoulder: int = None, elbow: int = None, wrist: int = None):\n        \"\"\"Manually set inverse kinematics options (and disable auto-conf).\n            On 4-axes robots (like Mcs500), shoulder and wrist values are not used and can be omitted.\n            Examples for 4-axes robots:\n                - SetConf(1)\n                - SetConf(elbow=1)\n\n        Parameters\n        ----------\n        shoulder : +1 or -1\n            Shoulder inverse kinematics parameter.\n        elbow : +1 or -1\n            Elbow inverse kinematics parameter.\n        wrist : +1 or -1\n            Wrist inverse kinematics parameter.\n\n        \"\"\"\n        [shoulder, elbow, wrist] = self._normalize_conf_cmd_args(shoulder, elbow, wrist)\n        self._send_motion_command('SetConf', [shoulder, elbow, wrist])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetAutoConf(self, e: int):\n        \"\"\"Enable or disable auto-conf (automatic selection of inverse kinematics options).\n\n        Parameters\n        ----------\n        e : bool\n            If true, robot will automatically choose the best configuration for the desired pose.\n\n        \"\"\"\n        self._send_motion_command('SetAutoConf', [int(e)])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetConfTurn(self, n: int):\n        \"\"\"Manually set the last joint turn configuration parameter.\n\n        Parameters\n        ----------\n        n : integer\n            The turn number for joint 6.\n\n        \"\"\"\n        self._send_motion_command('SetConfTurn', [n])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetAutoConfTurn(self, e: int):\n        \"\"\"Enable or disable auto-conf (automatic selection of inverse kinematics options) for joint 6.\n\n        Parameters\n        ----------\n        e : bool\n            If true, robot will automatically choose the best configuration for the desired pose.\n\n        \"\"\"\n        self._send_motion_command('SetAutoConfTurn', [int(e)])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetBlending(self, p: float):\n        \"\"\"Set percentage of blending between consecutive movements in the same mode (velocity or cartesian).\n\n        Note: There can't be blending between joint mode and Cartesian mode moves.\n\n        Parameters\n        ----------\n        p : float\n            Percentage blending between actions.\n\n        \"\"\"\n        self._send_motion_command('SetBlending', [p])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetCartAcc(self, p: float):\n        \"\"\"Set target acceleration (linear and angular) during MoveLin commands.\n\n        Parameters\n        ----------\n        p : float\n            Percentage of maximum acceleration.\n\n        \"\"\"\n        self._send_motion_command('SetCartAcc', [p])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetCartAngVel(self, w: float):\n        \"\"\"Set maximum angular velocity during MoveLin commands.\n\n        Note: Actual angular velocity may be lower if necessary to avoid exceeding maximum joint velocity.\n\n        Parameters\n        ----------\n        w : float\n            Maximum angular velocity in deg/s.\n\n        \"\"\"\n        self._send_motion_command('SetCartAngVel', [w])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetCartLinVel(self, v: float):\n        \"\"\"Set maximum linear velocity during MoveLin commands.\n\n        Note: Actual linear velocity may be lower if necessary to avoid exceeding maximum joint velocity.\n\n        Parameters\n        ----------\n        v : float\n            Maximum angular velocity in deg/s.\n\n        \"\"\"\n        self._send_motion_command('SetCartLinVel', [v])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetJointAcc(self, p: float):\n        \"\"\"Set target joint acceleration during MoveJoints commands.\n\n        Parameters\n        ----------\n        p : float\n            Target acceleration, in percent.\n\n        \"\"\"\n        self._send_motion_command('SetJointAcc', [p])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetJointVel(self, p: float):\n        \"\"\"Set target joint velocity during MoveJoints commands.\n\n        Parameters\n        ----------\n        p : float\n            Target joint velocity, in percent.\n\n        \"\"\"\n        self._send_motion_command('SetJointVel', [p])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetJointVelLimit(self, p: float):\n        \"\"\"Change the safety joint velocity limit that is applied to all type of moves.\n        In joint space:     The joints velocity will be capped to this limit\n                            even if SetJointVel or MoveJointsVel request higher speed.\n        With linear moves:  The joints velocity will be capped to this limit regardless of the requested\n                            linear or angular velocity.\n\n        Parameters\n        ----------\n        p : float\n            Joint velocity limit in percent.\n\n        \"\"\"\n        self._send_motion_command('SetJointVelLimit', [p])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetMoveMode(self, mode=MxMoveMode.MX_MOVE_MODE_VELOCITY):\n        \"\"\"Select the current move mode (velocity-based or time-based) for following mode commands.\n        The default mode when robot is activated is velocity-based.\n\n        Parameters\n        ----------\n        mode : MxMoveMode\n            The move mode to use.\n\n        \"\"\"\n        self._send_motion_command('SetMoveMode', [mode])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetMoveDurationCfg(self, severity=MxEventSeverity.MX_EVENT_SEVERITY_WARNING):\n        \"\"\"Set the configuration of the time-based movements.\n\n        Parameters\n        ----------\n        severity : MxEventSeverity\n            Severity level when the requested move duration is too short for the robot.\n\n        \"\"\"\n        self._send_motion_command('SetMoveDurationCfg', [severity])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetMoveDuration(self, t: float):\n        \"\"\"Set the duration of move commands when the move mode is time-based (see SetMoveMove).\n\n        Parameters\n        ----------\n        t : float\n            Move duration in seconds.\n\n        \"\"\"\n        self._send_motion_command('SetMoveDuration', [t])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    # pylint: disable=invalid-name\n    def SetMoveJumpHeight(self,\n                          startHeight: float = MX_MOVE_JUMP_DEFAULT_HEIGHT_MM,\n                          endHeight: float = MX_MOVE_JUMP_DEFAULT_HEIGHT_MM,\n                          minHeight: float = 0,\n                          maxHeight: float = 102):\n        \"\"\"Set height parameters for the MoveJump command (in mm).\n        Height parameters control how high the robot moves vertically at start, middle and end.\n        Height values provided can be positive or negative (relative to WRF's Z axis).\n        Space between minimum and maximum allows the robot flexibility to choose the optimal path.\n        An error is raised if joint limits prevent the robot from respecting minimum heights.\n\n        Parameters\n        ----------\n        startHeight : float\n            Height (in mm) to move from start position before starting lateral move, relative to starting position.\n        endHeight : float\n            Height (in mm) to reach after lateral move, before moving down to end position, relative to end position.\n        minHeight : float\n            Minimum height (in mm) to reach while performing the lateral move, applied to both,\n            start and end of the jump, relative to start/end position respectively.\n        maxHeight : float\n            Maximum height (in mm) allowed along the whole MoveJump path, applied to both,\n            start and end of the jump, relative to start/end position respectively.\n            The robot may not reach that height if optimal path does not need to go that high.\n\n        \"\"\"\n        self._send_motion_command('SetMoveJumpHeight', [startHeight, endHeight, minHeight, maxHeight])\n\n    # mx:export_to=robot_sidecar_globals.py\n    #pylint: disable=invalid-name\n    @disconnect_on_exception_decorator\n    def SetMoveJumpApproachVel(self,\n                               startVel: float = MX_MOVE_JUMP_DEFAULT_APPROACH_VEL_MM_SEC,\n                               startDist: float = MX_MOVE_JUMP_DEFAULT_APPROACH_DIST_MM,\n                               endVel: float = MX_MOVE_JUMP_DEFAULT_APPROACH_VEL_MM_SEC,\n                               endDist: float = MX_MOVE_JUMP_DEFAULT_APPROACH_DIST_MM):\n        \"\"\"Set the maximum allowed velocity (and length) of the start and end approach of a MoveJump.\n        This allows the robot to move slower than configured joint velocity for some distance from\n        start and end points, during the 'vertical' portion of the MoveJump.\n        This is a velocity limit i.e. it will have an effect only if slower than current JointVel.\n\n        Parameters\n        ----------\n        startVel : float\n            Maximum velocity (in mm/s) allowed near start positions\n            (as a velocity limit i.e. it will have an effect only if slower than current joint velocity).\n            Use 0 for 'unlimited'.\n        startDist : float\n            Approach distance (in mm) from start position, i.e. the portion of vertical move where\n            the StartVel limit is applied.\n            Automatically limited to jump height (SetMoveJumpHeight).\n        endVel : float\n            Maximum velocity (in mm/s) allowed near end position\n            (as a velocity limit i.e. it will have an effect only if slower than current joint velocity).\n            Use 0 for 'unlimited'.\n        endDist : float\n            Approach distance (in mm) from end position, i.e. the portion of vertical move where\n            the EndVel limit is applied.\n            Automatically limited to jump height (SetMoveJumpHeight).\n\n        \"\"\"\n        self._send_motion_command('SetMoveJumpApproachVel', [startVel, startDist, endVel, endDist])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetTrf(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Set the TRF (tool reference frame) Cartesian position.\n\n        Parameters\n        ----------\n        x, y, z : float\n            Desired reference coordinates in mm.\n        alpha, beta, gamma\n            Desired reference orientation in degrees.\n            On 4-axes robots (like Mcs500), alpha and beta values are not used and can be omitted.\n            Examples for 4-axes robots:\n                - SetTrf(200, 10, 100, 45)\n                - SetTrf(200, 10, 100, gamma=45)\n\n        \"\"\"\n        [alpha, beta, gamma] = self._normalize_cart_cmd_args(alpha, beta, gamma)\n        self._send_motion_command('SetTrf', [x, y, z, alpha, beta, gamma])\n\n    @deprecation.deprecated(deprecated_in=\"1.2.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'SetTrf' function instead\")\n    @disconnect_on_exception_decorator\n    def SetTRF(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Deprecated use SetTrf instead\n\n        \"\"\"\n        self.SetTrf(x, y, z, alpha, beta, gamma)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetWrf(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Set the WRF (world reference frame) Cartesian position.\n\n        Parameters\n        ----------\n        x, y, z : float\n            Desired reference coordinates in mm.\n        alpha, beta, gamma\n            Desired reference orientation in degrees.\n            On 4-axes robots (like Mcs500), alpha and beta values are not used and can be omitted.\n            Examples for 4-axes robots:\n                - SetWrf(200, 10, 100, 45)\n                - SetWrf(200, 10, 100, gamma=45)\n\n        \"\"\"\n        [alpha, beta, gamma] = self._normalize_cart_cmd_args(alpha, beta, gamma)\n        self._send_motion_command('SetWrf', [x, y, z, alpha, beta, gamma])\n\n    @deprecation.deprecated(deprecated_in=\"1.2.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'SetWrf' function instead\")\n    @disconnect_on_exception_decorator\n    def SetWRF(self, x: float, y: float, z: float, alpha: float = None, beta: float = None, gamma: float = None):\n        \"\"\"Deprecated use SetWrf instead\n\n        \"\"\"\n        self.SetWrf(x, y, z, alpha, beta, gamma)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetCheckpoint(self, n: int) -> InterruptableEvent:\n        \"\"\"Set checkpoint with desired id.\n           This function then returns an InterruptableEvent that can be used at any time to\n           wait until the robot's motion queue execution reaches this checkpoint.\n           This method is non-blocking whether robot connection is in asynchronous or synchronous mode.\n           Therefore, it is required to use the wait() method of the return object to catch the checkpoint event.\n\n        Parameters\n        ----------\n        n : int\n            Desired checkpoint id.\n\n        Return\n        ------\n        Checkpoint object\n            Object to use to wait for the checkpoint.\n\n        \"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            assert MX_CHECKPOINT_ID_MIN <= n <= MX_CHECKPOINT_ID_MAX\n            return self._set_checkpoint_impl(n)\n\n    @disconnect_on_exception_decorator\n    def ExpectExternalCheckpoint(self, n: int) -> InterruptableEvent:\n        \"\"\"Expect the robot to receive a checkpoint with given id (e.g. from saved program).\n           Make sure to call this function before starting the saved program otherwise the checkpoint could be missed.\n\n        Parameters\n        ----------\n        n : int\n            Id of expected checkpoint.\n\n        Return\n        ------\n        Checkpoint object\n            Object to use to wait for the checkpoint.\n\n        \"\"\"\n        with self._main_lock:\n            self._check_internal_states()\n            assert MX_CHECKPOINT_ID_MIN <= n <= MX_CHECKPOINT_ID_MAX\n            return self._set_checkpoint_impl(n, send_to_robot=False)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitGripperMoveCompletion(self, timeout: Optional[float] = None):\n        \"\"\"Wait until the most recent gripper move command has completed.\n\n           Note that any move command in the motion queue following a gripper command will start executing at the same\n           time the gripper starts moving.\n           Thus, if you wish to wait for the gripper command to finish before continuing to move the robot, you must\n           call WaitGripperMoveCompletion before posting subsequent motion commands.\n\n           Note: This function is meant to be called immediately after sending a gripper move command (GripperOpen,\n                 GripperClose or MoveGripper). This function will first wait for robot to be idle, then wait for\n                 the gripper command completion.\n\n        Parameters\n        ----------\n        timeout : float\n            Maximum time to spend waiting for the move to complete (in seconds).\n        \"\"\"\n        return super().WaitGripperMoveCompletion(timeout)\n\n    @disconnect_on_exception_decorator\n    def GripperOpen(self):\n        \"\"\"Open the gripper.\n           Note 1:  This command will not cause the robot to stop moving.\n\n           Note 2:  This command will be executed at the beginning of the blending (or deceleration) period of\n                    the previous command in the motion queue.\n                    You can insert a Delay before moving the gripper to make sure that gripper move starts only\n                    once the robot has stopped moving.\n\n           Note 3:  The robot will not wait for gripper move to be completed before continuing with the next command\n                    in the motion queue.\n                    If you need to wait for the gripper move to be completed before continuing your program, do not\n                    post any request in the motion queue after MoveGripper,\n                    then call method WaitGripperMoveCompletion or WaitHoldingPart in your application\n                    to know when your application can continue sending other move commands.\n\n        \"\"\"\n        return super().GripperOpen()\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GripperClose(self):\n        \"\"\"Close the gripper.\n           Note 1:  This command will not cause the robot to stop moving.\n\n           Note 2:  This command will be executed at the beginning of the blending (or deceleration) period of\n                    the previous command in the motion queue.\n                    You can insert a Delay before moving the gripper to make sure that gripper move starts only\n                    once the robot has stopped moving.\n\n           Note 3:  The robot will not wait for gripper move to be completed before continuing with the next command\n                    in the motion queue.\n                    If you need to wait for the gripper move to be completed before continuing your program, do not\n                    post any request in the motion queue after MoveGripper,\n                    then call method WaitGripperMoveCompletion or WaitHoldingPart in your application\n                    to know when your application can continue sending other move commands.\n\n        \"\"\"\n        return super().GripperClose()\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def MoveGripper(self, target: Union[bool, float]):\n        \"\"\"Move the gripper to a target position.\n           Note 1:  This command will not cause the robot to stop moving.\n\n           Note 2:  This command will be executed at the beginning of the blending (or deceleration) period of\n                    the previous command in the motion queue.\n                    You can insert a Delay before moving the gripper to make sure that gripper move starts only\n                    once the robot has stopped moving.\n\n           Note 3:  The robot will not wait for gripper move to be completed before continuing with the next command\n                    in the motion queue.\n                    If you need to wait for the gripper move to be completed before continuing your program, do not\n                    post any request in the motion queue after MoveGripper,\n                    then call method WaitGripperMoveCompletion or WaitHoldingPart in your application\n                    to know when your application can continue sending other move commands.\n\n           If the target specified is a bool, it indicates if the target position is the opened (True, GRIPPER_OPEN)\n           or closed (False, GRIPPER_CLOSE) position.\n           Otherwise the target position indicates the opening of the gripper, in mm from the most closed position.\n\n        Corresponds to text API calls \"GripperOpen\" / \"GripperClose\" / \"MoveGripper\".\n\n\n        Parameters\n        ----------\n        target : bool or float\n            bool type: Open or close the gripper (GRIPPER_OPEN or GRIPPER_CLOSE)\n            float type: The gripper's target position, in mm from the most closed position.\n\n        \"\"\"\n        return super().MoveGripper(target)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetGripperForce(self, p: float):\n        \"\"\"Set the gripper's force in percent.\n\n        Parameters\n        ----------\n        p : float\n            The desired force in percent.\n\n        \"\"\"\n        self._send_motion_command('SetGripperForce', [p])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetGripperVel(self, p: float):\n        \"\"\"Set the gripper's velocity in percent.\n\n        Parameters\n        ----------\n        p : float\n            The desired velocity in percent.\n\n        \"\"\"\n        self._send_motion_command('SetGripperVel', [p])\n\n    # mx:export_to=robot_sidecar_globals.py\n    #pylint: disable=invalid-name\n    @disconnect_on_exception_decorator\n    def SetGripperRange(self, closePos: float, openPos: float):\n        \"\"\"Set the gripper's range that will be used when calling GripperClose and GripperOpen.\n           This function is useful for example to set a smaller (and thus quicker) movement range when it is not\n           required to fully open the gripper to release objects. This is especially apparent on long-stroke grippers.\n\n           Setting both values to 0 will reset the range to the maximum range found during homing.\n\n        Parameters\n        ----------\n        closePos : float\n            The position relative to the completely closed position that the gripper will move to when calling\n            GripperClose. In mm.\n        openPos : float\n            The position relative to the completely closed position that the gripper will move to when calling\n            GripperOpen. In mm.\n\n        \"\"\"\n        self._send_motion_command('SetGripperRange', [closePos, openPos])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetValveState(self, *args: Union[MxCmdValveState, int, str]):\n        \"\"\"Set the pneumatic module valve states.\n           Note 1:  This command will not cause the robot to stop moving.\n\n           Note 2:  This command will be executed at the beginning of the blending (or deceleration) period of\n                    the previous command in the motion queue.\n                    You can insert a Delay before changing the valves states to make sure that valves are changed\n                    once the robot has stopped moving.\n\n        Parameters\n        ----------\n        valve_1...valve_n :\n            The desired state for valve:\n                - MxCmdValveState.MX_VALVE_STATE_STAY (alternatively: -1, '*' or 'stay')\n                - MxCmdValveState.MX_VALVE_STATE_CLOSE (alternatively: 0 or 'close')\n                - MxCmdValveState.MX_VALVE_STATE_OPEN (alternatively: 1 or 'open')\n            MPM500 pneumatic module has 2 valves.\n\n        \"\"\"\n        self._send_motion_command('SetValveState', args)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def VacuumGrip(self):\n        \"\"\"Start applying vacuum to grip a part with the IO module's vacuum gripper (motion queue command).\n           Note 1:  This command will not cause the robot to stop moving.\n\n           Note 2:  This command will be executed at the beginning of the blending (or deceleration) period of\n                    the previous command in the motion queue.\n                    You can insert a Delay before calling VacuumGrip to make sure that vacuum is applied only\n                    once the robot has stopped moving.\n\n           Note 3:  The robot will NOT wait until robot is confirmed holding part before starting to execute the next\n                    command in the motion queue.\n                    If you need to wait for holding part confirmation before continuing your program, do not\n                    post any request in the motion queue after VacuumGrip, then call method WaitHoldingPart\n                    in your application and finally post following move commands to the robot.\n        \"\"\"\n        self._send_motion_command('VacuumGrip')\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def VacuumGrip_Immediate(self):\n        \"\"\"Same as VacuumGrip but without going through robot's motion queue (immediately applied)\"\"\"\n        self.VacuumGripReleaseImmediate(False)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def VacuumRelease(self):\n        \"\"\"Release part held by the IO module's vacuum gripper (motion queue command).\n           Note 1:  This command will not cause the robot to stop moving.\n\n           Note 2:  This command will be executed at the beginning of the blending (or deceleration) period of\n                    the previous command in the motion queue.\n                    You can insert a Delay before calling VacuumRelease to make sure that part is released only\n                    once the robot has stopped moving.\n\n           Note 3:  The robot will NOT wait until robot is confirmed released part before starting to execute the next\n                    command in the motion queue.\n                    If you need to wait for released part confirmation before continuing your program, do not\n                    post any request in the motion queue after VacuumRelease, then call method WaitReleasedPart\n                    in your application and finally post following move commands to the robot.\n        \"\"\"\n        self._send_motion_command('VacuumRelease')\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def VacuumRelease_Immediate(self):\n        \"\"\"Same as VacuumRelease but without going through robot's motion queue (immediately applied)\"\"\"\n        self.VacuumGripReleaseImmediate(True)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitHoldingPart(self, timeout: Optional[float] = None):\n        \"\"\"Wait for the gripper (or vacuum gripper) to confirm it's holding part.\n\n           Note that any move command in the motion queue following a gripper command will start executing at the same\n           time the gripper starts moving.\n           Thus, if you wish to wait for holding part confirmation before continuing to move the robot, you must\n           call WaitHoldingPart before posting subsequent motion commands.\n\n        Parameters\n        ----------\n        timeout : float\n            Maximum time to spend waiting for the holding part confirmation (in seconds).\n        \"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_holding_part.wait(timeout=timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitReleasedPart(self, timeout: Optional[float] = None):\n        \"\"\"Wait for the gripper (or vacuum gripper) to confirm it has released part.\n\n           Note that any move command in the motion queue following a gripper command will start executing at the same\n           time the gripper starts moving.\n           Thus, if you wish to wait for released part confirmation before continuing to move the robot, you must\n           call WaitReleasedPart before posting subsequent motion commands.\n\n        Parameters\n        ----------\n        timeout : float\n            Maximum time to spend waiting for the released part confirmation (in seconds).\n        \"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_released_part.wait(timeout=timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitPurgeDone(self, timeout: Optional[float] = None):\n        \"\"\"Wait for the vacuum gripper purge to be done after releasing part.\n\n        Parameters\n        ----------\n        timeout : float\n            Maximum time to spend waiting for the vacuum purge done confirmation (in seconds).\n        \"\"\"\n        # Use appropriate default timeout if not specified\n        if timeout is None:\n            timeout = self.default_timeout\n        self._robot_events.on_vacuum_purge_done.wait(timeout=timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetVacuumThreshold(self, hold_threshold: float, release_threshold: float):\n        \"\"\"Set vacuum pressure level thresholds for considering holding or releasing a part (motion queue command).\n           Part is considered held once the vacuum level reaches the 'hold threshold'.\n           Part is considered released once the vacuum pressure passes the 'release threshold'\n           (i.e. closer to zero Kpa than 'release threshold').\n           The 'Hold threshold' must thus be under (more negative Kpa) than the 'release threshold'.\n           Use values (0,0) to reset to default values.\n\n        Parameters\n        ----------\n        hold_threshold : float\n            Vacuum pressure threshold to consider holding part in kPa.\n        openPos : float\n            Vacuum pressure threshold to consider part released in kPa.\n\n        \"\"\"\n        self._send_motion_command('SetVacuumThreshold', [hold_threshold, release_threshold])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetVacuumThreshold_Immediate(self, hold_threshold: float, release_threshold: float):\n        \"\"\"Same as SetVacuumThreshold but without going through robot's motion queue (immediately applied)\"\"\"\n        self._send_immediate_command('SetVacuumThreshold_Immediate', [hold_threshold, release_threshold], None)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetVacuumPurgeDuration(self, duration: float):\n        \"\"\"Set duration (in seconds) of the positive air pressure applied when VacuumRelease is called\n           (motion queue command).\n           This positive air pressure period helps ejecting the held part.\n           Use value -1 to restore default purge duration'.\n\n        Parameters\n        ----------\n        duration : float\n            Duration (in seconds) of the vacuum purge.\n\n        \"\"\"\n        self._send_motion_command('SetVacuumPurgeDuration', [duration])\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetVacuumPurgeDuration_Immediate(self, duration: float):\n        \"\"\"Same as SetVacuumPurgeDuration but without going through robot's motion queue (immediately applied)\"\"\"\n        self._send_immediate_command('SetVacuumPurgeDuration_Immediate', [duration], None)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetOutputState(self, bank_id: MxIoBankId, *output_states: Union[MxDigitalIoState, int, str]):\n        \"\"\"Set the digital output states for the specified IO bank (motion queue command).\n           Note 1:  This command will not cause the robot to stop moving.\n\n           Note 2:  This command will be executed at the beginning of the blending (or deceleration) period of\n                    the previous command in the motion queue.\n                    You can insert a Delay before changing the IO states to make sure that they change\n                    once the robot has stopped moving.\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId\n            The IO bank Id to set output states for.\n        output_states_1...output_states_n : MxDigitalIoState, int, str\n            The desired IO state (the number of available outputs depends on the chosen bank id):\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_STAY (alternatively: -1, '*' or 'stay')\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_0 (alternatively: 0 or 'off')\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_1 (alternatively: 1 or 'on')\n        \"\"\"\n        super().SetOutputState(bank_id, *output_states)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetOutputState_Immediate(self, bank_id: MxIoBankId, *output_states: Union[MxDigitalIoState, int, str]):\n        \"\"\"Same as SetOutputState but without going through robot's motion queue (immediately applied)\"\"\"\n        super().SetOutputState_Immediate(bank_id, *output_states)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitForAnyCheckpoint(self, timeout: float = None):\n        \"\"\"Pause program execution until any checkpoint has been received from the robot.\n\n        Parameters\n        ----------\n        timeout : float\n            Maximum time to spend waiting for the checkpoint (in seconds).\n        \"\"\"\n        super().WaitForAnyCheckpoint(timeout)\n\n    @disconnect_on_exception_decorator\n    def WaitConnected(self, timeout: float = None):\n        \"\"\"Pause program execution until robot is connected.\n           Since the Connect() command is always blocking, this command is only useful if a separate thread wants to\n           wait for the connection to be established.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitConnected(timeout)\n\n    @disconnect_on_exception_decorator\n    def WaitDisconnected(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot is disconnected.\n           Since the Disconnect() command is always blocking, this command is only useful if a separate thread wants to\n           wait for the disconnection.\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitDisconnected(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitActivated(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot is activated.\n\n        Parameters\n        ----------\n        timeout : float, by default 30\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitActivated(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitDeactivated(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot is deactivated.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitDeactivated(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitHomed(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot is homed.\n\n        Parameters\n        ----------\n        timeout : float, by default 40\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitHomed(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitSimActivated(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot simulation mode is activated.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n\n        \"\"\"\n        super().WaitSimActivated(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitSimDeactivated(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot simulation mode is deactivated.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitSimDeactivated(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitExtToolSimActivated(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot external tool simulation mode is activated.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n\n        \"\"\"\n        super().WaitExtToolSimActivated(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitExtToolSimDeactivated(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot external tool simulation mode is deactivated.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitExtToolSimDeactivated(timeout)\n\n    # pylint: disable=unused-argument\n    @disconnect_on_exception_decorator\n    def WaitIoSimEnabled(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, timeout: float = None):\n        \"\"\"Pause program execution until the robot PSU IO simulation mode is enabled.\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId, MxIoBankId.MX_IO_BANK_ID_IO_MODULE\n            Id of the IO module to wait for.\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitIoSimEnabled(timeout)\n\n    # pylint: disable=unused-argument\n    @disconnect_on_exception_decorator\n    def WaitIoSimDisabled(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, timeout: float = None):\n        \"\"\"Pause program execution until the robot IO simulation mode is disabled.\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId, MxIoBankId.MX_IO_BANK_ID_IO_MODULE\n            Id of the IO module to wait for.\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitIoSimDisabled(timeout)\n\n    def IsDesiredOutputState(self, bank_id: MxIoBankId, *expected_states: Union[MxDigitalIoState, int, str]) -> bool:\n        \"\"\"Tells if the current digital output states matches the desired state.\n           Note that, here, a desired state of '*', 'stay' or -1 is interpreted as \"don't compare\".\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId\n            The IO bank Id to validate output states for.\n        expected_states : Union[MxDigitalIoState, int, str]\n            The desired IO state (the number of available outputs depends on the chosen bank id):\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_STAY (alternatively: -1, '*' or 'stay') -> Will not be compared\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_0 (alternatively: 0 or 'off')\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_1 (alternatively: 1 or 'on')\n\n        Return\n        ------\n        True if current output states match desired state.\n        \"\"\"\n        return self.IsDesiredIoState(bank_id, False, *expected_states)\n\n    # mx:export_to=robot_sidecar_globals.py\n    def WaitOutputState(self,\n                        bank_id: MxIoBankId,\n                        *expected_states: Union[MxDigitalIoState, int, str],\n                        timeout: float = None):\n        \"\"\"Wait until the current digital output states matches the desired state.\n           Note that, here, a desired state of '*', 'stay' or -1 is interpreted as \"don't compare\".\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId\n            The IO bank Id to wait output states for.\n        expected_states : Union[MxDigitalIoState, int, str]\n            The desired IO state (the number of available outputs depends on the chosen bank id):\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_STAY (alternatively: -1, '*' or 'stay') -> Will not be compared\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_0 (alternatively: 0 or 'off')\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_1 (alternatively: 1 or 'on')\n\n        Raises\n        ------\n        TimeoutException\n            If timeout was reached before the digital outputs state is as desired.\n        \"\"\"\n        return self.WaitIOState(bank_id, False, *expected_states, timeout)\n\n    def IsDesiredInputState(self, bank_id: MxIoBankId, *expected_states: Union[MxDigitalIoState, int, str]) -> bool:\n        \"\"\"Tells if the current digital input states matches the desired state.\n           Note that, here, a desired state of '*', 'stay' or -1 is interpreted as \"don't compare\".\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId\n            The IO bank Id to validate input states for.\n        expected_states : Union[MxDigitalIoState, int, str]\n            The desired IO state (the number of available inputs depends on the chosen bank id):\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_STAY (alternatively: -1, '*' or 'stay') -> Will not be compared\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_0 (alternatively: 0 or 'off')\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_1 (alternatively: 1 or 'on')\n\n        Return\n        ------\n        True if current input states match desired state.\n        \"\"\"\n        return self.IsDesiredIoState(bank_id, True, *expected_states)\n\n    # mx:export_to=robot_sidecar_globals.py\n    def WaitInputState(self,\n                       bank_id: MxIoBankId,\n                       *expected_states: Union[MxDigitalIoState, int, str],\n                       timeout: float = None):\n        \"\"\"Wait until the current digital input states matches the desired state.\n           Note that, here, a desired state of '*', 'stay' or -1 is interpreted as \"don't compare\".\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId\n            The IO bank Id to wait input states for.\n        expected_states : Union[MxDigitalIoState, int, str]\n            The desired IO state (the number of available inputs depends on the chosen bank id):\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_STAY (alternatively: -1, '*' or 'stay') -> Will not be compared\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_0 (alternatively: 0 or 'off')\n                - MxDigitalIoState.MX_DIGITAL_IO_STATE_1 (alternatively: 1 or 'on')\n\n        Raises\n        ------\n        TimeoutException\n            If timeout was reached before the digital inputs state is as desired.\n        \"\"\"\n        return self.WaitIOState(bank_id, True, *expected_states, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitRecoveryMode(self, activated: bool, timeout: float = None):\n        \"\"\"Pause program execution until the robot recovery mode is in the requested state.\n\n        Parameters\n        ----------\n        activated : bool\n            Recovery mode to wait for (activated or deactivated\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitRecoveryMode(activated, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitForError(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot is in error state.\n\n        Parameters\n        ----------\n        timeout : float\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitForError(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitErrorReset(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot is not in an error state.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitErrorReset(timeout)\n\n    @deprecation.deprecated(deprecated_in=\"2.1.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'WaitSafetyStopReset' function instead\")\n    @disconnect_on_exception_decorator\n    def WaitPStop2Reset(self, timeout: float = None):\n        \"\"\"Deprecated use WaitSafetyStopReset instead.\"\"\"\n        super().WaitPStop2ResetDeprecated(timeout)\n\n    @deprecation.deprecated(deprecated_in=\"2.1.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'WaitSafetyStopReset' function instead\")\n    @disconnect_on_exception_decorator\n    def WaitPStop2Resettable(self, timeout: float = None):\n        \"\"\"Deprecated use WaitSafetyStopResettable instead.\"\"\"\n        super().WaitPStop2ResettableDeprecated(timeout)\n\n    @deprecation.deprecated(deprecated_in=\"2.1.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'WaitSafetyStopResettable' function instead\")\n    @disconnect_on_exception_decorator\n    def WaitEStopReset(self, timeout: float = None):\n        \"\"\"Deprecated use WaitSafetyStopReset instead.\"\"\"\n        super().WaitEStopResetDeprecated(timeout)\n\n    @deprecation.deprecated(deprecated_in=\"2.1.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'WaitSafetyStopResettable' function instead\")\n    @disconnect_on_exception_decorator\n    def WaitEStopResettable(self, timeout: float = None):\n        \"\"\"Deprecated use WaitSafetyStopResettable instead.\"\"\"\n        super().WaitEStopResettableDeprecated(timeout)\n\n    def WaitEstopResettable(self, timeout: float = None):\n        super().WaitEStopResettableDeprecated(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitSafetyStopReset(self, timeout: float = None):\n        \"\"\"Pause program execution until all safety stop conditions have been reset (EStop, PStop1, PStop2, ...)\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitSafetyStopReset(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitSafetyStopResettable(self, timeout: float = None):\n        \"\"\"Pause program execution until all safety conditions can be reset using the power supply Reset function.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitSafetyStopResettable(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitSafetyStopStateChange(self, timeout: float = None):\n        \"\"\"Pause program execution until any safety stop state changes (Raised, resettable or cleared safety stop,\n           operation mode change, etc) as reported by RobotSafetyStatus.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitSafetyStopStateChange(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitMotionResumed(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot motion is resumed.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitMotionResumed(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitMotionPaused(self, timeout: float = None):\n        \"\"\"Pause program execution until the robot motion is paused.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitMotionPaused(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitMotionCleared(self, timeout: float = None):\n        \"\"\"Pause program execution until all pending request to clear motion have been acknowledged.\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitMotionCleared(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitEndOfCycle(self, timeout: float = None):\n        \"\"\"Pause program execution until all messages in a message cycle are received\n\n        Parameters\n        ----------\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time to spend waiting for the event (in seconds).\n        \"\"\"\n        super().WaitEndOfCycle(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def WaitIdle(self, timeout: float = None, wait_rt_data=False):\n        \"\"\"Pause program execution until robot is idle (no longer moving, motion queue empty).\n\n        Note: After this function returns (and the robot is idle), some real-time values\n        (e.g. GetRtTargetJointPos, GetRtTargetCartPos, GetRobotRtData) may still be outdated since they are updated at\n        a defined monitoring interval (defined by SetMonitoringInterval()).\n        To get the most recent real-time position immediately after WaitIdle(), use the synchronous_update option\n        in those functions.\n        Alternatively, you can use WaitEndOfCycle() after WaitIdle() to ensure the latest real-time data is received.\n\n        Parameters\n        ----------\n        timeout : float\n            Maximum time to spend waiting for the event (in seconds).\n        wait_rt_data : bool\n            After the robot is idle (end of block), also wait until next cyclic real-time data is received.\n            This ensures that, when the WaitIdle function exits, the real-time data is up-to-date\n            (position, velocity (should be 0 here), etc)\n        \"\"\"\n        super().WaitIdle(timeout, wait_rt_data)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def ResetError(self):\n        \"\"\"Attempt to reset robot error.\"\"\"\n        super().ResetError()\n\n    @deprecation.deprecated(deprecated_in=\"1.2.2\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'ResetPStop2' function instead\")\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def ResetPStop(self, timeout: float = None):\n        \"\"\"Attempt to reset robot PStop2.\n           Deprecated for robots running firmware 10.1 and above: use ResumeMotion instead.\n           *** IMPORTANT NOTE: PStop2 is not safety-rated on Meca500 robots ***\n        \"\"\"\n        self.ResetPStop2Deprecated(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def ResetPStop2(self, timeout: float = None):\n        \"\"\"Attempt to reset robot PStop2.\n           Deprecated for robots running firmware 10.1 and above: use ResumeMotion instead.\n           *** IMPORTANT NOTE: PStop2 is not safety-rated on Meca500 robots ***\n        \"\"\"\n        super().ResetPStop2Deprecated(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def Delay(self, t: float):\n        \"\"\"Set a delay between motion commands.\n\n        Parameters\n        ----------\n        t : float\n            Desired pause duration in seconds.\n\n        \"\"\"\n        super().Delay(t)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SendCustomCommand(self,\n                          command: str,\n                          expected_responses: list[int] = None,\n                          timeout: float = None) -> InterruptableEvent | Message:\n        \"\"\"Send custom command to robot (a command that the robot may support but that this Python API does not\n           provide an explicit function for).\n\n        Parameters\n        ----------\n        command : str\n            Desired custom command.\n\n        expected_responses : None or list of integers.\n            If not none, wait for and return one of the expected responses.\n\n        timeout: None or float\n            Timeout (in seconds) waiting for the first of expected_responses.\n            If None, this function is non-blocking and return InterruptableEvent that can be used to wait\n            until first response of expected_responses is received.\n            If not None, this function will wait on the interruptable event for the specified duration\n            and instead return the Message that was received among expected_responses,\n            or throw TimeoutException if appropriate.\n\n        Raises\n        ------\n        TimeoutException\n            If timeout was reached before the robot returned success or failure response.\n        InterruptException\n            If the robot returns an error (exception message will describe the error).\n\n        Return\n        ------\n        If expected_responses is not None, this function returns either:\n         - InterruptableEvent if timeout is None (use event.wait() to wait for and get the response message).\n         - The received Message object if timeout is not None\n\n        \"\"\"\n        return self._send_custom_command(command, expected_responses, timeout, skip_internal_check=True)\n\n    def GetInterruptableEvent(self,\n                              codes: list[Union[MxRobotStatusCode, Message]],\n                              abort_on_error=False,\n                              abort_on_clear_motion=False) -> InterruptableEvent:\n        \"\"\"Get an interruptable event that can be used to await for next code received from the robot among the list\n\n        Parameters\n        ----------\n        codes : list[mdr.MxRobotStatusCode]\n            List of status codes to await for (first received will awake the interruptable event)\n            or\n            List of message (id + data) to await for (first received message that matches id and data will awake event)\n        abort_on_error : bool, optional\n            Tells if this event must be awakened if the robot falls into error state, by default False\n        abort_on_clear_motion : bool, optional\n            Tells if this event must be awakened if the robot's motion queue is cleared\n            Note that this also includes PStop2 condition and robot deactivation (which also cause the motion queue\n            to be cleared)\n\n        Returns\n        -------\n        mdr.InterruptableEvent\n            Event that will be awakened upon reception of first received event among provided codes\n\n        Example 1: Wait for an event id\n        -------\n            # Create interruptable event that will trigger on code MX_ST_RT_INPUT_STATE\n            input_state_changed_event = robot.GetInterruptableEvent([mdr.MxRobotStatusCode.MX_ST_RT_INPUT_STATE])\n            # (there can be code here that move the robot or whatever is expected to trigger digital input change)\n            # (...)\n\n            # Wait (block) until the event is received with a 10 seconds timeout.\n            input_state_changed_event.wait(10)\n\n        Example 2: Wait for an event id with specific data\n        -------\n            # Create interruptable event that will trigger when torque limit is exceeded,\n            # i.e. event id MX_ST_TORQUE_LIMIT_STATUS with data 1\n            torque_exceeded_event = robot.GetInterruptableEvent(\n                [mdr.Message(mdr.MxRobotStatusCode.MX_ST_TORQUE_LIMIT_STATUS, '1')])\n\n            # (there can be code here that move the robot or do other things, for example)\n            # (...)\n\n            # Check if the torque limit exceeded status event was received\n            if torque_exceeded_event.is_set():\n                # Torque limit was exceeded between call to GetInterruptableEvent above and now\n                pass\n\n            # Wait (block) until the torque limit exceeded event is received\n            torque_exceeded_event.wait(10)\n        \"\"\"\n        return super().GetInterruptableEvent(codes, abort_on_error, abort_on_clear_motion)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def StartProgram(self, n: int | str, timeout: float = None):\n        \"\"\"Start an offline program.\n\n        Offline programs need to be recorded using the robot's Web Portal (or text API).\n        This API can only start an already recorded offline program.\n        Callback on_offline_program_state will indicate when program is started.\n\n        Parameters\n        ----------\n        n : int\n            Id of offline program to start.\n        timeout: float\n            Timeout (in seconds) waiting for the robot to confirm that the program has started executing.\n\n        \"\"\"\n        super().StartProgram(n, timeout)\n\n    @disconnect_on_exception_decorator\n    def StartOfflineProgram(self, n: int | str, timeout: float = None):\n        \"\"\"Deprecated use StartPrograms instead.\n        \"\"\"\n        super().StartProgram(n, timeout)\n\n    @disconnect_on_exception_decorator\n    def ListFiles(self, timeout: float = None) -> dict:\n        \"\"\"List all files that are stored on the robot.\n        Related commands: LoadFile, SaveFile, DeleteFile\n\n        This function is synchronous only for now.\n        If you want to asynchronously list files, you can use SendCustomCommand, for example:\n        done_evt = self.SendCustomCommand('ListFiles')\n        Callback on_command_message(response) can be attached to be informed of all responses from the robot.\n        Responses to check fore are:\n            - response.id == MxRobotStatusCode.MX_ST_LIST_FILES\n            In this case response.json_data[MX_JSON_KEY_DATA][\"files\"] will contain the listed files list\n            (same format as returned by this function)\n            - response.id == MxRobotStatusCode.MX_ST_LIST_FILES_ERR\n\n        Parameters\n        ----------\n        timeout: float\n            Timeout (in seconds) waiting for files list.\n\n        Raises\n        ------\n        TimeoutException\n            If timeout was reached before the robot returned success or failure response.\n        InterruptException\n            If the robot returns an error (exception message will describe the error).\n\n        Returns\n        -------\n        dict\n            Object that contains the status of all listed files, in this format\n            {\n                \"myProgramName\": {\n                    \"status\": {\n                        \"valid\": false,\n                        \"invalidLines\": [10, 332, 522]\n                    }\n                },\n                \"myProgram2\": {\n                    \"status\": {\n                        \"valid\": true,\n                        \"invalidLines\": []\n                    }\n                },\n                ...\n            }\n        \"\"\"\n        return super().ListFiles(timeout)\n\n    @deprecation.deprecated(deprecated_in=\"2.1.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'ListFiles' function instead\")\n    @disconnect_on_exception_decorator\n    def ListPrograms(self, timeout: float = None) -> dict:\n        \"\"\"Deprecated use ListFiles instead.\n        \"\"\"\n        return super().ListFiles(timeout)\n\n    @disconnect_on_exception_decorator\n    def LoadFile(self, name: str, timeout: float = None) -> dict:\n        \"\"\"Load a file from the robot.\n\n        Related commands: ListFiles, SaveFile, DeleteFile\n\n        This function is synchronous only for now.\n        If you want to asynchronously load a file, you can use SendCustomCommand, for example:\n        done_evt = self.SendCustomCommand('LoadFile{\"data\":{\"name\":\"programName\"}')\n        Callback on_command_message(response) can be attached to be informed of all responses from the robot.\n        Responses to check fore are:\n            - response.id == MxRobotStatusCode.MX_ST_LOAD_FILES\n            - response.id == MxRobotStatusCode.MX_ST_LOAD_FILES_ERR\n\n        Parameters\n        ----------\n        name: str\n            Name of the file to load.\n        timeout: float\n            Timeout (in seconds) waiting for file to be loaded.\n\n        Raises\n        ------\n        TimeoutException\n            If timeout was reached before the robot returned success or failure response.\n        InterruptException\n            If the robot returns an error (exception message will describe the error).\n\n        Returns\n        -------\n        dict\n            Object that contains information and contents of the loaded program\n            {\n                \"name\": \"fileName\",\n                \"status\": {\n                    \"valid\": false,\n                    \"invalidLines\": [10, 332, 522]\n                },\n                \"content\":{\"// File content\"}\n            }\n        \"\"\"\n        return super().LoadFile(name, timeout)\n\n    @deprecation.deprecated(deprecated_in=\"2.1.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'LoadFile' function instead\")\n    @disconnect_on_exception_decorator\n    def LoadProgram(self, name: str, timeout: float = None) -> dict:\n        \"\"\"Deprecated use LoadFile instead.\n        \"\"\"\n        return super().LoadFile(name, timeout)\n\n    @disconnect_on_exception_decorator\n    def SaveFile(self, name: str, content: str, timeout: float = None, allow_invalid=False, overwrite=False):\n        \"\"\"Save a file the robot.\n\n        Related commands: ListFiles, LoadFile, DeleteFile\n\n        This function is synchronous only for now.\n        If you want to asynchronously save file, you can use SendCustomCommand, for example:\n        done_evt = self.SendCustomCommand('SaveFile{\"data\":{\"name\":\"programName\", \"content\":\"Program text\"}}')\n        Callback on_command_message(response) can be attached to be informed of all responses from the robot.\n        Responses to check fore are:\n            - response.id == MxRobotStatusCode.MX_ST_SAVE_FILE\n            - response.id == MxRobotStatusCode.MX_ST_SAVE_FILE_ERR\n\n        Parameters\n        ----------\n        name: str\n            Name of the file to save.\n        content: str\n            The file content to save.\n        timeout: float\n            Timeout (in seconds) waiting for file to be saved.\n        allow_invalid: bool\n            Allow saving the file even if it is invalid\n        overwrite: bool\n            Overwrite if a file with the same name already exists on the robot.\n            (equivalent of atomic Delete then SaveFile)\n            If False, SaveFile will be refused if the name is already used.\n\n        Raises\n        ------\n        TimeoutException\n            If timeout was reached before the robot returned success or failure response.\n        InterruptException\n            If the robot returns an error (exception message will describe the error).\n        \"\"\"\n        return super().SaveFile(name, content, timeout, allow_invalid, overwrite)\n\n    @deprecation.deprecated(deprecated_in=\"2.1.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'SaveFile' function instead\")\n    @disconnect_on_exception_decorator\n    def SaveProgram(self, name: str, program: str, timeout: float = None, allow_invalid=False, overwrite=False):\n        \"\"\"Deprecated use SaveFile instead.\n        \"\"\"\n        return super().SaveFile(name, program, timeout, allow_invalid, overwrite)\n\n    @disconnect_on_exception_decorator\n    def DeleteFile(self, name: str, timeout: float = None):\n        \"\"\"Delete a file from the robot.\n\n        Related commands: ListFiles, LoadFile, SaveFile\n\n        This function is synchronous only for now.\n        If you want to asynchronously delete a file, you can use SendCustomCommand, for example:\n        done_evt = self.SendCustomCommand('DeleteFile{\"data\":{\"name\":\"programName\"}')\n        Callback on_command_message(response) can be attached to be informed of all responses from the robot.\n        Responses to check fore are:\n            - response.id == MxRobotStatusCode.MX_ST_DELETE_FILE\n            - response.id == MxRobotStatusCode.MX_ST_DELETE_FILE_ERR\n\n        Parameters\n        ----------\n        name: str\n            Name of the file to delete.\n        timeout: float\n            Timeout (in seconds) waiting for file to be deleted.\n\n        Raises\n        ------\n        TimeoutException\n            If timeout was reached before the robot returned success or failure response.\n        InterruptException\n            If the robot returns an error (exception message will describe the error).\n        \"\"\"\n        return super().DeleteFile(name, timeout)\n\n    @deprecation.deprecated(deprecated_in=\"2.1.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'DeleteFile' function instead\")\n    @disconnect_on_exception_decorator\n    def DeleteProgram(self, name: str, timeout: float = None):\n        \"\"\"Deprecated use DeleteFile instead.\n        \"\"\"\n        return super().DeleteFile(name, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRtExtToolStatus(self,\n                           include_timestamp: bool = False,\n                           synchronous_update: bool = False,\n                           timeout: float = None) -> ExtToolStatus:\n        \"\"\"Return a copy of the current external tool status\n\n        Parameters\n        ----------\n        include_timestamp : bool\n            If true, return a TimestampedData object, otherwise just return states.\n        synchronous_update: bool\n            True -> Synchronously get updated external tool status. False -> Get latest known status.\n        timeout: float\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        TimestampedData or ExtToolStatus\n            Object containing the current external tool status\n\n        \"\"\"\n        return super().GetRtExtToolStatus(include_timestamp, synchronous_update, timeout)\n\n    @disconnect_on_exception_decorator\n    def GetNetworkCfg(self, synchronous_update: bool = True, timeout: float = None) -> NetworkConfig:\n        \"\"\"Return robot's current network configuration\n\n        Parameters\n        ----------\n        synchronous_update: bool\n            True -> Synchronously get updated network config. False -> Get latest known network configuration.\n        timeout: float\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        NetworkConfig\n            Object containing the current network config\n\n        \"\"\"\n        return super().GetNetworkCfg(synchronous_update, timeout)\n\n    @disconnect_on_exception_decorator\n    def GetNetworkConfig(self, synchronous_update: bool = False, timeout: float = None) -> NetworkConfig:\n        \"\"\"Legacy command. Please use GetNetworkCfg instead.\"\"\"\n        return super().GetNetworkCfg(synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRtIoStatus(self,\n                      bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                      include_timestamp: bool = False,\n                      synchronous_update: bool = False,\n                      timeout: float = None) -> IoStatus:\n        \"\"\"Return a copy of the current IO module status\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId\n            The IO bank Id to get output states for.\n        synchronous_update: bool\n            True -> Synchronously get updated IO module status. False -> Get latest known status.\n        timeout: float\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        TimestampedData or IoStatus\n            Object containing the current IO module status\n\n        \"\"\"\n        return super().GetRtIoStatus(bank_id, include_timestamp, synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRtGripperState(self,\n                          include_timestamp: bool = False,\n                          synchronous_update: bool = False,\n                          timeout: float = None) -> GripperState:\n        \"\"\"Return a copy of the current gripper state\n\n        Parameters\n        ----------\n        include_timestamp : bool\n            If true, return a TimestampedData object, otherwise just return states.\n        synchronous_update: bool\n            True -> Synchronously get updated gripper state. False -> Get latest known status.\n        timeout: float\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        TimestampedData or GripperState\n            Object containing the current gripper state\n\n        \"\"\"\n        return super().GetRtGripperState(include_timestamp, synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRtValveState(self,\n                        include_timestamp: bool = False,\n                        synchronous_update: bool = False,\n                        timeout: float = None) -> ValveState:\n        \"\"\"Return a copy of the current valve state\n\n        Parameters\n        ----------\n        include_timestamp : bool\n            If true, return a TimestampedData object, otherwise just return states.\n        synchronous_update: bool\n            True -> Synchronously get updated valve states. False -> Get latest known status.\n        timeout: float\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        TimestampedData or ValveState\n            Object containing the current valve state\n\n        \"\"\"\n        return super().GetRtValveState(include_timestamp, synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRtOutputState(self,\n                         bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                         synchronous_update: bool = False,\n                         timeout: float = None) -> TimestampedData:\n        \"\"\"Return a copy of the current digital outputs state\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId\n            The IO bank Id to get output states for.\n        synchronous_update: bool\n            True -> Synchronously get updated states. False -> Get latest known status.\n        timeout: float\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        TimestampedData\n            Object containing the current digital output states for requested bank id.\n\n        \"\"\"\n        return super().GetRtOutputState(bank_id, synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRtInputState(self,\n                        bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE,\n                        synchronous_update: bool = False,\n                        timeout: float = None) -> TimestampedData:\n        \"\"\"Return a copy of the current digital inputs state\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId\n            The IO bank Id to get input states for.\n        synchronous_update: bool\n            True -> Synchronously get updated states. False -> Get latest known status.\n        timeout: float\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        TimestampedData\n            Object containing the current digital input states for requested bank id.\n\n        \"\"\"\n        return super().GetRtInputState(bank_id, synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRtVacuumState(self,\n                         include_timestamp: bool = False,\n                         synchronous_update: bool = False,\n                         timeout: float = None) -> VacuumState:\n        \"\"\"Return a copy of the current vacuum gripper state\n\n        Parameters\n        ----------\n        include_timestamp : bool\n            If true, return a TimestampedData object, otherwise return VacuumState.\n        synchronous_update: bool\n            True -> Synchronously get updated states. False -> Get latest known status.\n        timeout: float\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        TimestampedData\n            Object containing the current Vacuum grip state: [vacuum on/off, purge on/off,  holding part]\n\n        \"\"\"\n        return super().GetRtVacuumState(include_timestamp, synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRtTargetJointPos(self,\n                            include_timestamp: bool = False,\n                            synchronous_update: bool = False,\n                            timeout: float = None) -> TimestampedData:\n        \"\"\"Returns the real-time target joint positions of the robot.\n\n        Parameters\n        ----------\n        include_timestamp : bool\n            If true, return a TimestampedData object, otherwise just return joints angles.\n        synchronous_update : bool\n            True -> Synchronously get current target joints position.\n            False -> Return latest known data (from previous received cyclic data) without requesting the robot\n            *** WARNING: This position may be outdated from as much as one cycle, which duration is defined by\n                         SetMonitoringInterval().\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time in second to wait for forced update.\n\n        Return\n        ------\n        TimestampedData or list of floats\n            Returns joint positions in degrees.\n\n        \"\"\"\n        return super().GetRtTargetJointPos(include_timestamp, synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetJoints(self, synchronous_update: bool = False, timeout: float = None):\n        \"\"\"Legacy command. Please use GetRtTargetJointPos instead.\"\"\"\n        return super().GetRtTargetJointPos(include_timestamp=False,\n                                           synchronous_update=synchronous_update,\n                                           timeout=timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRtTargetCartPos(self,\n                           include_timestamp: bool = False,\n                           synchronous_update: bool = False,\n                           timeout: float = None) -> TimestampedData:\n        \"\"\"Returns the current end-effector pose of the robot. WARNING: NOT UNIQUE.\n\n        Parameters\n        ----------\n        include_timestamp : bool\n            If true, return a TimestampedData object, otherwise just return joints angles.\n        synchronous_update : bool\n            True -> Synchronously get current cartesian position.\n            False -> Return latest known data (from previous received cyclic data) without requesting the robot\n            *** WARNING: This position may be outdated from as much as one cycle, which duration is defined by\n                         SetMonitoringInterval().\n        timeout : float, defaults to DEFAULT_WAIT_TIMEOUT\n            Maximum time in second to wait for forced update.\n\n        Return\n        ------\n        TimestampedData or list of floats\n            Returns end-effector pose [x, y, z, alpha, beta, gamma].\n\n        \"\"\"\n        return super().GetRtTargetCartPos(include_timestamp, synchronous_update=synchronous_update, timeout=timeout)\n\n    def GetPose(self, synchronous_update: bool = False, timeout: float = None) -> TimestampedData:\n        \"\"\"Legacy command. Please use GetRtTargetCartPos instead.\"\"\"\n        return super().GetRtTargetCartPos(include_timestamp=False,\n                                          synchronous_update=synchronous_update,\n                                          timeout=timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetMonitoringInterval(self, t: float):\n        \"\"\"Sets the interval at which the monitoring port sends real-time data.\n\n        Parameters\n        ----------\n        t : float\n            Monitoring interval duration in seconds.\n\n        \"\"\"\n        super().SetMonitoringInterval(t)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetRealTimeMonitoring(self, *events: tuple):\n        \"\"\"Configure which real-time monitoring events to enable.\n\n        Parameters\n        ----------\n        events : list of event IDs\n            List of event IDs to enable.\n            Example:\n          SetRealTimeMonitoring(MxRobotStatusCode.MX_ST_RT_TARGET_JOINT_POS, MxRobotStatusCode.MX_ST_RT_TARGET_CART_POS)\n            enables the target joint positions and target end effector pose messages.\n            Can also use events='all' to enable all.\n\n        \"\"\"\n        super().SetRealTimeMonitoring(*events)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetRtc(self, t: int):\n        \"\"\"Sets the robot's real-time clock (date/time).\n\n        Parameters\n        ----------\n        t : int\n            Unix epoch time (seconds since 00:00:00 UTC Jan 1, 1970).\n\n        \"\"\"\n        super().SetRtc(t)\n\n    @deprecation.deprecated(deprecated_in=\"1.2.0\",\n                            removed_in=\"3.0.0\",\n                            current_version=__version__,\n                            details=\"Use the 'SetRtc' function instead\")\n    @disconnect_on_exception_decorator\n    def SetRTC(self, t: int):\n        \"\"\"Deprecated use SetRtc instead.\n        \"\"\"\n        super().SetRtc(t)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def ActivateSim(self, mode: Optional[MxRobotSimulationMode] = None):\n        \"\"\"Enables simulation mode. Motors and external tool don't move, but commands will be processed\n\n        Args:\n            mode (MxRobotSimulationMode, optional): Use the \"real-time\" or \"fast\" simulation mode.\n            If not specified (None), the robot's default simulation mode will be used (see SetSimModeCfg).\n        \"\"\"\n        super().ActivateSim(mode)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def DeactivateSim(self):\n        \"\"\"Disables simulation mode. Motors and external tool will now move normally.\"\"\"\n        super().DeactivateSim()\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetExtToolSim(self, sim_ext_tool_type: int = MxExtToolType.MX_EXT_TOOL_MEGP25_SHORT):\n        \"\"\"Simulate an external tool, allowing GripperOpen/Close, MoveGripper and SetValveState commands\n            on a robot without an external tool present.\n\n        Parameters\n        ----------\n        sim_ext_tool_type : int or constants\n            0: MxExtToolType.MX_EXT_TOOL_NONE\n            1: MxExtToolType.MX_EXT_TOOL_CURRENT\n           10: MxExtToolType.MX_EXT_TOOL_MEGP25_SHORT\n           11: MxExtToolType.MX_EXT_TOOL_MEGP25_LONG\n           20: MxExtToolType.MX_EXT_TOOL_VBOX_2VALVES\n        \"\"\"\n        super().SetExtToolSim(sim_ext_tool_type)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetIoSim(self, bank_id: MxIoBankId = MxIoBankId.MX_IO_BANK_ID_IO_MODULE, enable: bool = True):\n        \"\"\"Enable or disable IO simulation. This allows emulating the presence of an IO module and use the\n           corresponding APIs (ex: SetOutputState) without the module to be physically present.\n           This can also be used even if the physical module is present to test the APIs without actually applying the\n           changes on the physical module (to test the APIs without the robot moving)\n\n        Parameters\n        ----------\n        bank_id : MxIoBankId\n            The IO bank Id to enable or disable simulation mode for.\n        enable : bool\n            Enable or disable simulation mode.\n        \"\"\"\n        super().SetIoSim(bank_id, enable)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetRecoveryMode(self, activated: bool = True):\n        \"\"\"Enable/disable recovery mode, allowing robot to move (slowly) without homing and without joint limits.\"\"\"\n        super().SetRecoveryMode(activated)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetTimeScaling(self, p: float):\n        \"\"\"This command sets the time scaling (in percentage) of the trajectory generator. By calling this command\n            with p < 100, all robot motions remain exactly the same (i.e., the path remains the same), but executed\n            at p% of the original speed, including time delays (e.g., the pause set by the command Delay).\n            In other words, this command is more than a simple velocity override.\n\n        Parameters\n        ----------\n        p : float\n            Percentage time scaling, from 0.001 to 100.\n\n        \"\"\"\n        super().SetTimeScaling(p)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetJointLimitsCfg(self, e: bool = True):\n        \"\"\"Enable/Disable user-defined limits set by the 'SetJointLimits' command. It can only be executed while\n        the robot is deactivated. If the user-defined limits are disabled, the default joint limits become active.\n        However, user-defined limits remain in memory, and can be re-enabled, even after a power down.\n\n        Parameters\n        ----------\n            e : bool\n                enable (True) or disable (False) the user-defined joint limits.\n        \"\"\"\n        super().SetJointLimitsCfg(e)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetJointLimits(self, n: int, lower_limit: float, upper_limit: float):\n        \"\"\"This command redefines the lower and upper limits of a robot joint. It can only be executed while the robot\n        is deactivated. For these user-defined joint limits to be taken into account, you must execute the command\n        SetJointLimitsCfg(1). Obviously, the new joint limits must be within the default joint limits and all the robot\n        joints position must be within the requested limits. Note that these user-defined joint limits remain active\n        even after you power down the robot.\n\n        Parameters\n        ----------\n            n : int\n                joint number, an integer ranging from 1 to 6\n            lower_limit : float\n                lower limit of the actuator, in degrees/mm\n            upper_limit : float\n                upper limit of the actuator, in degrees/mm\n        \"\"\"\n        super().SetJointLimits(n, lower_limit, upper_limit)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetWorkZoneCfg(self,\n                       severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR,\n                       mode: MxWorkZoneMode = MxWorkZoneMode.MX_WORK_ZONE_MODE_FCP_IN_WORK_ZONE):\n        \"\"\"Set the severity at which to report work zone violations and the detection mode for work zone violations used\n        by the robot. This command can only be used when the robot is deactivated. User-defined limits remain in memory,\n        even after a power down.\n\n        Parameters\n        ----------\n            severity : MxEventSeverity\n                Severity-level to report work zone events.\n                The available severities are found in mx_robot_def.MxEventSeverity.\n                Note that MX_EVENT_SEVERITY_PAUSE_MOTION = 2 is not supported as colliding paths should not be followed.\n            mode : MxWorkZoneMode\n                Work zone detection mode to use for checks.\n                The available modes are found in mx_robot_def.MxWorkZoneMode.\n        \"\"\"\n        super().SetWorkZoneCfg(severity, mode)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetWorkZoneLimits(self, x_min: float, y_min: float, z_min: float, x_max: float, y_max: float, z_max: float):\n        \"\"\"Set the work zone limits the robot must not exceed. This command can only be used when the robot is\n        deactivated. User-defined limits remain in memory, even after a power down.\n\n        Parameters\n        ----------\n            x_min : float\n                minimum x value of the work zone\n            y_min : float\n                minimum y value of the work zone\n            z_min : float\n                minimum z value of the work zone\n            x_max : float\n                maximum x value of the work zone\n            y_max : float\n                maximum y value of the work zone\n            z_max : float\n                maximum z value of the work zone\n        \"\"\"\n        super().SetWorkZoneLimits(x_min, y_min, z_min, x_max, y_max, z_max)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetCollisionCfg(self, severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR):\n        \"\"\"Set the severity at which to report self collision events. This command can only be used when the robot is\n        deactivated. User-defined configurations remain in memory, even after a power down.\n\n        Parameters\n        ----------\n            severity : MxEventSeverity\n                Severity-level to report collision events.\n                The available severities are found in mx_robot_def.MxEventSeverity.\n                Note that MX_EVENT_SEVERITY_PAUSE_MOTION = 2 is not supported as colliding paths should not be followed.\n        \"\"\"\n        super().SetCollisionCfg(severity)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetToolSphere(self, x: float, y: float, z: float, r: float):\n        \"\"\"Set the tool sphere model of the robot. This command can only be used when the robot is\n        deactivated. User-defined limits remain in memory, even after a power down.\n\n        Parameters\n        ----------\n            x_min : float\n                offset along FRF x-axis to position tool center\n            y_min : float\n                offset along FRF y-axis to position tool center\n            z : float\n                offset along FRF z-axis to position tool center\n            r : float\n                radius of the tool sphere model. r > 0\n        \"\"\"\n        super().SetToolSphere(x, y, z, r)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetTorqueLimitsCfg(\n            self,\n            severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_ERROR,\n            skip_acceleration: MxTorqueLimitsMode = MxTorqueLimitsMode.MX_TORQUE_LIMITS_DETECT_SKIP_ACCEL):\n        \"\"\"Change the torque limits configuration (enable/disable, choose severity, etc.).\n        Note that the per-joint torque limit is configured by calling SetTorqueLimits.\n\n        Parameters\n        ----------\n        severity : MxEventSeverity\n            Severity-level of exceeding torque limits.\n            Available severity levels (see MxEventSeverity or TORQUE_LIMIT_SEVERITIES):\n                - MX_EVENT_SEVERITY_SILENT or 0 or 'disabled':     Torque limits disabled\n                                        (this by default when robot is activated)\n                - MX_EVENT_SEVERITY_WARNING or 1 or 'warning':      Send a warning event\n                                        (MxRobotStatusCode.MX_ST_TORQUE_LIMIT_STATUS) when torque exceeds limit\n                - MX_EVENT_SEVERITY_PAUSE_MOTION or 2 or 'pause-motion': Pause motion when torque exceeds the limit\n                - MX_EVENT_SEVERITY_CLEAR_MOTION or 3 or 'clear-motion': Pause motion when torque exceeds the limit\n                - MX_EVENT_SEVERITY_ERROR or 4 or 'error':        Set robot in error state when torque exceeds the limit\n        skip_acceleration : MxTorqueLimitsMode\n            Whether torque limits are ignored during acceleration periods (allowing fast accelerations without\n            triggering torque limits exceeded condition)\n            Available modes (see MxTorqueLimitsMode):\n                - MX_TORQUE_LIMITS_DETECT_ALL or 0 or False : Always check if torque is within limits\n                - MX_TORQUE_LIMITS_DETECT_SKIP_ACCEL or 1 or True : Ignore torque over limit during acceleration\n        \"\"\"\n        super().SetTorqueLimitsCfg(severity, skip_acceleration)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetTorqueLimits(self, *args: float):\n        \"\"\"Set the torque limit (in percent) for each joint.\n        Note that torque limits will be applied only if severity mode is set to other than 'disabled' by\n        calling SetTorqueLimitsCfg.\n\n        Parameters\n        ----------\n        joint_1...joint_n : float\n            Desired torque limit in percent.\n\n        \"\"\"\n        super().SetTorqueLimits(*args)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetPStop2Cfg(self, severity: MxEventSeverity = MxEventSeverity.MX_EVENT_SEVERITY_CLEAR_MOTION):\n        \"\"\"Set the severity at which to treat a PStop2 events.\n        This command can only be used when the robot is deactivated. User-defined severity remains in memory, even after\n        a power down.\n\n        Parameters\n        ----------\n            severity : MxEventSeverity\n                Severity-level to treat PStop2 events.\n                The available severities are:\n                    - mx_robot_def.MxEventSeverity.MX_EVENT_SEVERITY_PAUSE_MOTION\n                    - mx_robot_def.MxEventSeverity.MX_EVENT_SEVERITY_CLEAR_MOTION\n        \"\"\"\n        super().SetPStop2Cfg(severity)\n\n    @disconnect_on_exception_decorator\n    def SetSimModeCfg(self, default_sim_mode=MxRobotSimulationMode.MX_SIM_MODE_REAL_TIME):\n        \"\"\"Set the simulation mode configuration.\n        This configuration remains in memory, even after a power down.\n\n        Parameters\n        ----------\n            default_sim_mode : MxRobotSimulationMode\n                Default simulation mode to use when using ActivateSim command without specifying the mode.\n                The available modes are:\n                    - mx_robot_def.MxRobotSimulationMode.MX_SIM_MODE_REAL_TIME\n                    - mx_robot_def.MxRobotSimulationMode.MX_SIM_MODE_FAST\n        \"\"\"\n        super().SetSimModeCfg(default_sim_mode)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def SetPayload(self, mass: float, x: float, y: float, z: float):\n        \"\"\"Set payload mass and center of mass (in FRF) of currently carried by the robot's gripper (or external tool).\n\n        Parameters\n        ----------\n        mass : float\n            Carried mass in KG.\n        x : float\n            X coordinate of center of mass relatively to FRF\n        y : float\n            Y coordinate of center of mass relatively to FRF\n        z : float\n            Z coordinate of center of mass relatively to FRF\n\n        \"\"\"\n        super().SetPayload(mass, x, y, z)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def ActivateBrakes(self, activated: bool = True):\n        \"\"\"Enable/disable the brakes. These commands are only available when the robot is deactivated.\n\n        By default, brakes are enabled until robot is activated (brakes are automatically disabled upon activation).\n        Corresponds to text API calls \"BrakesOn\" / \"BrakesOff\".\n\n        Parameters\n        ----------\n        activated : bool\n            Engage brakes if true, otherwise disengage brakes.\n\n        \"\"\"\n        super().ActivateBrakes(activated)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRobotInfo(self) -> RobotInfo:\n        \"\"\"Return a copy of the known robot information.\n\n        Return\n        ------\n        RobotInfo\n            Object containing robot information.\n\n        \"\"\"\n        return super().GetRobotInfo()\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetRobotRtData(self, synchronous_update: bool = False, timeout: float = None) -> RobotRtData:\n        \"\"\"Return a copy of the current robot real-time data, with all values associated with the same timestamp.\n\n        *** WARNING:    Not all real-time data is sent by the robot by default.\n                        SetRealtimeMonitoring() can be used to enable more real-time data than the default ones.\n                        A non-enabled real-time data will report \"enabled\" as False\n                        (for example: GetRobotRtData().rt_joint_torq.enabled will be False if not sent by the robot)\n\n        Parameters\n        ----------\n        synchronous_update: bool\n            True -> Synchronously get all robot real-time data by waiting end of current cycle.\n            False -> Return latest known data (from previous received cyclic data) without requesting the robot.\n            *** WARNING: This position may be outdated from as much as one cycle, which duration is defined by\n                         SetMonitoringInterval().\n        timeout: float\n            Timeout (in seconds) waiting for updated cyclic data from the robot. Only used for synchronous requests.\n\n        Return\n        ------\n        RobotRtData\n            Object containing the current robot real-time data\n\n        \"\"\"\n        return super().GetRobotRtData(synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetStatusRobot(self, synchronous_update: bool = False, timeout: float = None) -> RobotStatus:\n        \"\"\"Return a copy of the current robot status\n\n        Parameters\n        ----------\n        synchronous_update: bool\n            True -> Synchronously get updated robot status. False -> Get latest known status.\n        timeout: float, defaults to DEFAULT_WAIT_TIMEOUT\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        RobotStatus\n            Object containing the current robot status\n\n        \"\"\"\n        return super().GetStatusRobot(synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetSafetyStatus(self, synchronous_update: bool = False, timeout: float = None) -> RobotSafetyStatus:\n        \"\"\"Return a copy of the current robot safety status\n\n        Parameters\n        ----------\n        synchronous_update: bool\n            True -> Synchronously get updated robot safety status. False -> Get latest known status.\n        timeout: float, defaults to DEFAULT_WAIT_TIMEOUT\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        RobotSafetyStatus\n            Object containing the current robot safety status\n\n        \"\"\"\n        return super().GetSafetyStatus(synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetSidecarStatus(self,\n                         idx: Optional[int] = None,\n                         synchronous_update: bool = False,\n                         timeout: float = None) -> Optional[RobotSidecarStatus]:\n        \"\"\"Return a copy of the current robot sidecar status\n\n        Parameters\n        ----------\n        idx: Optional[int]\n            Optional index of the sidecar instance to get status for.\n            If None, the function will return the status for the first sidecar instance connected, priority to the\n            sidecar instance embedded in the robot\n        synchronous_update: bool\n            True -> Synchronously get updated robot sidecar status. False -> Get latest known status.\n        timeout: float, defaults to DEFAULT_WAIT_TIMEOUT\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        Optional[RobotSidecarStatus]\n            Status of selected sidecar scripting engine\n\n        \"\"\"\n        return super().GetSidecarStatus(idx, synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetPowerSupplyInputs(self, synchronous_update: bool = False, timeout: float = None) -> RobotPowerSupplyInputs:\n        \"\"\"Return a copy of the current robot power supply input states\n\n        Parameters\n        ----------\n        synchronous_update: bool\n            True -> Synchronously get updated robot power supply input states. False -> Get latest known status.\n        timeout: float, defaults to DEFAULT_WAIT_TIMEOUT\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        RobotPowerSupplyInputs\n            Object containing the current robot power supply inputs status\n\n        \"\"\"\n        return super().GetPowerSupplyInputs(synchronous_update, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetCollisionStatus(self, timeout: float = None) -> CollisionStatus:\n        \"\"\"Return a copy of the current robot collision status\n\n        Parameters\n        ----------\n        timeout: float, defaults to DEFAULT_WAIT_TIMEOUT\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        CollisionStatus\n            Object containing the current robot collision status\n\n        \"\"\"\n        return super().GetCollisionStatus(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    @disconnect_on_exception_decorator\n    def GetGripperRange(self, timeout: float = None) -> Tuple[float, float]:\n        \"\"\"Return the currently configured gripper range.\n            Note that the reported values are valid only when the robot is activated and homed.\n\n        Parameters\n        ----------\n        timeout: float, defaults to DEFAULT_WAIT_TIMEOUT\n            Timeout (in seconds) waiting for synchronous response from the robot.\n\n        Returns\n        -------\n        Tuple [close_pos, open_pos]\n            Tuple indicating the close and open position of the gripper, in mm from the completely closed position\n            detected during homing.\n\n        \"\"\"\n        return super().GetGripperRange(timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    def LogTrace(self, trace: str, level: Optional[int] = None):\n        \"\"\"Send a text trace that is printed in the robot's log internal file (which can be retrieved from robot's Web\n           portal under menu \"Options -> Get Log\").\n           (useful for clearly identifying steps of a program within robot's log when reporting problems to\n            Mecademic support team!)\n\n        Parameters\n        ----------\n        trace : string\n            Text string to print in robot's internal log file\n        level : logger level\n            Local logger level to print with logging.DEBUG, logging.INFO, logging.ERROR, etc.\n            Will not print locally (only on robot) if level is None (the default)\n        \"\"\"\n        super().LogTrace(trace, level)\n\n    def StartLogging(self,\n                     monitoringInterval: float,\n                     file_name: str = None,\n                     file_path: str = None,\n                     fields: list = None,\n                     record_time: bool = True):\n        \"\"\"Start logging robot state and real-time data to a zip file that contains:\n           - a json file (robot information summary, commands sent to the robot)\n           - a csv file (real-time data received from the robot)\n\n        This function will use SetRealtimeMonitoring() to enable specified real-time data fields.\n        This function will use SetMonitoringInterval() to configure the requested monitoring interval.\n\n        Using WaitIdle before StartLogging may be useful if you want to ensure that the captured data includes\n        subsequent move commands only.\n\n        Parameters\n        ----------\n        monitoring_interval: float\n            Indicates rate at which state from robot will be received on monitor port. Unit: seconds\n\n        file_name: string or None\n            Log file name\n            If None, file name will be built with date/time and robot information (robot type, serial, version).\n\n        file_path : string or None\n            Path to save the zip file that contains logged data.\n            If not provided, file will be saved in working directory.\n\n        fields : list of strings or None\n            List of real-time data fields to log.\n            Available field names correspond to fields from the RobotRtData attributes.\n            None means log all possible real-time data.\n\n        record_time : bool\n            If true, current date and time will be recorded in file.\n        \"\"\"\n        super().StartLogging(monitoringInterval, file_name, file_path, fields, record_time)\n\n    def EndLogging(self, keep_captured_trajectory: bool = False) -> str:\n        \"\"\"Stop logging robot real-time data to file.\n        Parameters\n        ----------\n        keep_captured_trajectory: bool\n            Tells to keep a copy of captured trajectory that can be accessed later via\n            GetCapturedTrajectory()\n\n        Return\n        ------\n        string\n            Name of the zip file that contains robot information and captured trajectory\n        \"\"\"\n        return super().EndLogging(keep_captured_trajectory)\n\n    def GetCapturedTrajectory(self) -> RobotTrajectories:\n        \"\"\"Returns the most recent robot trajectory captured using StartLogging or FileLogger functions.\n\n        Returns\n        -------\n        RobotTrajectories\n            Object that contains robot information and captured trajectory information\n        \"\"\"\n        return super().GetCapturedTrajectory()\n\n    #pylint: disable=invalid-name\n    @contextlib.contextmanager\n    def FileLogger(self,\n                   monitoringInterval: float,\n                   file_name: str = None,\n                   file_path: str = None,\n                   fields: list = None,\n                   record_time: bool = True,\n                   keep_captured_trajectory: bool = False):\n        \"\"\"Contextmanager interface for file logger.\n           See StartLogging for more information.\n\n        Parameters\n        ----------\n        monitoring_interval: float\n            See StartLogging.\n        file_name: string or None\n            See StartLogging.\n        file_path : string or None\n            See StartLogging.\n        fields : list of strings or None\n            See StartLogging.\n        record_time : bool\n            See StartLogging.\n        keep_captured_trajectory: bool\n            Tells to keep a copy of captured trajectory that can be accessed later via\n            GetCapturedTrajectory()\n        \"\"\"\n        self.StartLogging(\n            monitoringInterval,\n            file_name=file_name,\n            file_path=file_path,\n            fields=fields,\n            record_time=record_time,\n        )\n        try:\n            yield\n        finally:\n            self.EndLogging(keep_captured_trajectory)\n\n    UPDATE_TIMEOUT = 15 * 60  # 15 minutes timeout\n\n    def UpdateRobot(self, firmware: Union[str, pathlib.Path], timeout=UPDATE_TIMEOUT):\n        \"\"\"\n        Install a new firmware and verifies robot version afterward.\n\n        Parameters\n        ----------\n        firmware: pathlib object or string\n            Path of robot firmware file\n\n        timeout: int\n            time in second allowed to update the robot (default: 15 minutes)\n\n        \"\"\"\n        return super().UpdateRobot(firmware, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    def CreateVariable(self,\n                       name: str,\n                       value: any,\n                       cyclic_id: Optional[int] = None,\n                       override: bool = False,\n                       timeout: Optional[float] = None):\n        \"\"\"Create a variable that is permanently saved in the robot.\n\n        Note: The variable will only be added to local namespace (robot.vars) after receiving the robot response for\n            this request. Beware of that if using this function asynchronously.\n            Use robot.Sync() if needed, or use a timeout to make this function blocking.\n        Note: You can check if the variable already exists before calling this function as follows:\n            `robot.vars.get(\"myvar\") is not None`\n\n        See description of the \"override\" argument below for details about how this function manages the case where a\n        variable with the same name already exists.\n\n        There are different ways to access a created variable:\n        robot.vars.myvar => Return the variable value only\n        robot.vars.get(\"myvar\") => Return a RegisteredVariable that contains value, cyclic_id, etc.\n        robot.GetVariable(\"myvar\") => Return a RegisteredVariable that contains value, cyclic_id, etc.\n\n        Args:\n            name (str): Name of the variable to set.\n            value (any): Value to assign to this variable. The type will be deduced from this value.\n            cyclic_id (int): Optional Id to use to reference variable in cyclic protocols (0 or None to ignore)\n            override (bool): Specifies the behavior when a variable with the same name already exists:\n                             True:  Update the value and cyclic ID with the new ones,\n                             False: Return error if the existing variable has a different type or cyclic ID,\n                                    otherwise do nothing and leave the variable unchanged.\n            timeout (float): Optional time to wait for the robot to confirm variable creation.\n                            If None:\n                                In Synchronous API mode a default timeout is used.\n                                In asynchronous mode a None timeout makes this function non-blocking (will not know\n                                if variable creation may have failed).\n        Raises\n        ------\n        ArgErrorException\n            If the robot refused the variable creation for some reason (name or cyclic ID conflict for example).\n        \"\"\"\n        super().CreateVariable(name, value, cyclic_id, override, timeout)\n\n    def CreateRegisteredVariable(self,\n                                 var: rsc.RegisteredVariable,\n                                 override: bool = False,\n                                 timeout: Optional[float] = None) -> bool:\n        \"\"\" Same as CreateVariable, but taking RegisteredVariable object instead of separate value, cyclic_id \"\"\"\n        return super().CreateVariable(name=var.name,\n                                      value=var.get_value(),\n                                      cyclic_id=var.cyclic_id,\n                                      override=override,\n                                      timeout=timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    def DeleteVariable(self, name: str, timeout: Optional[float] = None):\n        \"\"\"Delete a variable from the robot's permanently saved variables.\n\n        Note: The variable will only be removed local namespace (robot.vars) after receiving the robot response for\n            this request. Beware of that if using this function asynchronously.\n            Use robot.Sync() if needed, or use a timeout to make this function blocking.\n        Note: You can check if the variable already exists before calling this function as follows:\n            `robot.vars.get(name) is not None`\n\n        This function does nothing if the variable does not exist.\n\n        Args:\n            name (str): Name of the variable to delete.\n            timeout (float): Optional time to wait for the robot to confirm variable deletion.\n                            If None:\n                                In Synchronous API mode a default timeout is used.\n                                In asynchronous mode a None timeout makes this function non-blocking (will not know\n                                if variable deletion may have failed).\n        Raises\n        ------\n        NotFoundException\n            If the variable did not exist on the robot.\n        \"\"\"\n        super().DeleteVariable(name)\n\n    # mx:export_to=robot_sidecar_globals.py\n    def SetVariable(self, name: str, value: any, timeout: Optional[float] = None):\n        \"\"\"Set a variable that was previously created on the robot using CreateVariable.\n        This function can be synchronous or asynchronous (see timeout argument explained below).\n\n        Note: There are alternatives to SetVariable that are always synchronous (waiting for robot confirmation):\n              - The simplest way is to directly set the corresponding attribute of the robot class `robot.vars`:\n                `robot.vars.my_var = \"my_value\"\n              - Using the \"set\" method of robot.vars, which also returns the previous value\n                prev_val = `robot.vars.my_var.set(\"my_var\", \"my_value\")\n\n        Args:\n            name (str):  Name of the variable to create.\n            value (any): New value to assign to this variable. The type will be deduced from this value.\n                        The new value type must match the existing value type otherwise the robot will return an error.\n            timeout (float): Optional time to wait for the robot to confirm variable modification.\n                            If None:\n                                In Synchronous API mode a default timeout is used.\n                                In asynchronous mode a None timeout makes this function non-blocking (will not know\n                                if variable modification may have failed).\n        Raises\n        ------\n        ArgErrorException\n            If the robot refused the variable creation for some reason (name or cyclic ID conflict for example).\n        \"\"\"\n        super().SetVariable(name, value, timeout)\n\n    # mx:export_to=robot_sidecar_globals.py\n    def GetVariable(self, name: str) -> Optional[rsc.RegisteredVariable]:\n        \"\"\"Get a variable by name.\n\n        This is a non-blocking function, it searches locally in the already synchronized variables map.\n\n        This is equivalent to directly accessing the variable from `robot.vars`. For example:\n            `robot.vars.my_var` => Returns the variable value\n            `robot.vars.get(\"my_var\") => Returns a rsc.RegisteredVariable\n\n        Args:\n            name (str): The name of the variable to get value for\n\n        Returns:\n            Optional[rsc.RegisteredVariable]: The found variable, or None if no variable exist with that name\n        \"\"\"\n        return super().GetVariable(name)\n\n    # mx:export_to=robot_sidecar_globals.py\n    def GetVariableByCyclicId(self, cyclic_id: int) -> Optional[rsc.RegisteredVariable]:\n        \"\"\"Get a variable by cyclic ID.\n\n        This is a non-blocking function, it searches locally in the already synchronized variables map.\n\n        Args:\n            cyclic_id (int): The variable cyclic ID to search for\n\n        Returns:\n            Optional[rsc.RegisteredVariable]: The found variable, or None if no variable exist with that cyclic_id\n        \"\"\"\n        return super().GetVariableByCyclicId(cyclic_id)\n\n    def ListVariables(self) -> list[str]:\n        \"\"\" Return the list of robot variables.\n            This is a non-blocking function that returns a list of all variable names that are synchronized\n            with the robot.\n        \"\"\"\n        return super().ListVariables()\n\n    #####################################################################################\n    # Private methods.\n    #####################################################################################\n    def _sidecar_get_registered_attr(self, attr_name: str) -> any:\n        \"\"\" Callback for getting an attribute from local namespace.\n            This function is used (for now) to detect if a registered function will overload an existing public API\n            function from this class.\n        \"\"\"\n        # Note: DO NOT CALL super()._sidecar_get_registered_attr() because here we really want to get an attribute\n        #       of this derived class (for example, SetBlending or any function that does not exist on the base class).\n        return getattr(Robot, attr_name, None)\n\n    def _sidecar_set_registered_attr(self, attr_name: str, attr_val: any):\n        \"\"\" Callback for setting an attribute from local namespace \"\"\"\n        # Set in both parent class' namespace\n        super()._sidecar_set_registered_attr(attr_name, attr_val)\n        setattr(Robot, attr_name, attr_val)\n\n    def _sidecar_del_registered_attr(self, attr_name: str):\n        \"\"\" Callback for deleting an attribute from local namespace \"\"\"\n        # Delete from both parent class' namespace\n        super()._sidecar_del_registered_attr(attr_name)\n        delattr(Robot, attr_name)",
    "span": [
      36,
      3144
    ],
    "start_byte": 1008,
    "end_byte": 138258,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot.py",
    "name": "Robot"
  }
]