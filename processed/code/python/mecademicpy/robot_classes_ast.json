[
  {
    "snippet": "import json",
    "span": [
      9,
      9
    ],
    "start_byte": 444,
    "end_byte": 455,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py"
  },
  {
    "snippet": "import re",
    "span": [
      10,
      10
    ],
    "start_byte": 456,
    "end_byte": 465,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py"
  },
  {
    "snippet": "import threading",
    "span": [
      11,
      11
    ],
    "start_byte": 466,
    "end_byte": 482,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py"
  },
  {
    "snippet": "import time",
    "span": [
      12,
      12
    ],
    "start_byte": 483,
    "end_byte": 494,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py"
  },
  {
    "snippet": "from typing import Callable, Optional, Union",
    "span": [
      13,
      13
    ],
    "start_byte": 495,
    "end_byte": 539,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py"
  },
  {
    "snippet": "import mecademicpy.tools as tools",
    "span": [
      15,
      15
    ],
    "start_byte": 541,
    "end_byte": 574,
    "node_type": "import_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py"
  },
  {
    "snippet": "from .mx_robot_def import *",
    "span": [
      18,
      18
    ],
    "start_byte": 633,
    "end_byte": 660,
    "node_type": "import_from_statement",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py"
  },
  {
    "snippet": "class RtDataUpdateType(IntEnum):\n    MX_RT_DATA_UPDATE_TYPE_UNAVAILABLE = 0  # Data is not available\n    MX_RT_DATA_UPDATE_TYPE_CYCLICAL = 1  # Data is sent every cycle\n    MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL = 2  # Data sent every cycle when configured through SetRealTimeMonitoring\n    MX_RT_DATA_UPDATE_TYPE_EVENT_BASED = 3  # Data is sent upon connection and updated when its values change",
    "span": [
      30,
      34
    ],
    "start_byte": 927,
    "end_byte": 1325,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "RtDataUpdateType"
  },
  {
    "snippet": "class Message:\n    \"\"\"Class for storing a response message from a Mecademic robot.\n\n    Attributes\n    ----------\n    id : integer\n        The id of the message, representing the type of message.\n    data : string\n        The raw payload of the message.\n    json_data : JSON data parsed as a dictionary. None if message is not JSON format.\n                Robot JSON message format is:\n                {\n                   MX_JSON_KEY_CODE:int,\n                   MX_JSON_KEY_META_DATA:{\n                       MX_JSON_KEY_MSG_TYPE:int\n                   },\n                   MX_JSON_KEY_DATA:{\n                       (per-code JSON arguments/values)\n                   }\n\"\"\"\n\n    # pylint: disable=redefined-builtin\n    def __init__(self, id: int, data: str, json_data: dict | None = None):\n        self.id = id\n        self.data = data\n        self.json_data = json_data\n\n    def __repr__(self):\n        return f\"Message with id={self.id}, data={self.data}\"\n\n    @classmethod\n    def from_string(cls, input: str):\n        \"\"\"Construct message object from raw string input.\n\n        Parameters\n        ----------\n        input : string\n            Input string to convert to message.\n\n        \"\"\"\n        id = 0\n        data = \"\"\n        json_data = {}\n        if len(input) == 0:\n            pass\n        elif input[0] == '{':\n            # JSON format\n            json_data = json.loads(input)\n            # Extract id from JSON payload\n            id = json_data[MX_JSON_KEY_CODE]\n            # Keep whole unparsed JSON string as raw data\n            data = input\n        else:\n            # Legacy format\n            id_start = input.find('[') + 1\n            id_end = input.find(']', id_start)\n            id = int(input[id_start:id_end])\n\n            # Find next square brackets (contains data).\n            data_start = input.find('[', id_end) + 1\n            data_end = input.rfind(']')\n\n            data = ''\n            if data_start != -1 and data_end != -1:\n                data = input[data_start:data_end]\n\n        return cls(id, data, json_data)",
    "span": [
      40,
      106
    ],
    "start_byte": 1539,
    "end_byte": 3601,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "Message"
  },
  {
    "snippet": "class MecademicException(Exception):\n    \"\"\"Base exception class for Mecademic-related exceptions.\n\"\"\"\n\n    def __init__(self, message: str):\n        \"\"\" Initialize this base exception\n\n        Args:\n            message (str):\n                User message to print\n        \"\"\"\n        self.message = message\n        super().__init__(self.message)\n\n    pass",
    "span": [
      114,
      128
    ],
    "start_byte": 3827,
    "end_byte": 4183,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "MecademicException"
  },
  {
    "snippet": "class MecademicFatalException(MecademicException):\n    \"\"\"Class for all mecademic exceptions that should be considered fatal (stack trace should be printed).\n\"\"\"\n    pass",
    "span": [
      131,
      134
    ],
    "start_byte": 4186,
    "end_byte": 4356,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "MecademicFatalException"
  },
  {
    "snippet": "class MecademicNonFatalException(MecademicException):\n    \"\"\"Class for all mecademic exceptions that should be considered non fatal (can be catch, error printed, and\n       application may continue).\n\"\"\"\n    pass",
    "span": [
      137,
      141
    ],
    "start_byte": 4359,
    "end_byte": 4571,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "MecademicNonFatalException"
  },
  {
    "snippet": "class InvalidStateError(MecademicNonFatalException):\n    \"\"\"The internal state of the instance is invalid.\n\"\"\"\n    pass",
    "span": [
      144,
      147
    ],
    "start_byte": 4574,
    "end_byte": 4693,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "InvalidStateError"
  },
  {
    "snippet": "class InvalidConfigError(MecademicNonFatalException):\n    \"\"\"Invalid config is used.\n    \"\"\"\n    pass",
    "span": [
      150,
      153
    ],
    "start_byte": 4696,
    "end_byte": 4797,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "InvalidConfigError"
  },
  {
    "snippet": "class CommunicationError(MecademicNonFatalException):\n    \"\"\"There is a communication issue with the robot.\n\"\"\"\n    pass",
    "span": [
      156,
      159
    ],
    "start_byte": 4800,
    "end_byte": 4920,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "CommunicationError"
  },
  {
    "snippet": "class DisconnectError(MecademicNonFatalException):\n    \"\"\"A non-nominal disconnection has occurred.\n\"\"\"\n    pass",
    "span": [
      162,
      165
    ],
    "start_byte": 4923,
    "end_byte": 5035,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "DisconnectError"
  },
  {
    "snippet": "class InterruptException(MecademicNonFatalException):\n    \"\"\"An event has encountered an error. Perhaps it will never be set.\n\"\"\"\n    pass",
    "span": [
      168,
      171
    ],
    "start_byte": 5038,
    "end_byte": 5176,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "InterruptException"
  },
  {
    "snippet": "class TimeoutException(MecademicNonFatalException):\n    \"\"\"Requested timeout during a blocking operation (synchronous mode or Wait* functions) has been reached.\n       (raised by InterruptableEvent)\"\"\"\n    pass",
    "span": [
      174,
      177
    ],
    "start_byte": 5179,
    "end_byte": 5389,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "TimeoutException"
  },
  {
    "snippet": "class NotFoundException(MecademicNonFatalException):\n    \"\"\"A method, variable or object was not found\"\"\"\n    pass",
    "span": [
      180,
      182
    ],
    "start_byte": 5392,
    "end_byte": 5506,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "NotFoundException"
  },
  {
    "snippet": "class ArgErrorException(MecademicNonFatalException):\n    \"\"\"An argument was invalid, the operation could not be completed\"\"\"\n    pass",
    "span": [
      185,
      187
    ],
    "start_byte": 5509,
    "end_byte": 5642,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "ArgErrorException"
  },
  {
    "snippet": "class RobotCallbacks:\n    \"\"\"Class for storing possible status events for the Mecademic robot.\n\n    Attributes\n    ----------\n        on_connected : function object\n            Function to be called once connected.\n        on_disconnected : function object\n            Function to be called once disconnected.\n        on_status_updated : function object\n            Function to be called once robot status is updated.\n\n        on_status_gripper_updated : function object\n            Function to be called once gripper status is updated (legacy, use following external tools callbacks).\n        on_external_tool_status_updated: function object\n            Function to be called once external tool status is updated.\n        on_gripper_state_updated: function object\n            Function to be called once gripper state is updated.\n        on_valve_state_updated: function object\n            Function to be called once valve state is updated.\n\n        on_output_state_updated: function object\n            Function to be called when digital outputs changed.\n        on_input_state_updated: function object\n            Function to be called when digital inputs changed.\n        on_vacuum_state_updated: function object\n            Function to be called once vacuum state is updated.\n\n        on_activated : function object\n            Function to be called once activated.\n        on_deactivated : function object\n            Function to be called once deactivated.\n        on_homed : function object\n            Function to be called once homing is complete.\n        on_error : function object\n            Function to be called if robot enters an error state.\n        on_error_reset : function object\n            Function to be called once error is reset.\n\n        on_safety_stop : function object\n            Function to be called when the robot enters safety stop state following a raised safety stop conditions\n            (EStop, PStop1, PStop2, etc.).\n            Note that on_safety_stop_state_change can be used to be notified of more safety stop conditions that change\n            while the robot is already in safety stop.\n        on_safety_stop_reset : function object\n            Function to be called when all safety stop conditions (EStop, PStop1, PStop2, ...) are cleared (reset)\n        on_safety_stop_resettable : function object\n            Function to be called when all safety stop conditions (EStop, PStop1, PStop2, ...) can be reset\n            i.e. the safety stop conditions are no more present and need a reset (Power supply reset button in some\n            cases, or simply ResumeMotion in other cases)\n        on_safety_stop_state_change : function object\n            Function to be called when any safety stop state change (see RobotSafetyStatus)\n\n        on_pstop2 : function object\n            Function to be called if PStop2 is activated.\n            *** DEPRECATED (replaced by on_safety_stop_state)\n        on_pstop2_resettable : function object\n            Function to be called when PStop2 condition can be reset\n            (i.e. the power supply PStop2 signal is no more asserted)\n            *** DEPRECATED (replaced by on_safety_stop_state)\n        on_pstop2_reset : function object\n            Function to be called if PStop2 is reset.\n            *** DEPRECATED (replaced by on_safety_stop_state)\n        on_estop : function object\n            Function to be called if EStop is activated.\n            *** DEPRECATED (replaced by on_safety_stop_state)\n        on_estop_reset : function object\n            Function to be called if EStop is reset.\n            *** DEPRECATED (replaced by on_safety_stop_state)\n        on_estop_resettable : function object\n            Function to be called when EStop condition can be reset\n            (i.e. the power supply EStop signal is no more asserted)\n            *** DEPRECATED (replaced by on_safety_stop_state)\n\n        on_motion_paused : function object\n            Function to be called once motion is paused.\n        on_motion_cleared : function object\n            Function to be called once motion is cleared.\n        on_motion_resumed : function object\n            Function to be called once motion is resumed.\n        on_checkpoint_reached : function object\n            Function to be called if a checkpoint is reached.\n        on_checkpoint_discarded : function object\n            Function to be called if a checkpoint is discarded\n            (due to motion cleared, robot deactivated, robot in error, safety stop, etc.).\n\n        on_activate_sim : function object\n            Function to be called once sim mode is activated.\n        on_deactivate_sim : function object\n            Function to be called once sim mode is deactivated.\n        on_activate_ext_tool_sim : function object\n            Function to be called once gripper sim mode is activated.\n        on_deactivate_ext_tool_sim : function object\n            Function to be called once gripper sim mode is deactivated.\n        on_io_sim_enabled : function object\n            Function to be called once IO simulation mode is enabled.\n        on_io_sim_disabled : function object\n            Function to be called once IO simulation mode is disabled.\n\n        on_activate_recovery_mode : function object\n            Function to be called once recovery mode is activated.\n        on_deactivate_recovery_mode : function object\n            Function to be called once recovery mode is deactivated.\n\n        on_command_message : function object\n            Function to be called each time a command response is received.\n        on_monitor_message : function object\n            Function to be called each time an event is received on the monitoring port.\n            Only available when connected to the robot in monitoring mode.\n            Note that on_monitor_message may not be very useful. We suggest to use on_end_of_cycle instead\n            (which works for both monitoring or control mode connections).\n\n        on_offline_program_state : function object\n            Function to be called each time an offline program starts or fails to start.\n\n        on_end_of_cycle : function object\n            Function to be called each time end of cycle is reached.\n            It's called once all real-time data for current monitoring interval has been received.\n            At this moment, all robot real-time data is coherent (belongs to the same cycle).\n            \"\"\"\n\n    def __init__(self):\n        self.on_connected: Callable[[], None] = None\n        self.on_disconnected: Callable[[], None] = None\n\n        self.on_status_updated: Callable[[], None] = None\n        self.on_status_gripper_updated: Callable[[], None] = None\n\n        self.on_external_tool_status_updated: Callable[[], None] = None\n        self.on_gripper_state_updated: Callable[[], None] = None\n        self.on_valve_state_updated: Callable[[], None] = None\n        self.on_output_state_updated: Callable[[], None] = None\n        self.on_input_state_updated: Callable[[], None] = None\n        self.on_vacuum_state_updated: Callable[[], None] = None\n\n        self.on_activated: Callable[[], None] = None\n        self.on_deactivated: Callable[[], None] = None\n\n        self.on_homed: Callable[[], None] = None\n\n        self.on_error: Callable[[], None] = None\n        self.on_error_reset: Callable[[], None] = None\n        self.on_safety_stop_resettable: Callable[[], None] = None\n        self.on_safety_stop_reset: Callable[[], None] = None\n        self.on_safety_stop_state_change: Callable[[], None] = None\n\n        self.on_pstop2: Callable[[], None] = None\n        self.on_pstop2_resettable: Callable[[], None] = None\n        self.on_pstop2_reset: Callable[[], None] = None\n        self.on_estop: Callable[[], None] = None\n        self.on_estop_resettable: Callable[[], None] = None\n        self.on_estop_reset: Callable[[], None] = None\n\n        self.on_motion_paused: Callable[[], None] = None\n        self.on_motion_cleared: Callable[[], None] = None\n        self.on_motion_resumed: Callable[[], None] = None\n\n        self.on_checkpoint_reached: Callable[[int], None] = None\n        self.on_checkpoint_discarded: Callable[[int], None] = None\n\n        self.on_activate_sim: Callable[[], None] = None\n        self.on_deactivate_sim: Callable[[], None] = None\n\n        self.on_activate_ext_tool_sim: Callable[[], None] = None\n        self.on_deactivate_ext_tool_sim: Callable[[], None] = None\n        self.on_io_sim_enabled: Callable[[], None] = None\n        self.on_io_sim_disabled: Callable[[], None] = None\n\n        self.on_activate_recovery_mode: Callable[[], None] = None\n        self.on_deactivate_recovery_mode: Callable[[], None] = None\n\n        self.on_command_message: Callable[[Message], None] = None\n        self.on_monitor_message: Callable[[Message], None] = None\n\n        self.on_offline_program_state: Callable[[], None] = None\n\n        self.on_end_of_cycle: Callable[[], None] = None",
    "span": [
      190,
      366
    ],
    "start_byte": 5645,
    "end_byte": 14564,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "RobotCallbacks"
  },
  {
    "snippet": "class InterruptableEvent:\n    \"\"\"Extend default event class to also be able to unblock and raise an exception in case the event becomes\n       irrelevant and will not occur (for example: Waiting on a checkpoint when robot is in error)\n\n    Attributes\n    ----------\n    id : int or None\n        Id for event.\n    _event : event object\n        A standard event-type object.\n    _lock : lock object\n        Used to ensure atomic operations.\n    _interrupted : boolean\n        If true, event is in an error state.\n    _interrupted_msg : string\n        User message that explains the reason of interruption.\n    _abort_on_error : bool\n        Tells if this event must be awakened if the robot falls into error state, by default False\n    _abort_on_clear_motion : bool\n        Tells if this event must be awakened if the robot's motion queue is cleared\n        Note that this also includes PStop2 condition and robot deactivation (which also cause the motion queue\n        to be cleared)\n\"\"\"\n\n    # pylint: disable=redefined-builtin\n    def __init__(self, id=None, data=None, abort_on_error=False, abort_on_clear_motion=False):\n        self._id = id\n        self._data = data\n        self._event = threading.Event()\n        self._lock = threading.Lock()\n        self._interrupted = False\n        self._interrupted_msg = \"\"\n        self._abort_on_error = abort_on_error\n        self._abort_on_clear_motion = abort_on_clear_motion\n\n    def check_interrupted(self):\n        if self._interrupted:\n            if self._interrupted_msg != \"\":\n                raise InterruptException(self._interrupted_msg)\n            else:\n                raise InterruptException('Event interrupted, possibly because event will never be triggered.')\n\n    def wait(self, timeout: float = None) -> Message:\n        \"\"\"Block until event is set or should raise an exception (InterruptException or TimeoutException).\n           InterruptException is raised if waiting for the event has become irrelevant, like waiting for\n           a checkpoint while robot is in error.\n\n        Attributes\n        ----------\n        timeout : float\n            Maximum duration to wait in seconds.\n\n        Return\n        ------\n        data : object\n            Return the data object (or None for events not returning any data)\n\n        \"\"\"\n        with self._lock:\n            self.check_interrupted()\n        start_time = time.monotonic()\n        # Wait by smaller chunks to we can get interrupted by OS signals (like SIGINT)\n        partial_timeout = 0.1 if timeout is None else min(timeout, 0.1)\n        while True:\n            is_set = self._event.wait(timeout=partial_timeout)\n            if is_set:\n                break\n            self.check_interrupted()\n            if timeout is not None and time.monotonic() - start_time > timeout:\n                raise TimeoutException(\"Timeout waiting for interruptable event\")\n        with self._lock:\n            self.check_interrupted()\n            return self._data\n\n    def set(self, data: Message = None):\n        \"\"\"Set the event and unblock all waits. Optionally modify data before setting.\n\n        \"\"\"\n        with self._lock:\n            self._data = data\n            self._event.set()\n\n    def abort(self, message=\"\"):\n        \"\"\"Unblock any waits and raise an exception.\n\n        \"\"\"\n        with self._lock:\n            if not self._event.is_set():\n                self._interrupted_msg = message\n                self._interrupted = True\n                self._event.set()  # Awake all threads\n                self._event.clear()  # Restore previous state (important to keep state even if interrupted)\n\n    def clear(self):\n        \"\"\"Reset the event to its initial state.\n\n        \"\"\"\n        with self._lock:\n            self._interrupted = False\n            self._event.clear()\n\n    def is_set(self) -> bool:\n        \"\"\"Checks if the event is set.\n\n        Return\n        ------\n        boolean\n            False if event is not set or instance should '_interrupted'. True otherwise.\n\n        \"\"\"\n        with self._lock:\n            if self._interrupted:\n                return False\n            else:\n                return self._event.is_set()\n\n    def clear_abort(self):\n        \"\"\"Clears the abort to make waiting for the event blocking again.\n\n        \"\"\"\n        with self._lock:\n            if self._interrupted:\n                self._interrupted = False\n\n    @property\n    def id(self) -> int:\n        \"\"\"Make id a read-only property since it should not be changed after instantiation.\n\n        \"\"\"\n        return self._id\n\n    @property\n    def data(self) -> Message:\n        \"\"\"Make data a read-only property and enforce that it is only assignable at construction or using set().\n\n        \"\"\"\n        return self._data",
    "span": [
      369,
      505
    ],
    "start_byte": 14567,
    "end_byte": 19318,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "InterruptableEvent"
  },
  {
    "snippet": "class RobotVersion:\n    \"\"\"\n        Robot utility class to handle firmware version.\n\n    Attributes\n    ----------\n\n    build : integer\n        Firmware build number, None if unavailable\n\n    extra : string\n        Firmware version 'extra' name, None if unavailable\n\n    full_version : string\n        Full firmware version containing major.minor.patch.build-extra\n\n    major : integer\n        Major firmware version value\n\n    minor : integer\n        Minor firmware version value\n\n    patch : integer\n        Patch firmware version value\n\n    short_version : string\n        Firmware version containing major.minor.patch only\n\n    \"\"\"\n\n    REGEX_VERSION_BUILD = r\"(?P<version>\\d+\\.\\d+\\.\\d+)\\.?(?P<build>\\d+)?-?(?P<extra>.*)\"\n\n    def __init__(self, version: str):\n        \"\"\"Creates\n\n        :param version: version of firmware. See update_version for supported formats\n        \"\"\"\n        self.full_version = version\n        self.update_version(self.full_version)\n\n    def __str__(self) -> str:\n        return self.full_version\n\n    def __lt__(self, other: RobotVersion) -> bool:\n        \"\"\"\" Less than implementation\n        \"\"\"\n        return not self.is_at_least(other.major, other.minor, other.patch, other.build)\n\n    def get_str(self, build=False, extra=False) -> str:\n        \"\"\"Get version string\n\n        Parameters\n        ----------\n        build : bool, optional\n            Include the build number in the version (ex:9.3.0.4739), by default False\n        extra : bool, optional\n            Include the build 'extra in the version (ex:9.3.0.4739-master), by default False\n\n        Returns\n        -------\n        str\n            Formatted version string\n        \"\"\"\n        version_to_return = self.short_version\n        if build and self.build:\n            version_to_return += f'.{self.build}'\n        if extra and self.extra:\n            version_to_return += f'-{self.extra}'\n        return version_to_return\n\n    def update_version(self, version: str):\n        \"\"\"Update object firmware version values by parsing a version string.\n\n        :param version: string\n            New version of firmware. Supports multiple version formats\n            ie. 8.1.9, 8.4.3.1805-official\n        \"\"\"\n        self.short_version = '0.0.0'\n\n        regex_version = re.search(self.REGEX_VERSION_BUILD, version)\n        if regex_version is None:\n            raise ValueError(f'Invalid version format: \"{version}\"')\n        if regex_version.group(\"version\"):\n            self.short_version = regex_version.group(\"version\")\n\n        splitted_version = self.short_version.split(\".\")\n        self.major = int(splitted_version[0])\n        self.minor = int(splitted_version[1])\n        self.patch = int(splitted_version[2])\n        self.build = None\n        self.extra = None\n        if regex_version.group(\"build\"):\n            self.build = int(regex_version.group(\"build\"))\n        if regex_version.group(\"extra\"):\n            self.extra = regex_version.group(\"extra\")\n\n        self.full_version = self.get_str(build=True, extra=True)\n\n    def is_at_least(self, major, minor=0, patch=0, build=0) -> bool:\n        \"\"\"Tells if this RobotInfo instance's version is at least the specified version\n\n        Parameters\n        ----------\n        major : integer\n            Minimum desired major version\n        minor : integer\n            Minimum desired minor version\n        patch : integer\n            Minimum desired patch version\n        build : integer\n            Minimum desired build version\n\n        Returns\n        -------\n        boolean\n            True if this RobotInfo instance's version is at least the specified version\n        \"\"\"\n        # Check major\n        if self.major > major:\n            return True\n        elif self.major < major:\n            return False\n\n        # Same major, check minor\n        if self.minor > minor:\n            return True\n        elif self.minor < minor:\n            return False\n\n        # Same minor, check patch\n        if self.patch > patch:\n            return True\n        elif self.patch < patch:\n            return False\n\n        if build == 0 or build is None:\n            # Don't need to check build\n            return True\n\n        # Same patch, check build\n        if self.build is not None:\n            if self.build >= build:\n                return True\n        else:\n            # Build is not known, we can't make sure we're ok\n            return False\n\n        return False",
    "span": [
      508,
      655
    ],
    "start_byte": 19321,
    "end_byte": 23755,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "RobotVersion"
  },
  {
    "snippet": "class RobotInfo:\n    \"\"\"Class for storing metadata about a robot.\n\n    Attributes\n    ----------\n    robot_model: MxRobotModel\n        Model of robot\n    model : string\n        Model of robot (legacy, use robot_model instead since it's an enum with well-known values)\n    revision : int\n        Robot revision.\n    is_virtual : bool\n        True if is a virtual robot.\n    is_safe_boot : bool\n        True if is booted in safe-boot mode.\n    version : str\n        robot firmware revision number as received from the connection string.\n    serial : string\n        Serial identifier of robot.\n    ip_address : string\n        IP address of this robot.\n    rt_message_capable : bool\n        True if robot is capable of sending real-time monitoring messages.\n    rt_on_ctrl_port_capable : bool\n        True if robot is capable of sending real-time monitoring messages on control port (SetCtrlPortMonitoring).\n    sidecar_capable : bool\n        True if robot supports running the sidecar scripting engine.\n    num_joints : int\n        Number of joints on the robot.\n    requires_homing : bool\n        Tells if this robot requires homing.\n    supports_ext_tool : bool\n        Tells if this robot supports connecting external tools (gripper or valve box).\n    supports_io_module : bool\n        Tells if this robot supports IO expansion module.\n    supports_manual_mode : bool\n        Tells if this robot supports manual mode.\n    gripper_pos_ctrl_capable : bool\n        Tells if this robot supports gripper position control.\n    ext_tool_version_capable : bool\n        Tells if this robot supports external tool fw version fetch.\n    ext_tool_version : str\n        External tool firmware revision number as received from the connection string.\n        Version 0.0.0.0 if device isn't connected or ext_tool_version_capable == False.\n    supports_joint_vel_limit : bool\n        Tells if this robot supports SetJointVelLimit\n    supports_set_payload : bool\n        Tells if this robot supports SetPayload\n    supports_torque_limits : bool\n        Tells if this robot supports SetTorqueLimits and SetTorqueLimitsCfg\n    supports_conf_turn : bool\n        Tells if this robot supports SetConfTurn\n    supports_time_scaling : bool\n        Tells if this robot supports SetTimeScaling\n    supports_checkpoint_discarded : bool\n        Tells if this robot supports reporting discarded checkpoints (MX_ST_CHECKPOINT_DISCARDED)\n    supports_move_duration : bool\n        Tells if this robot supports time-based movements (SetMoveDuration, SetMoveMode, ...)\n\"\"\"\n\n    def __init__(self,\n                 model: str = 'Unknown',\n                 revision: int = 0,\n                 is_virtual: bool = False,\n                 is_safe_boot: bool = False,\n                 version: str = '0.0.0',\n                 serial: str = '',\n                 ext_tool_version: str = '0.0.0.0'):\n        self.robot_model = MxRobotModel.MX_ROBOT_MODEL_UNKNOWN\n        self.model = model\n        self.revision = revision\n        self.is_virtual = is_virtual\n        self.is_safe_boot = is_safe_boot\n        self.version = RobotVersion(version)\n        self.serial = serial\n        self.ip_address = None  # Set later\n        self.rt_message_capable = False\n        self.rt_on_ctrl_port_capable = False\n        self.sidecar_capable = False\n        self.gripper_pos_ctrl_capable = False\n        self.ext_tool_version_capable = False\n        self.ext_tool_version = RobotVersion(ext_tool_version)\n        self.supports_io_module = False\n        self.supports_manual_mode = False\n        self.supports_joint_vel_limit = False\n        self.supports_set_payload = False\n        self.supports_torque_limits = False\n        self.supports_conf_turn = False\n        self.supports_time_scaling = False\n        self.supports_checkpoint_discarded = False\n        self.supports_move_duration = False\n\n        if self.model.upper() == MX_ROBOT_MODEL_OFFICIAL_NAME_M500.upper():\n            if self.revision == 1:\n                self.robot_model = MxRobotModel.MX_ROBOT_MODEL_M500_R1\n            elif self.revision == 2:\n                self.robot_model = MxRobotModel.MX_ROBOT_MODEL_M500_R2\n            elif self.revision == 3:\n                self.robot_model = MxRobotModel.MX_ROBOT_MODEL_M500_R3\n            elif self.revision == 4:\n                self.robot_model = MxRobotModel.MX_ROBOT_MODEL_M500_R4\n            self.num_joints = 6\n            self.requires_homing = True\n            self.supports_ext_tool = True\n            self.supports_io_module = False\n        elif self.model.upper() == MX_ROBOT_MODEL_OFFICIAL_NAME_MCS500.upper():\n            self.robot_model = MxRobotModel.MX_ROBOT_MODEL_MCS500_R1\n            self.num_joints = 4\n            self.requires_homing = False\n            self.supports_ext_tool = False\n            self.supports_io_module = True\n            self.supports_manual_mode = True\n        elif self.model.upper() == MX_ROBOT_MODEL_OFFICIAL_NAME_MCA250.upper():\n            self.robot_model = MxRobotModel.MX_ROBOT_MODEL_MCA250_R1\n            self.num_joints = 6\n            self.requires_homing = False\n            self.supports_ext_tool = False\n            self.supports_io_module = True\n            self.supports_manual_mode = True\n        elif self.model.upper() == MX_ROBOT_MODEL_OFFICIAL_NAME_MCA1000.upper():\n            self.robot_model = MxRobotModel.MX_ROBOT_MODEL_MCA1000_R1\n            self.num_joints = 6\n            self.requires_homing = False\n            self.supports_ext_tool = False\n            self.supports_io_module = True\n            self.supports_manual_mode = True\n        elif self.model.upper() == 'UNKNOWN':\n            self.robot_model = MxRobotModel.MX_ROBOT_MODEL_UNKNOWN\n            self.num_joints = 1\n            self.requires_homing = False\n            self.supports_ext_tool = False\n            self.supports_ext_tool = False\n        else:\n            self.robot_model = MxRobotModel.MX_ROBOT_MODEL_UNKNOWN\n            raise ValueError(f'Invalid robot model: {self.model}')\n\n        # Check if this robot supports real-time monitoring events\n        if self.version.is_at_least(8, 4):\n            self.rt_message_capable = True\n        # Check if this robot supports real-time monitoring on control port\n        if self.version.is_at_least(9, 0):\n            self.rt_on_ctrl_port_capable = True\n        # Check if this robot supports the sidecar scripting engine\n        if self.version.is_at_least(11, 1, 3):\n            self.sidecar_capable = True\n        # Check if this robot supports gripper position control\n        if self.version.is_at_least(9, 1):\n            self.gripper_pos_ctrl_capable = True\n        if self.version.is_at_least(9, 1, 5):\n            # Check if this robot supports external tool version\n            self.ext_tool_version_capable = True\n        if self.version.is_at_least(9, 3):\n            self.supports_joint_vel_limit = True\n            self.supports_set_payload = True\n            self.supports_torque_limits = True\n            self.supports_conf_turn = True\n        if self.version.is_at_least(10, 0, 1):\n            self.supports_time_scaling = True\n        if self.version.is_at_least(10, 2, 1):\n            self.supports_checkpoint_discarded = True\n        if self.version.is_at_least(11, 1, 2):\n            self.supports_move_duration = True\n\n    def __str__(self):\n        safe_boot_str = \" SAFE-BOOT\" if self.is_safe_boot else \"\"\n        return (f\"Connected to {self.ip_address}: \"\n                f\"{self.model} R{self.revision} {self.serial} v{self.version}{safe_boot_str}\")\n\n    def __repr__(self):\n        return str(self)\n\n    @classmethod\n    def from_command_response_string(cls, input_string: str):\n        \"\"\"Generate robot information from standard robot connection response string.\n\n        String format should be \"Connected to {model} R{revision}{-virtual} v{fw_major_num}.{fw_minor_num}.{patch_num}\"\n\n        Parameters\n        ----------\n        input_string : string\n            Input string to be parsed.\n\n        \"\"\"\n        connection_string_regex = r\"Connected to (?P<model>[\\w|-]+) ?R?(?P<revision>\\d)?\"\n        connection_string_regex += r\"(?P<virtual>-virtual)?(?P<safe_boot>-safe-boot)?( v|_)?(?P<version>\\d+\\.\\d+\\.\\d+)\"\n\n        model: str = \"Unknown\"\n        revision = 0\n        virtual = False\n        safe_boot = False\n\n        try:\n            robot_info_regex = re.search(connection_string_regex, input_string)\n            if robot_info_regex is None:\n                raise ValueError(f'Could not parse robot info string \"{input_string}\"')\n            if robot_info_regex.group('model'):\n                model = robot_info_regex.group('model')\n            if robot_info_regex.group('revision'):\n                revision = int(robot_info_regex.group('revision'))\n            if robot_info_regex.group('virtual'):\n                virtual = True\n            if robot_info_regex.group('safe_boot'):\n                safe_boot = True\n            return cls(model=model,\n                       revision=revision,\n                       is_virtual=virtual,\n                       is_safe_boot=safe_boot,\n                       version=robot_info_regex.group('version'))\n        except Exception as exception:\n            raise ValueError(f'Could not parse robot info string \"{input_string}\", error: {exception}') from exception\n\n    def get_serial_digit(self) -> int:\n        \"\"\"Returns robot serial digits.\n           ie. M500-0123 -> 123 (for Meca500)\n            or\n           ie. 0123 -> 123 (for other)\n\n        Returns\n        -------\n        int\n            Returns robot serial digits\n        \"\"\"\n        if self.robot_model == MxRobotModel.MX_ROBOT_MODEL_M500_R4:\n            serial_digit = self._get_meca500_serial_digits()\n        elif self.robot_model == MxRobotModel.MX_ROBOT_MODEL_M500_R3:\n            serial_digit = self._get_meca500_serial_digits()\n        elif self.robot_model == MxRobotModel.MX_ROBOT_MODEL_M500_R2:\n            serial_digit = self._get_meca500_serial_digits()\n        else:\n            # This should cover mcs500 and all new future hardwares\n            serial_digit = int(self.serial)\n        return serial_digit\n\n    def _get_meca500_serial_digits(self) -> int:\n        \"\"\"Returns robot serial digits.\n           ie. M500-0123 -> 123\n\n        Returns\n        -------\n        int\n            Returns robot serial digits\n        \"\"\"\n        serial_split = self.serial.split('-')\n\n        if len(serial_split) != 2:\n            raise ValueError(f'Invalid serial number string received: {self.serial}, expecting \"M500-1234\"')\n\n        return int(serial_split[1])",
    "span": [
      658,
      905
    ],
    "start_byte": 23758,
    "end_byte": 34335,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "RobotInfo"
  },
  {
    "snippet": "class UpdateProgress:\n    \"\"\"Class for storing the robot's firmware update status.\n\n    Attributes\n    ----------\n    in_progress : bool\n        Firmware update is in progress\n    complete : bool\n        Firmware update has completed\n    version : str\n        The firmware version being installed\n    error : boolean\n        Tells if the update failed\n    error_msg : str\n        Message that explains why the update failed\n    progress : str\n        Update progress message received from robot\n    step : str\n        String that describes the current firmware update step being performed\n\n    _last_print_timestamp : float\n        Last time we have printed the firmware update status\n\"\"\"\n\n    def __init__(self):\n        # The following are status fields.\n        self.in_progress = False\n        self.complete = False\n        self.version = \"\"\n        self.error = False\n        self.error_msg = \"\"\n        self.progress = 0.0\n        self.progress_str = \"\"  # For legacy update\n        self.step = \"\"\n\n        self._last_print_timestamp = 0.0",
    "span": [
      908,
      943
    ],
    "start_byte": 34338,
    "end_byte": 35383,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "UpdateProgress"
  },
  {
    "snippet": "class TimestampedData:\n    \"\"\" Class for storing timestamped data (real-time data received from the robot)\n\n    Attributes\n    ----------\n    timestamp : number-like\n        Monotonic timestamp associated with data (in microseconds since robot last reboot)\n        This timestamp is stamped by the robot so it is not affected by host/network jitter\n    data : object\n        Data to be stored.\n    update_type : RtDataUpdateType\n        Update type of the TimestampedData. Refer to RtDataUpdateType for the various update types.\n\"\"\"\n\n    def __init__(self, timestamp: int, data: list[float], update_type: RtDataUpdateType):\n        self.timestamp = timestamp\n        self.data = data\n        self.update_type = update_type\n        self.enabled = False if (update_type == RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL\n                                 or update_type == RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_UNAVAILABLE) else True\n\n    def __str__(self):\n        return str([self.timestamp] + self.data)\n\n    def __repr__(self):\n        return str(self)\n\n    def clear_if_disabled(self):\n        \"\"\"Clear timestamp and data if not reported by the robot (not part of enabled real-time monitoring events)\n        \"\"\"\n        if not self.enabled:\n            self.timestamp = 0\n            self.data = TimestampedData.zeros(len(self.data), self.update_type).data\n\n    def update_from_csv(self, input_string: str, allowed_nb_val: list[int] = None):\n        \"\"\"Update from comma-separated string, only if timestamp is newer.\n\n        Parameters\n        ----------\n        input_string : string\n            Comma-separated string. First value is timestamp, rest is data.\n        allowed_nb_val : list[int]\n            Optional list of accepted number of values. If not provided, input_string must contain at least as many\n            values as current contents of self.data.\n\n        \"\"\"\n        numbs = tools.string_to_numbers(input_string)\n        nb_values = len(numbs) - 1\n\n        if allowed_nb_val is None:\n            if (nb_values) < len(self.data):\n                raise ValueError(f'Cannot update TimestampedData, too few values received ({nb_values}).')\n            elif (nb_values) > len(self.data):\n                numbs = numbs[0:len(self.data) + 1]\n        else:\n            if nb_values not in allowed_nb_val:\n                raise ValueError(f'Cannot update TimestampedData, incorrect number of values received ({nb_values}).')\n\n        if numbs[0] >= self.timestamp:\n            self.timestamp = numbs[0]\n            self.data = numbs[1:]\n            self.enabled = True\n\n    def update_from_data(self, timestamp: int, data: list[float]):\n        \"\"\"Update with data unless timestamp is older\n\n        Parameters\n        ----------\n        timestamp : number-like\n            Timestamp associated with data.\n        data : object\n            Data to be stored if timestamp is newer.\n\n        \"\"\"\n        if timestamp >= self.timestamp:\n            self.timestamp = timestamp\n            self.data = data\n            self.enabled = True\n\n    @classmethod\n    def zeros(cls, length: int, update_type: RtDataUpdateType):\n        \"\"\" Construct empty TimestampedData object of specified length.\n\n        Parameters\n        ----------\n        length : int\n            Length of data to construct.\n        update_type : RtDataUpdateType\n            Update type of monitored data. Refer to RtDataUpdateType for the various update types\n\n        Return\n        ------\n        TimestampedData object\n\n        \"\"\"\n        return cls(0, [0.] * length, update_type)\n\n    def __eq__(self, other):\n        \"\"\" Return true if other object has identical timestamp and data.\n\n        Parameters\n        ----------\n        other : object\n            Object to compare against.\n\n        Return\n        ------\n        bool\n            True if objects have same timestamp and data.\n\n        \"\"\"\n        return other.timestamp == self.timestamp and other.data == self.data and other.update_type == self.update_type\n\n    def __ne__(self, other):\n        \"\"\" Return true if other object has different timestamp or data.\n\n        Parameters\n        ----------\n        other : object\n            Object to compare against.\n\n        Return\n        ------\n        bool\n            True if objects have different timestamp or data.\n\n        \"\"\"\n        return not self == other",
    "span": [
      946,
      1073
    ],
    "start_byte": 35386,
    "end_byte": 39757,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "TimestampedData"
  },
  {
    "snippet": "class RobotRtData:\n    \"\"\"Class for storing the internal real-time data of a Mecademic robot.\n\n    Most real-time data query methods from the programming guide were not implemented explicitly in Python.\n    The information, however, are available using the GetRobotRtData() method.\n    The attribute corresponding programming method is shown between parentheses.\n\n    The frequency and availability of real-time data depends on the monitoring interval and which monitoring\n    events are enabled. Monitoring events can be configured using SetMonitoringInterval() and SetRealTimeMonitoring().\n\n    Attributes\n    ----------\n    cycle_count : int\n        Number of real-time data updates received from the robot. The robot will send real-time data updates at\n        the interval defined by SetMonitoringInterval (16.6 milliseconds by default)\n    rt_target_joint_pos : TimestampedData\n        Controller desired joint positions in degrees [theta_1...6] (GetRtTargetJointPos).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_target_cart_pos : TimestampedData\n        Controller desired end effector pose [x, y, z, alpha, beta, gamma] (GetRtTargetCartPos).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_target_joint_vel : TimestampedData\n        Controller desired joint velocity in degrees/second [theta_dot_1...6] (GetRtTargetJointVel).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_TARGET_JOINT_VEL).\n    rt_target_cart_vel : TimestampedData\n        Controller desired end effector velocity with timestamp. Linear values in mm/s, angular in deg/s.\n        [linear_velocity_vector x, y, z, angular_velocity_vector omega-x, omega-y, omega-z] (GetRtTargetCartVel).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_TARGET_CART_VEL).\n    rt_target_joint_torq : TimestampedData\n        Controller estimated torque ratio as a percent of maximum [torque_1...6] (GetRtJointTorq).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_TARGET_JOINT_TORQ).\n    rt_target_conf : TimestampedData\n        Controller joint configuration that corresponds to desired joint positions (GetRtTargetConf).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_target_conf_turn : TimestampedData\n        Controller last joint turn number that corresponds to desired joint positions (GetRtTargetConfTurn).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n\n    rt_joint_pos : TimestampedData\n        Drive-measured joint positions in degrees [theta_1...6] (GetRtJointPos).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_JOINT_POS).\n    rt_cart_pos : TimestampedData\n        Drive-measured end effector pose [x, y, z, alpha, beta, gamma] (GetRtCartPos).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_CART_POS).\n    rt_joint_vel : TimestampedData\n        Drive-measured joint velocity in degrees/second [theta_dot_1...6] (GetRtJointVel).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_JOINT_VEL).\n    rt_joint_torq : TimestampedData\n        Drive-measured torque ratio as a percent of maximum [torque_1...6] (GetRtJointTorq).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_JOINT_TORQ).\n    rt_cart_vel : TimestampedData\n        Drive-measured end effector velocity with timestamp. Linear values in mm/s, angular in deg/s.\n        [linear_velocity_vector x, y, z, angular_velocity_vector omega-x, omega-y, omega-z] (GetRtCartVel).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_CART_VEL).\n    rt_conf : TimestampedData\n        Controller joint configuration that corresponds to drives-measured joint positions (GetRtConf).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_CONF).\n    rt_conf_turn : TimestampedData\n        Controller last joint turn number that corresponds to drives-measured joint positions (GetRtConfTurn).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_CONF_TURN).\n\n    rt_accelerometer : TimestampedData\n        Raw accelerometer measurements [accelerometer_id, x, y, z]. 16000 = 1g (GetRtAccelerometer).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_ACCELEROMETER).\n    rt_effective_time_scaling : TimestampedData\n        Effective time scaling ratio (GetRtEffectiveTimeScaling).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_EFFECTIVE_TIME_SCALING).\n    rt_vm : TimestampedData\n        Motor voltage readings (GetRtVm).\n        Contains: [Baseboard VM, Psu VM, SafeMcu VM, Drive 1 VM, Drive 1 VM, ..., Drive N VM]\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_VM).\n    rt_current : TimestampedData\n        Motor current readings (GetRtIm).\n        Contains: [Baseboard current]\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_CURRENT).\n\n    rt_external_tool_status : TimestampedData\n        External tool status [sim_tool_type, physical_tool_type, homing_state, error_status, overload_error]\n        (GetRtExtToolStatus).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_valve_state : TimestampedData\n        Valve state [valve_opened[0], valve_opened[1]] (GetRtValveState).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_gripper_state : TimestampedData\n        Gripper state [holding_part, target_pos_reached, opened, closed] (GetRtGripperState).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_gripper_force : TimestampedData\n        Gripper force in % of maximum force (GetRtGripperForce).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_GRIPPER_FORCE).\n    rt_gripper_pos : TimestampedData\n        Gripper position in mm. (GetRtGripperPos)\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_GRIPPER_POS).\n\n    rt_io_module_status : TimestampedData\n        IO module status [bank_id, present, sim_mode, error_code] (GetRtIoStatus).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_io_module_outputs : TimestampedData\n        IO module's digital outputs state [output[0], output[1], ...] (GetRtOutputState).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_io_module_inputs : TimestampedData\n        IO module's digital inputs state [input[0], input[1], ...] (GetRtInputState).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_vacuum_state : TimestampedData\n        IO module's vacuum gripper state [vacuum_on, purge_on, holding_part] (GetRtVacuumState).\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_vacuum_pressure: TimestampedData\n        IO module's vacuum current pressure in kPa (GetRtVacuumPressure).\n        *** Not enabled by default. To enable it, use SetRealTimeMonitoring(MX_ST_RT_VACUUM_PRESSURE).\n\n    rt_wrf : TimestampedData\n        Current definition of the WRF w.r.t. the BRF with timestamp. Cartesian data are in mm, Euler angles in degrees.\n        [cartesian coordinates x, y, z, Euler angles omega-x, omega-y, omega-z] (GetRtWrf)\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_trf : TimestampedData\n        Current definition of the TRF w.r.t. the FRF with timestamp. cartesian data are in mm, Euler angles in degrees.\n        [cartesian coordinates x, y, z, Euler angles omega-x, omega-y, omega-z] (GetRtTrf)\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n    rt_checkpoint : TimestampedData\n        Last executed checkpoint with timestamp. (GetCheckpoint)\n        Always enabled and available (regardless of SetRealTimeMonitoring options).\n\"\"\"\n\n    def __init__(self, num_joints: int):\n        self._init_timestamped_data(num_joints)\n        self.max_queue_size = 0\n        self.cycle_count = 0\n\n    def _init_timestamped_data(self, num_joints: int):\n        \"\"\"Initialize timestamped data class members according to detected robot model (number of joints)\"\"\"\n        nb_cart_val = num_joints  # 4 degrees of liberty for 4 joints robots, 6 for 6 joint robots\n        nb_conf_val = 3 if num_joints == 6 else 1  # 4 degrees of liberty for 4 joints robots, 6 for 6 joint robots\n\n        self.rt_target_joint_pos = TimestampedData.zeros(\n            num_joints, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL)  # microseconds timestamp, degrees\n        self.rt_target_cart_pos = TimestampedData.zeros(\n            nb_cart_val, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL)  # microseconds timestamp, mm and degrees\n        self.rt_target_joint_vel = TimestampedData.zeros(\n            num_joints,\n            RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, degrees/second\n        self.rt_target_cart_vel = TimestampedData.zeros(\n            nb_cart_val,\n            RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, mm/s and deg/s\n        self.rt_target_joint_torq = TimestampedData.zeros(\n            num_joints,\n            RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, percent of maximum\n        self.rt_target_conf = TimestampedData.zeros(nb_conf_val, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n        self.rt_target_conf_turn = TimestampedData.zeros(1, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n\n        self.rt_joint_pos = TimestampedData.zeros(\n            num_joints, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, degrees\n        self.rt_cart_pos = TimestampedData.zeros(\n            nb_cart_val,\n            RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, mm and degrees\n        self.rt_joint_vel = TimestampedData.zeros(\n            num_joints,\n            RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, degrees/second\n        self.rt_joint_torq = TimestampedData.zeros(\n            num_joints,\n            RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, percent of maximum\n        self.rt_cart_vel = TimestampedData.zeros(\n            nb_cart_val,\n            RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, mm/s and deg/s\n        self.rt_conf = TimestampedData.zeros(nb_conf_val, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n        self.rt_conf_turn = TimestampedData.zeros(1, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n\n        self.rt_effective_time_scaling = TimestampedData.zeros(1,\n                                                               RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL\n                                                               )  # microseconds timestamp, effective time scaling ratio\n        self.rt_vm = TimestampedData.zeros(\n            num_joints + 3, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL\n        )  # microseconds timestamp, Baseboard VM, Psu VM, SafeMcu Vm, Drive 1 VM, Drive 2 Vm, ...\n        self.rt_current = TimestampedData.zeros(\n            1, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, Baseboard current\n\n        # Another way of getting robot joint position using less-precise encoders.\n        # For robot production testing (otherwise use rt_joint_pos which is much more precise)\n        self.rt_abs_joint_pos = TimestampedData.zeros(\n            num_joints, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, degrees\n\n        # Contains dictionary of accelerometers stored in the robot indexed by joint number.\n        # For example, Meca500 currently only reports the accelerometer in joint 5.\n        self.rt_accelerometer: dict[int, TimestampedData] = dict()  # 16000 = 1g\n\n        self.rt_external_tool_status = TimestampedData.zeros(\n            5, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED\n        )  # microseconds timestamp, sim tool type, physical tool type, homed, error, overload\n        self.rt_valve_state = TimestampedData.zeros(\n            MX_EXT_TOOL_MPM500_NB_VALVES,\n            RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)  # microseconds timestamp, valve1 opened, valve2 opened\n        self.rt_gripper_state = TimestampedData.zeros(\n            4, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED\n        )  # microseconds timestamp, holding part, target pos reached, closed, opened\n        self.rt_gripper_force = TimestampedData.zeros(\n            1, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, gripper force [%]\n        self.rt_gripper_pos = TimestampedData.zeros(\n            1,\n            RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, gripper position [mm]\n\n        self.rt_io_module_status = TimestampedData.zeros(4, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n        self.rt_io_module_outputs = TimestampedData.zeros(\n            0, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)  # Resized later\n        self.rt_io_module_inputs = TimestampedData.zeros(\n            0, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)  # Resized later\n        self.rt_vacuum_state = TimestampedData.zeros(3, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED\n                                                     )  # microseconds timestamp, vacuum on/off, purge on/off, holding\n        self.rt_vacuum_pressure = TimestampedData.zeros(\n            1,\n            RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_CYCLICAL_OPTIONAL)  # microseconds timestamp, vacuum pressure [kPa]\n\n        self.rt_sig_gen_status = TimestampedData.zeros(4, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)\n        self.rt_sig_gen_outputs = TimestampedData.zeros(\n            0, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)  # Resized later\n        self.rt_sig_gen_inputs = TimestampedData.zeros(\n            0, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)  # Resized later\n\n        self.rt_wrf = TimestampedData.zeros(\n            nb_cart_val, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)  # microseconds timestamp, mm and degrees\n        self.rt_trf = TimestampedData.zeros(\n            nb_cart_val, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)  # microseconds timestamp, mm and degrees\n        self.rt_checkpoint = TimestampedData.zeros(\n            1, RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED)  # microseconds timestamp, checkpointId\n\n    def _for_each_rt_data(self):\n        \"\"\"Iterates for each TimestampedData type member of this class (rt_joint_pos, rt_cart_pos, etc.)\n        \"\"\"\n        # Collect class member names\n        member_names = vars(self)\n        # Iterate though all \"rt_\" members\n        for member_name in member_names:\n            if not member_name.startswith('rt_'):\n                continue\n            member = getattr(self, member_name)\n            # Check member type (TimestampedData or dict of TimestampedData), then yield TimestampedData\n            if isinstance(member, TimestampedData):\n                yield member\n            elif isinstance(member, dict):\n                for sub_member in member.values():\n                    yield sub_member\n\n    def _reset_enabled(self):\n        \"\"\"Clear the \"enabled\" flag of each member of this class of type TimestampedData\n        \"\"\"\n        for rt_data in self._for_each_rt_data():\n            rt_data.enabled = False\n\n        # manually remove the accelerometer data\n        self.rt_accelerometer.clear()\n\n    def _clear_accelerometer_data_if_disabled(self):\n        \"\"\"Clear the accelerometer data dictionary member\n        \"\"\"\n        for accelerometer_idx in list(self.rt_accelerometer.keys()):\n            if self.rt_accelerometer[accelerometer_idx].enabled is False:\n                del self.rt_accelerometer[accelerometer_idx]\n\n    def clear_if_outdated(self):\n        \"\"\"Clear the TimestampedData of each member if the data is outdated\n        \"\"\"\n        # Clear any outdated pieces of data by using the enable flag\n        reference_timestamp = self.rt_target_joint_pos.timestamp  # Present at every cycle\n\n        for rt_data in self._for_each_rt_data():\n            if (rt_data.timestamp != reference_timestamp\n                    and rt_data.update_type != RtDataUpdateType.MX_RT_DATA_UPDATE_TYPE_EVENT_BASED):\n                rt_data.enabled = False\n                rt_data.clear_if_disabled()\n\n        self._clear_accelerometer_data_if_disabled()\n\n    def clear_if_disabled(self):\n        \"\"\"Clear real-time values that are disabled (not reported by robot's current real-time monitoring configuration)\n        \"\"\"\n        for rt_data in self._for_each_rt_data():\n            rt_data.clear_if_disabled()\n\n        self._clear_accelerometer_data_if_disabled()",
    "span": [
      1076,
      1351
    ],
    "start_byte": 39760,
    "end_byte": 57149,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "RobotRtData"
  },
  {
    "snippet": "class RobotStatus:\n    \"\"\"Class for storing the status of a Mecademic robot.\n\n    Attributes\n    ----------\n    activation_state : bool\n        True if the robot is activated.\n    homing_state : bool\n        True if the robot is homed.\n    simulation_mode : MxRobotSimulationMode\n        True if the robot is in simulation-only mode (fast or real-time)\n    recovery_mode : bool\n        True if the robot is in recovery mode.\n    error_status : bool\n        True if the robot is in error.\n    error_code : int\n        Current robot error code, or 0 if the robot is not in error state.\n        Note: Only supported if connecting to the on port MX_ROBOT_TCP_PORT_CONTROL_JSON or MX_ROBOT_TCP_PORT_FEED_JSON.\n              Otherwise error_code will be None (unknown).\n    pstop2State : MxStopState\n        *** IMPORTANT NOTE: PStop2 is not safety-rated on Meca500 robots ***\n        *** Deprecated. Use RobotSafetyStatus.pstop2_state instead.\n        Current PStop2 status.\n    estopState : MxStopState\n        *** Deprecated. Use RobotSafetyStatus.estop_state instead.\n        Current EStop status.\n        Note that Meca500 revision 3 or older never report this condition because these robots's power supply\n        will be shutdown completely in case of EStop (and thus this API will get disconnected from the robot instead).\n    pause_motion_status : bool\n        True if motion is currently paused.\n    end_of_block_status : bool\n        True if robot is not moving and motion queue is empty.\n        Note: We recommend not using end_of_block_status to detect when robot has finished executing previously sent\n              commands. Some posted commands may still be transient (on the network for example) and the robot may,\n              in some cases, declare end-of-block in-between two commands.\n              Instead, we recommend using checkpoints or the WaitIdle method.\n    brakes_engaged : bool\n        True if robot brakes are engaged.\n        This is relevant only when robot is deactivated (brakes are automatically disengaged upon robot activation).\n    connection_watchdog_enabled : bool\n        True if the connection watchdog is currently enabled/active (see ConnectionWatchdog API call)\n\"\"\"\n\n    def __init__(self):\n\n        # The following are status fields.\n        self.activation_state = False\n        self.homing_state = False\n        self.simulation_mode = MxRobotSimulationMode.MX_SIM_MODE_DISABLED\n        self.recovery_mode = False\n        self.error_status = False\n        self.error_code: Optional[int] = None\n        # pylint: disable=invalid-name\n        self.pstop2State = MxStopState.MX_STOP_STATE_RESET  # Deprecated, moved to RobotSafetyStatus.pstop2_state\n        self.estopState = MxStopState.MX_STOP_STATE_RESET  # Deprecated, moved to RobotSafetyStatus.estop_state\n        self.pause_motion_status = False\n        self.end_of_block_status = False\n        self.brakes_engaged = False\n        self.connection_watchdog_enabled = False\n\n    def __str__(self) -> str:\n        error_str = f'{self.error_status}' if (self.error_code is None\n                                               or self.error_code == 0) else f'{self.error_code}'\n        return (f\"Activated: {self.activation_state}, \"\n                f\"homed: {self.homing_state}, \"\n                f\"sim: {self.simulation_mode}, \"\n                f\"recovery mode: {self.recovery_mode}, \"\n                f\"error: {error_str}, \"\n                f\"pause motion: {str(self.pause_motion_status)}, \"\n                f\"EOB: {self.end_of_block_status}, \"\n                f\"brakes engaged: {self.brakes_engaged}, \"\n                f\"connection watchdog: {'enabled' if self.connection_watchdog_enabled else 'disabled'}\")\n\n    def can_move(self) -> bool:\n        \"\"\"Tells if robot can currently be moved (state is homed, or activated in recovery mode)\n\n        Returns:\n            bool: true if robot can be moved\n        \"\"\"\n        return self.homing_state or (self.activation_state and self.recovery_mode)",
    "span": [
      1354,
      1433
    ],
    "start_byte": 57152,
    "end_byte": 61145,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "RobotStatus"
  },
  {
    "snippet": "class RobotStaticSafetyStopMasks:\n    \"\"\"Various useful bit masks used to categorize safety signals\n\n    Attributes\n    ----------\n    clearedByPsu : int\n        Bit mask to identify safety signals that must be reset using the power supply reset function.\n    withVmOff : int\n        Bit mask to identify safety signals that cause motor voltage to be removed.\n        These are category 1 safety stop signals (Estop, PStop1, etc.).\n    maskedInManualMode : int\n        Bit mask to identify safety signals masked when the robot is in \"manual\" operation mode (PStop1, PStop2)\n\n    \"\"\"\n\n    def __init__(self):\n        # Useful masks to categorize RobotSafetyStatus.stop_mask above\n        # *** Note: Only available when connected on the JSON port (MX_ROBOT_TCP_PORT_CONTROL_JSON)\n        # pylint: disable=invalid-name\n        self.clearedByPsu = 0\n        self.withVmOff = 0\n        self.maskedInManualMode = 0",
    "span": [
      1436,
      1457
    ],
    "start_byte": 61148,
    "end_byte": 62058,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "RobotStaticSafetyStopMasks"
  },
  {
    "snippet": "class RobotPowerSupplyInputs:\n    \"\"\" Class for storing robot's power supply physical input states\n\n        Attributes\n        ----------\n        psu_input_mask : int\n            Bit mask that summarizes all power supply input states. Use bits from MxPsuInputMask\n        estop_asserted : bool\n            Indicate if the EStop (emergency stop) signal on the power supply is asserted (robot will stop)\n        pstop1_asserted : bool\n            Indicate if the PStop1 (protective stop category 1) signal on the power supply is asserted (robot will stop)\n        pstop2_asserted : bool\n            Indicate if the PStop2 (protective stop category 2) signal on the power supply is asserted (robot will stop)\n        reset_ext_asserted : bool\n            Indicate if the 'reset' input signal on the power supply is asserted (requesting for a reset)\n        reset_keypad_pressed : bool\n            Indicate if the 'reset' keypad button on the power supply is pressed\n        enabling_device_asserted : bool\n            Indicate if the enabling device power supply input indicates that the enabling device is pressed\n    \"\"\"\n\n    def __init__(self):\n        self.psu_input_mask = 0\n        self.estop_asserted = False\n        self.pstop1_asserted = False\n        self.pstop2_asserted = False\n        self.reset_ext_asserted = False\n        self.reset_keypad_pressed = False\n        self.enabling_device_asserted = False\n\n    def set_psu_input_mask(self, input_mask: Union[MxPsuInputMask, int]):\n        \"\"\"Update the power supply input mask, and update corresponding individual booleans (estop_asserted, etc.)\n\n        Parameters\n        ----------\n        input_mask : Union[MxPsuInputMask,int]\n            Power supply input mask to set\n        \"\"\"\n        self.psu_input_mask = int(input_mask)\n\n        # Update individual booleans\n        self.estop_asserted = (self.psu_input_mask & MxPsuInputMask.MX_PSU_INPUT_ESTOP) != 0\n        self.pstop1_asserted = (self.psu_input_mask & MxPsuInputMask.MX_PSU_INPUT_PSTOP1) != 0\n        self.pstop2_asserted = (self.psu_input_mask & MxPsuInputMask.MX_PSU_INPUT_PSTOP2) != 0\n        self.reset_ext_asserted = (self.psu_input_mask & MxPsuInputMask.MX_PSU_INPUT_RESET_EXT) != 0\n        self.reset_keypad_pressed = (self.psu_input_mask & MxPsuInputMask.MX_PSU_INPUT_RESET_KEYPAD) != 0\n        self.enabling_device_asserted = (self.psu_input_mask & MxPsuInputMask.MX_PSU_INPUT_ENABLING_DEVICE) != 0\n\n    def set_estop_asserted(self, state: bool):\n        \"\"\" Update estop_asserted and update the mask (psuInputMask) accordingly \"\"\"\n        self.estop_asserted = state\n        if state:\n            self.psu_input_mask |= MxPsuInputMask.MX_PSU_INPUT_ESTOP\n        else:\n            self.psu_input_mask &= ~MxPsuInputMask.MX_PSU_INPUT_ESTOP\n\n    def set_pstop1_asserted(self, state: bool):\n        \"\"\" Update pstop1_asserted and update the mask (psuInputMask) accordingly \"\"\"\n        self.pstop1_asserted = state\n        if state:\n            self.psu_input_mask |= MxPsuInputMask.MX_PSU_INPUT_PSTOP1\n        else:\n            self.psu_input_mask &= ~MxPsuInputMask.MX_PSU_INPUT_PSTOP1\n\n    def set_pstop2_asserted(self, state: bool):\n        \"\"\" Update pstop2_asserted and update the mask (psuInputMask) accordingly \"\"\"\n        self.pstop2_asserted = state\n        if state:\n            self.psu_input_mask |= MxPsuInputMask.MX_PSU_INPUT_PSTOP2\n        else:\n            self.psu_input_mask &= ~MxPsuInputMask.MX_PSU_INPUT_PSTOP2\n\n    def set_reset_ext_asserted(self, state: bool):\n        \"\"\" Update reset_ext_asserted and update the mask (psuInputMask) accordingly \"\"\"\n        self.reset_ext_asserted = state\n        if state:\n            self.psu_input_mask |= MxPsuInputMask.MX_PSU_INPUT_RESET_EXT\n        else:\n            self.psu_input_mask &= ~MxPsuInputMask.MX_PSU_INPUT_RESET_EXT\n\n    def set_reset_keypad_asserted(self, state: bool):\n        \"\"\" Update reset_keypad_asserted and update the mask (psuInputMask) accordingly \"\"\"\n        self.reset_keypad_pressed = state\n        if state:\n            self.psu_input_mask |= MxPsuInputMask.MX_PSU_INPUT_RESET_KEYPAD\n        else:\n            self.psu_input_mask &= ~MxPsuInputMask.MX_PSU_INPUT_RESET_KEYPAD\n\n    def set_enabling_device_asserted(self, state: bool):\n        \"\"\" Update enabling_device_asserted and update the mask (psuInputMask) accordingly \"\"\"\n        self.enabling_device_asserted = state\n        if state:\n            self.psu_input_mask |= MxPsuInputMask.MX_PSU_INPUT_ENABLING_DEVICE\n        else:\n            self.psu_input_mask &= ~MxPsuInputMask.MX_PSU_INPUT_ENABLING_DEVICE\n\n    def __str__(self) -> str:\n        return (f\"psu_input_mask: {hex(self.psu_input_mask)} -> \"\n                f\"estop_asserted: {self.estop_asserted}, \"\n                f\"pstop1_asserted: {self.pstop1_asserted}, \"\n                f\"pstop2_asserted: {self.pstop2_asserted}, \"\n                f\"reset_ext_asserted: {self.reset_ext_asserted}, \"\n                f\"reset_keypad_pressed: {self.reset_keypad_pressed}, \"\n                f\"enabling_device_asserted: {self.enabling_device_asserted}\")",
    "span": [
      1460,
      1563
    ],
    "start_byte": 62061,
    "end_byte": 67141,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "RobotPowerSupplyInputs"
  },
  {
    "snippet": "class RobotSafetyStatus:\n    \"\"\"Class for storing the safety stop status of a Mecademic robot.\n\n    Attributes\n    ----------\n    robot_operation_mode : MxRobotOperationMode\n        The current robot operation mode, based on the the power supply key position (not supported on Meca500 robots).\n        When the key is not in \"automatic\" position, restrictions will apply for using the robot.\n    reset_ready : bool\n        Not yet implemented. Future implementation will:\n        Indicate if it's currently possible to reset safety stop conditions that are linked to the power supply reset\n        button because they remove motor power (EStop, PStop1, Operation mode change, robot reboot, etc.)\n    stop_mask : int\n        Bit mask that summarizes all safety stop conditions on the robot (including both active or resettable signals).\n        Use bits from MxSafeStopCategory.\n        Note: Also available as individual signal states (estop_state, pstop1_state, etc...)\n    stop_resettable_mask : int\n        Bit mask that summarizes all safety stop conditions that are currently resettable.\n        Use bits from MxSafeStopCategory.\n        Note: Also available as individual signal states (estop_state, pstop1_state, etc...)\n    estop_state : MxStopState\n        Current EStop status.\n        Note that Meca500 revision 3 or older never report this condition because these robots's power supply\n        will be shutdown completely in case of EStop (and thus this API will get disconnected from the robot instead).\n    pstop1_state : MxStopState\n        Current PStop1 status\n    pstop2_state : MxStopState\n        Current PStop2 status\n        *** IMPORTANT NOTE: PStop2 is not safety-rated on Meca500 robots ***\n    operation_mode_stop_state : MxStopState\n        Current status for \"operation mode\" safety stop condition (upon mode changes or when mode is locked)\n    enabling_device_released_stop_state : MxStopState\n        Current status for \"enabling device\" safety stop condition\n    voltage_fluctuation_stop_state : MxStopState\n        Current status for \"voltage fluctuation\" safety stop condition\n    reboot_stop_state : MxStopState\n        Current status for \"robot just rebooted\" safety stop condition\n    redundancy_fault_stop_state : MxStopState\n        Current status for \"redundancy fault\" safety stop condition\n    standstill_fault_stop_state : MxStopState\n        Current status for \"standstill fault\" safety stop condition\n    connection_dropped_stop_state : MxStopState\n        Current status for \"connection dropped\" safety stop condition\n    minor_error_stop_state : MxStopState\n        Current status for \"minor error\" safety stop condition, which is triggered if robot removes motor voltage\n        for any internal reason other than the safety stop signals above (thus generally due to a minor internal error).\n        If this happens, see the robot logs for details.\n    static_masks : RobotStaticSafetyStopMasks\n        Useful masks to categorize safety stop signals from stop_mask\n\"\"\"\n\n    def __init__(self):\n        self.robot_operation_mode = MxRobotOperationMode.MX_ROBOT_OPERATION_MODE_AUTO\n        self.reset_ready = False\n        self.stop_mask = 0\n        self.stop_resettable_mask = 0\n        self.estop_state = MxStopState.MX_STOP_STATE_RESET\n        self.pstop1_state = MxStopState.MX_STOP_STATE_RESET\n        self.pstop2_state = MxStopState.MX_STOP_STATE_RESET\n        self.operation_mode_stop_state = MxStopState.MX_STOP_STATE_RESET\n        self.enabling_device_released_stop_state = MxStopState.MX_STOP_STATE_RESET\n        self.voltage_fluctuation_stop_state = MxStopState.MX_STOP_STATE_RESET\n        self.reboot_stop_state = MxStopState.MX_STOP_STATE_RESET\n        self.redundancy_fault_stop_state = MxStopState.MX_STOP_STATE_RESET\n        self.standstill_fault_stop_state = MxStopState.MX_STOP_STATE_RESET\n        self.connection_dropped_stop_state = MxStopState.MX_STOP_STATE_RESET\n        self.minor_error_stop_state = MxStopState.MX_STOP_STATE_RESET\n\n        # Useful masks to categorize stop_mask above\n        self.static_masks = RobotStaticSafetyStopMasks()\n\n    def set_estop_state(self, stop_state: MxStopState):\n        \"\"\"Change the EStop state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            EStop state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_ESTOP, stop_state)\n\n    def set_pstop1_state(self, stop_state: MxStopState):\n        \"\"\"Change the PStop1 state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            PStop1 state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_PSTOP1, stop_state)\n\n    def set_pstop2_state(self, stop_state: MxStopState):\n        \"\"\"Change the PStop2 state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            PStop2 state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_PSTOP2, stop_state)\n\n    def set_operation_mode_stop_state(self, stop_state: MxStopState):\n        \"\"\"Change the \"operation mode\" safety stop state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            Safety stop state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_OPERATION_MODE, stop_state)\n\n    def set_enabling_device_released_stop_state(self, stop_state: MxStopState):\n        \"\"\"Change the \"enabling device\" safety stop state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            Safety stop state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_ENABLING_DEVICE_RELEASED, stop_state)\n\n    def set_voltage_fluctuation_stop_state(self, stop_state: MxStopState):\n        \"\"\"Change the \"voltage fluctuation\" safety stop state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            Safety stop state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_VOLTAGE_FLUCTUATION, stop_state)\n\n    def set_reboot_stop_state(self, stop_state: MxStopState):\n        \"\"\"Change the \"robot just rebooted\" safety stop state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            Safety stop state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_REBOOT, stop_state)\n\n    def set_redundancy_fault_stop_state(self, stop_state: MxStopState):\n        \"\"\"Change the \"redundancy fault\" safety stop state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            Safety stop state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_REDUNDANCY_FAULT, stop_state)\n\n    def set_standstill_fault_stop_state(self, stop_state: MxStopState):\n        \"\"\"Change the \"standstill fault\" safety stop state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            Safety stop state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_STANDSTILL_FAULT, stop_state)\n\n    def set_connection_dropped_stop_state(self, stop_state: MxStopState):\n        \"\"\"Change the \"connection dropped\" safety stop state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            Safety stop state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_CONNECTION_DROPPED, stop_state)\n\n    def set_minor_error_stop_state(self, stop_state: MxStopState):\n        \"\"\"Change the \"minor error\" safety stop state\n\n        Parameters\n        ----------\n        stop_state : MxStopState\n            Safety stop state to set\n        \"\"\"\n        self.set_stop_state(MxSafeStopCategory.MX_SAFE_STOP_MINOR_ERROR, stop_state)\n\n    def set_stop_state(self, stop_category: MxSafeStopCategory, stop_state: MxStopState):\n        \"\"\"Change a safety stop state\n\n        Parameters\n        ----------\n        stop_category : MxSafeStopCategory\n            Safety stop category to change state for\n        stop_state : MxStopState\n            Safety stop state to set\n        \"\"\"\n        # Make sure to cast to enum value (in case we were passed an int)\n        stop_state = MxStopState(stop_state)\n\n        # Update specified stop state\n        if stop_category == MxSafeStopCategory.MX_SAFE_STOP_ESTOP:\n            self.estop_state = stop_state\n        elif stop_category == MxSafeStopCategory.MX_SAFE_STOP_PSTOP1:\n            self.pstop1_state = stop_state\n        elif stop_category == MxSafeStopCategory.MX_SAFE_STOP_PSTOP2:\n            self.pstop2_state = stop_state\n        elif stop_category == MxSafeStopCategory.MX_SAFE_STOP_OPERATION_MODE:\n            self.operation_mode_stop_state = stop_state\n        elif stop_category == MxSafeStopCategory.MX_SAFE_STOP_ENABLING_DEVICE_RELEASED:\n            self.enabling_device_released_stop_state = stop_state\n        elif stop_category == MxSafeStopCategory.MX_SAFE_STOP_VOLTAGE_FLUCTUATION:\n            self.voltage_fluctuation_stop_state = stop_state\n        elif stop_category == MxSafeStopCategory.MX_SAFE_STOP_REBOOT:\n            self.reboot_stop_state = stop_state\n        elif stop_category == MxSafeStopCategory.MX_SAFE_STOP_REDUNDANCY_FAULT:\n            self.redundancy_fault_stop_state = stop_state\n        elif stop_category == MxSafeStopCategory.MX_SAFE_STOP_STANDSTILL_FAULT:\n            self.standstill_fault_stop_state = stop_state\n        elif stop_category == MxSafeStopCategory.MX_SAFE_STOP_CONNECTION_DROPPED:\n            self.connection_dropped_stop_state = stop_state\n        elif stop_category == MxSafeStopCategory.MX_SAFE_STOP_MINOR_ERROR:\n            self.minor_error_stop_state = stop_state\n\n        # Update the masks too\n        if stop_state == MxStopState.MX_STOP_STATE_ACTIVE:\n            self.stop_mask |= stop_category\n            self.stop_resettable_mask &= ~stop_category\n        elif stop_state == MxStopState.MX_STOP_STATE_RESETTABLE:\n            self.stop_mask |= stop_category\n            self.stop_resettable_mask |= stop_category\n        else:\n            self.stop_mask &= ~stop_category\n            self.stop_resettable_mask &= ~stop_category\n\n    @classmethod\n    def mask_to_string(cls, mask: int) -> str:\n        \"\"\"Format as a string a safety stop mask (detailing each safety stop signal that is active in the mask)\n\n        Args:\n            mask (int): Mask to print as detailed string\n\n        Returns:\n            str: Detailed string that represents all active safety stop signals in the mask\n        \"\"\"\n        status_masks: list[str] = []\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_ESTOP):\n            status_masks.append('EStop')\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_PSTOP1):\n            status_masks.append('PStop1')\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_PSTOP2):\n            status_masks.append('PStop2')\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_OPERATION_MODE):\n            status_masks.append('Operation mode')\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_ENABLING_DEVICE_RELEASED):\n            status_masks.append('Enabling device released')\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_VOLTAGE_FLUCTUATION):\n            status_masks.append('Voltage fluctuation')\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_REBOOT):\n            status_masks.append('Robot rebooted')\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_REDUNDANCY_FAULT):\n            status_masks.append('Redundancy fault')\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_STANDSTILL_FAULT):\n            status_masks.append('Standstill fault')\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_CONNECTION_DROPPED):\n            status_masks.append('Connection dropped')\n        if mask & int(MxSafeStopCategory.MX_SAFE_STOP_MINOR_ERROR):\n            status_masks.append('Minor error')\n        return ', '.join(status_masks)\n\n    def __str__(self) -> str:\n        return (\n            f\"operation mode: {tools.robot_operation_mode_to_string(self.robot_operation_mode)}, \"\n            f\"reset_ready: {self.reset_ready}, \"\n            f\"stop_mask: {hex(self.stop_mask)} ({self.mask_to_string(self.stop_mask)}), \"\n            f\"stop_resettable_mask: {hex(self.stop_resettable_mask)} ({self.mask_to_string(self.stop_resettable_mask)})\"\n        )",
    "span": [
      1566,
      1836
    ],
    "start_byte": 67144,
    "end_byte": 79435,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "RobotSafetyStatus"
  },
  {
    "snippet": "class GripperStatus:\n    \"\"\"Class for storing the Mecademic robot's gripper status.\n       LEGACY, use ExtToolStatus and GripperState instead.\n\n    Attributes\n    ----------\n    present : bool\n        True if the gripper is present on the robot.\n    homing_state : bool\n        True if the gripper has been homed (ready to be used).\n    holding_part : bool\n        True if the gripper is currently holding a part.\n    target_pos_reached : bool\n        True if the gripper is at target position or at a limit (fully opened or closed).\n    error_status : bool\n        True if the gripper is in error state.\n    overload_error : bool\n        True if the gripper is in overload error state.\n\"\"\"\n\n    def __init__(self):\n\n        # The following are status fields.\n        self.present = False\n        self.homing_state = False\n        self.holding_part = False\n        self.target_pos_reached = False\n        self.error_status = False\n        self.overload_error = False",
    "span": [
      1839,
      1867
    ],
    "start_byte": 79438,
    "end_byte": 80404,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "GripperStatus"
  },
  {
    "snippet": "class NetworkConfig:\n    \"\"\"Class for storing the Mecademic robot's network configuration.\n\n    Attributes\n    ----------\n    name : str\n        Robot name for DHCP requests\n    dhcp : bool\n        DHCP mode enabled for automatic IP assignment by DHCP server\n    ip : str\n        IPv4 address (ex: '192.168.0.100')\n    mask : str\n        Network mask (ex: '255.255.255.0')\n    gateway : str\n        Gateway IP address (ex: '192.168.0.1')\n    mac : str\n        Robot read-only MAC address (ex: '20:B0:F7:06:E4:80')\n\n\"\"\"\n\n    def __init__(self):\n\n        # The following are status fields.\n        self.name = ''\n        self.dhcp = False\n        self.ip = '192.168.0.100'\n        self.mask = '255.255.255.0'\n        self.gateway = ''\n        self.mac = ''\n\n    def __str__(self) -> str:\n        return (f\"Name: {self.name}, \"\n                f\"DHCP: {self.dhcp}, \"\n                f\"ip: {self.ip}, \"\n                f\"mask: {self.mask}, \"\n                f\"gateway: {self.gateway}, \"\n                f\"mac: {self.mac}\")\n\n    def __repr__(self) -> str:\n        return str(self)",
    "span": [
      1870,
      1909
    ],
    "start_byte": 80407,
    "end_byte": 81482,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "NetworkConfig"
  },
  {
    "snippet": "class ExtToolStatus:\n    \"\"\"Class for storing the Mecademic robot's external tool status.\n\n    Attributes\n    ----------\n    sim_tool_type : int\n        Simulated tool type.\n         0: MxExtToolType.MX_EXT_TOOL_NONE\n        10: MxExtToolType.MX_EXT_TOOL_MEGP25_SHORT\n        11: MxExtToolType.MX_EXT_TOOL_MEGP25_LONG\n        20: MxExtToolType.MX_EXT_TOOL_VBOX_2VALVES\n    physical_tool_type : int\n        Physical external tool type (same values as mentioned above).\n    homing_state : bool\n        True if the gripper is homed.\n    error_status : bool\n        True if the gripper is in error state.\n    overload_error : bool\n        True if the gripper is in overload error state.\n    comm_err_warning : bool\n        True if some communication errors were detected with the external tool.\n        This could mean that the cable may be damaged and must be replaced,\n        or that the cable may simply not be screwed tight enough on either side.\n\"\"\"\n\n    def __init__(self):\n\n        # The following are status fields.\n        self.sim_tool_type = MxExtToolType.MX_EXT_TOOL_NONE\n        self.physical_tool_type = MxExtToolType.MX_EXT_TOOL_NONE\n        self.homing_state = False\n        self.error_status = False\n        self.overload_error = False\n        self.comm_err_warning = False\n\n    def __str__(self) -> str:\n        return (f\"Sim tool type: {self.sim_tool_type}, \"\n                f\"Physical tool type: {self.physical_tool_type}, \"\n                f\"homed: {self.homing_state}, \"\n                f\"error: {self.error_status}, \"\n                f\"overload: {self.overload_error}\")\n\n    def __repr__(self) -> str:\n        return str(self)\n\n    def current_tool_type(self) -> int:\n        \"\"\"Returns current external tool type (simulated or physical)\n\n        Returns\n        -------\n        int\n            Current external tool\n        \"\"\"\n        return self.sim_tool_type if self.sim_tool_type != MxExtToolType.MX_EXT_TOOL_NONE else self.physical_tool_type\n\n    def is_physical_tool_present(self) -> bool:\n        \"\"\"Returns if physical tool is connected\n\n        Returns\n        -------\n        bool\n            True if physical gripper is connected, False otherwise\n        \"\"\"\n        return self.physical_tool_type != MxExtToolType.MX_EXT_TOOL_NONE\n\n    def is_tool_sim(self) -> bool:\n        \"\"\"Returns if tool is simulated or not\n\n        Returns\n        -------\n        bool\n            True if tool is simulated, False otherwise\n        \"\"\"\n        return self.sim_tool_type != MxExtToolType.MX_EXT_TOOL_NONE\n\n    def is_gripper(self, physical: bool = False) -> bool:\n        \"\"\"Returns if current external tool (simulated or physical) is a gripper\n\n        Parameters\n        ----------\n        physical : bool\n            True check physical gripper, False use current one (simulated or physical)\n\n        Returns\n        -------\n        bool\n            True if tool is a gripper, False otherwise\n        \"\"\"\n        tool_type = self.physical_tool_type if physical else self.current_tool_type()\n        return tool_type in [MxExtToolType.MX_EXT_TOOL_MEGP25_SHORT, MxExtToolType.MX_EXT_TOOL_MEGP25_LONG]\n\n    def is_pneumatic_module(self, physical: bool = False) -> bool:\n        \"\"\"Returns if current external tool (simulated or physical) is a pneumatic module\n\n        Parameters\n        ----------\n        physical : bool\n            True check physical gripper, False use current one (simulated or physical)\n\n        Returns\n        -------\n        bool\n            True if tool is a pneumatic module, False otherwise\n        \"\"\"\n        tool_type = self.physical_tool_type if physical else self.current_tool_type()\n        return tool_type in [MxExtToolType.MX_EXT_TOOL_VBOX_2VALVES]",
    "span": [
      1912,
      2017
    ],
    "start_byte": 81485,
    "end_byte": 85195,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "ExtToolStatus"
  },
  {
    "snippet": "class IoStatus:\n    \"\"\"Class for storing the Mecademic robot's IO modules status.\n\n    Attributes\n    ----------\n    bank_id : int\n        Type of this IO module.\n        1: MxIoBankId.MX_IO_BANK_ID_IO_MODULE\n    present : bool\n        True if an IO module of this type is present on the robot.\n    nb_inputs : int\n        Number of digital inputs supported by this IO module.\n    nb_outputs : int\n        Number of digital outputs supported by this IO module.\n    sim_mode : bool\n        True if the IO module is in simulation mode.\n    error : int\n        Error code of the IO module (0 if no error).\n    timestamp : int\n        Monotonic timestamp associated with data (in microseconds since robot last reboot)\n        This timestamp is stamped by the robot so it is not affected by host/network jitter\n\"\"\"\n\n    def __init__(self):\n\n        # The following are status fields.\n        self.bank_id = MxIoBankId.MX_IO_BANK_ID_UNDEFINED\n        self.present = False\n        self.nb_inputs = 0\n        self.nb_outputs = 0\n        self.sim_mode = False\n        self.error = 0\n        self.timestamp = 0\n\n    def __str__(self) -> str:\n        return (f\"BankId: {self.bank_id}, \"\n                f\"Physically present: {self.present}, \"\n                f\"Digital inputs: {self.nb_inputs}, \"\n                f\"Digital outputs: {self.nb_outputs}, \"\n                f\"Simulation mode: {self.sim_mode}, \"\n                f\"error: {self.error}\")\n\n    def __repr__(self) -> str:\n        return str(self)",
    "span": [
      2020,
      2063
    ],
    "start_byte": 85198,
    "end_byte": 86690,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "IoStatus"
  },
  {
    "snippet": "class ValveState:\n    \"\"\"Class for storing the Mecademic robot's pneumatic module valve states.\n\n    Attributes\n    ----------\n    valve_opened : list[int]\n        List of valve state: MX_VALVE_STATE_CLOSE or MX_VALVE_STATE_OPENED\n\"\"\"\n\n    def __init__(self):\n\n        # The following are status fields.\n        self.valve_opened = [int] * MX_EXT_TOOL_VBOX_MAX_VALVES",
    "span": [
      2066,
      2078
    ],
    "start_byte": 86693,
    "end_byte": 87060,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "ValveState"
  },
  {
    "snippet": "class GripperState:\n    \"\"\"Class for storing the Mecademic robot's gripper state.\n\n    Attributes\n    ----------\n    holding_part : bool\n        True if the gripper is currently holding a part.\n    target_pos_reached : bool\n        True if the gripper is at requested position:\n          - At configured opened/closed position following GripperOpen/GripperClose.\n          - At requested position after MoveGripper.\n    closed : bool\n        True if the gripper is at the configured 'close' position (ref SetGripperRanger) or less.\n    opened : bool\n        True if the gripper is at the configured 'open' position (ref SetGripperRanger) or more.\n\n\"\"\"\n\n    def __init__(self):\n\n        # The following are status fields.\n        self.holding_part = False\n        self.target_pos_reached = False\n        self.closed = False\n        self.opened = False\n\n    def __str__(self):\n        return (f'holding={self.holding_part}, '\n                f'pos_reached={self.target_pos_reached}, '\n                f'closed={self.closed}, '\n                f'opened={self.opened}')\n\n    def __repr__(self) -> str:\n        return str(self)",
    "span": [
      2081,
      2114
    ],
    "start_byte": 87063,
    "end_byte": 88185,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "GripperState"
  },
  {
    "snippet": "class VacuumState:\n    \"\"\"Class for storing the Mecademic robot's IO module vacuum state.\n\n    Attributes\n    ----------\n    vacuum_on : bool\n        True if the vacuum is currently 'on' (trying to pick or holding part).\n    purge_on: bool\n        True if currently pushing air to release part (see SetVacuumPurgeDuration).\n    holding_part : bool\n        True if currently holding part (based on configured pressure thresholds, see SetVacuumThreshold ).\n    timestamp : int\n        Monotonic timestamp associated with data (in microseconds since robot last reboot)\n        This timestamp is stamped by the robot so it is not affected by host/network jitter\n\"\"\"\n\n    def __init__(self):\n\n        # The following are status fields.\n        self.vacuum_on = False\n        self.purge_on = False\n        self.holding_part = False\n        self.timestamp = 0\n\n    def __str__(self) -> str:\n        return (f\"Vacuum: {'on' if self.vacuum_on else 'off'}, \"\n                f\"Purge: {'on' if self.purge_on else 'off'}, \"\n                f\"Holding part: {self.holding_part}\")\n\n    def __repr__(self) -> str:\n        return str(self)",
    "span": [
      2117,
      2147
    ],
    "start_byte": 88188,
    "end_byte": 89310,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "VacuumState"
  },
  {
    "snippet": "class CollisionObject:\n    \"\"\"Class that represents one object that can enter in collision with another or with the work zone boundary.\n       A collision object is defined by its group (MxCollisionGroup) and, in some cases, an index (like the joint)\n\n    Attributes\n    ----------\n    group : MxCollisionGroup\n        The group (type) of this object\n    index: int\n        The index of the object within the group (for groups that can have multiple objects).\n        Available indices for groups are:\n        - MxCollisionGroup.MX_COLLISION_GROUP_ROBOT:     Use index values from MxCollisionGroupRobotIdx.\n        - MxCollisionGroup.MX_COLLISION_GROUP_FCP:       Index is not used (always 0).\n        - MxCollisionGroup.MX_COLLISION_GROUP_TOOL:      Always 0 when tool sphere is used.\n                                                         Future versions may support multiple tool objects.\n        - MxCollisionGroup.MX_COLLISION_GROUP_ENV_OBJ:   User-defined index of the user-defined environment objects.\n                                                         (not supported yet)\n        - MxCollisionGroup.MX_COLLISION_GROUP_WORK_ZONE: Index is not used (always 0).\n\"\"\"\n\n    def __init__(self,\n                 group=MxCollisionGroup.MX_COLLISION_GROUP_ROBOT,\n                 index=MxCollisionGroupRobotIdx.MX_COLLISION_GROUP_ROBOT_BASE):\n        self.set(group, index)\n\n    def set(self, group: MxCollisionGroup, index: int):\n        \"\"\" Setter function \"\"\"\n        # The following are status fields.\n        self.group = group\n        # Update the index according to new group (if appropriate)\n        if self.group == MxCollisionGroup.MX_COLLISION_GROUP_ROBOT:\n            self.index = MxCollisionGroupRobotIdx(index)\n        elif self.group == MxCollisionGroup.MX_COLLISION_GROUP_TOOL:\n            self.index = MxCollisionGroupToolIdx(index)\n        else:\n            self.index = int(index)\n\n    def set_from_response(self, response_args: list[int]) -> list[int]:\n        \"\"\" Set CollisionObject from parsed reply message argument \"\"\"\n        self.set(MxCollisionGroup(response_args.pop(0)), response_args.pop(0))\n        return response_args\n\n    def __eq__(self, other):\n        if int(self.group) != int(other.group):\n            return False\n        if (self.group == MxCollisionGroup.MX_COLLISION_GROUP_ROBOT\n                or self.group == MxCollisionGroup.MX_COLLISION_GROUP_TOOL\n                or self.group == MxCollisionGroup.MX_COLLISION_GROUP_ENV_OBJ):\n            # In this group, the index is important\n            if int(self.index) != int(other.index):\n                return False\n        return True\n\n    def __str__(self) -> str:\n        return tools.robot_collision_group_to_string(self.group, self.index)\n\n    def __repr__(self) -> str:\n        return str(self)",
    "span": [
      2150,
      2207
    ],
    "start_byte": 89313,
    "end_byte": 92112,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "CollisionObject"
  },
  {
    "snippet": "class SelfCollisionStatus:\n    \"\"\"Class for storing the Mecademic robot's self collision status.\n       This is used when robot collision detection has been activated (with SetCollisionCfg).\n\n    Attributes\n    ----------\n    collision_detected : bool\n        True if the robot has detected a collision with itself.\n        Note that when the collision severity is set to MX_EVENT_SEVERITY_PAUSE_MOTION or greater\n        the robot will have stopped just before the collision actually occurs and collision_detected will be True\n        until ResumeMotion is called.\n        When collision severity is set to MX_EVENT_SEVERITY_WARNING the robot will actually continue to move and the\n        collision will actually occur. This can damage the robot or the tool.\n    object1 : MxCollisionGroup\n        When collision is detected, indicates the first of the two objects that caused the collision\n        (a part of the robot or the tool)\n    object2 : MxCollisionGroup\n        When collision is detected, indicates the second of the two objects that caused the collision\n        (a part of the robot or the tool)\n\"\"\"\n\n    def __init__(self,\n                 collision_detected: bool = False,\n                 collision_object1: CollisionObject = CollisionObject(),\n                 collision_object2: CollisionObject = CollisionObject()):\n        # The following are status fields.\n        self.collision_detected = collision_detected\n        self.object1 = collision_object1\n        self.object2 = collision_object2\n\n    def set_from_response(self, response_args: list[int]) -> list[int]:\n        \"\"\" Set CollisionObject from parsed reply message argument \"\"\"\n        self.collision_detected = bool(response_args.pop(0))\n        response_args = self.object1.set_from_response(response_args)\n        response_args = self.object2.set_from_response(response_args)\n        return response_args\n\n    def __str__(self) -> str:\n        if self.collision_detected:\n            return f'Collision detected between {self.object1} and {self.object2}'\n        else:\n            return 'No collision detected'\n\n    def __repr__(self) -> str:\n        return str(self)",
    "span": [
      2210,
      2254
    ],
    "start_byte": 92115,
    "end_byte": 94266,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "SelfCollisionStatus"
  },
  {
    "snippet": "class WorkZoneStatus:\n    \"\"\"Class for storing the Mecademic robot's \"in work zone\" status.\n       This is used when robot work zone has been defined and enabled (with SetWorkZoneCfg).\n\n    Attributes\n    ----------\n    outside_work_zone : bool\n        True if the a part of the robot or the tool have reached the work zone boundary.\n        Note that when the collision severity is set to MX_EVENT_SEVERITY_PAUSE_MOTION or greater\n        the robot will have stopped just before the robot moves outside the work zone but flag outside_work_zone will\n        still be set to True until ResumeMotion is called.\n        When collision severity is set to MX_EVENT_SEVERITY_WARNING the flag outside_work_zone will report whether the\n        robot is currently outside the work zone.\n    object : MxCollisionGroup\n        Indicate the object that reached the work zone boundary (a part of the robot, or the tool)\n\"\"\"\n\n    def __init__(self, outside_work_zone: bool = False, collision_object: CollisionObject = CollisionObject()):\n        # The following are status fields.\n        self.outside_work_zone = outside_work_zone\n        self.object = collision_object\n\n    def set_from_response(self, response_args: list[int]) -> list[int]:\n        \"\"\" Set CollisionObject from parsed reply message argument \"\"\"\n        self.outside_work_zone = bool(response_args.pop(0))\n        response_args = self.object.set_from_response(response_args)\n        return response_args\n\n    def __str__(self) -> str:\n        if self.outside_work_zone:\n            return f'Work zone boundary reached by {self.object}'\n        else:\n            return 'Robot is inside work zone'\n\n    def __repr__(self) -> str:\n        return str(self)",
    "span": [
      2257,
      2292
    ],
    "start_byte": 94269,
    "end_byte": 95977,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "WorkZoneStatus"
  },
  {
    "snippet": "class CollisionStatus:\n    \"\"\"Class for storing the Mecademic robot's collision status (collision with self or work zone boundary).\n       This is used when robot collision detection has been activated (with SetCollisionCfg) or\n       work zone has been enabled (with SetWorkZoneCfg)\n\n    Attributes\n    ----------\n    self_collision_status : SelfCollisionStatus\n        Current self collision status\n    work_zone_status : WorkZoneStatus\n        Current \"inside work zone\" status\n\"\"\"\n\n    def __init__(self,\n                 self_collision_status: SelfCollisionStatus = SelfCollisionStatus(),\n                 work_zone_status: WorkZoneStatus = WorkZoneStatus()):\n        # The following are status fields.\n        self.self_collision_status = self_collision_status\n        self.work_zone_status = work_zone_status\n\n    def __str__(self) -> str:\n        return f'Collision status: [ {self.self_collision_status}, {self.work_zone_status} ]'\n\n    def __repr__(self) -> str:\n        return str(self)",
    "span": [
      2295,
      2319
    ],
    "start_byte": 95980,
    "end_byte": 96977,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "CollisionStatus"
  },
  {
    "snippet": "class RobotSidecarStatus:\n    \"\"\"Class for storing the status of a \"sidecar\" scripting engine connected to the robot.\n\n    Attributes\n    ----------\n    embedded : bool\n        True if this sidecar instance is running embedded inside the robot.\n    remote_ip : str\n        The IP address of this sidecar instance.\n    registered_functions : list[str]\n        List of functions registered by this sidecar instance.\n\"\"\"\n\n    def __init__(self):\n\n        # The following are status fields.\n        self.id: Optional[int] = None\n        self.embedded = False\n        self.remote_ip = \"\"\n        self.registered_functions: list[str] = []\n\n    def __str__(self) -> str:\n        ip = \"\"\n        if not self.embedded:\n            ip = f\", IP: {self.remote_ip}\"\n        return ((f\"Id: {self.id}, \"\n                 f\"Embedded: {self.embedded}, \"\n                 f\"Ip: {self.remote_ip}{ip}, \"\n                 f\"functions: [{','.join(self.registered_functions)}]\"))",
    "span": [
      2322,
      2350
    ],
    "start_byte": 96980,
    "end_byte": 97936,
    "node_type": "class_definition",
    "language": "python",
    "file_path": "/mnt/d/OneDrive/OneDrive - purdue.edu/Documents/Work/Mecademic/AgentMeca/repos/mecademicpy/mecademicpy/robot_classes.py",
    "name": "RobotSidecarStatus"
  }
]